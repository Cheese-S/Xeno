(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * A manager class for all of the AI in a scene.
 * Keeps a list of registered actors and handles AI generation for actors.
 */
class AIManager {
    constructor() {
        this.actors = new Array();
        this.registeredAI = new Map_1.default();
    }
    /**
     * Registers an actor with the AIManager
     * @param actor The actor to register
     */
    registerActor(actor) {
        this.actors.push(actor);
    }
    removeActor(actor) {
        let index = this.actors.indexOf(actor);
        if (index !== -1) {
            this.actors.splice(index, 1);
        }
    }
    /**
     * Registers an AI with the AIManager for use later on
     * @param name The name of the AI to register
     * @param constr The constructor for the AI
     */
    registerAI(name, constr) {
        this.registeredAI.add(name, constr);
    }
    /**
     * Generates an AI instance from its name
     * @param name The name of the AI to add
     * @returns A new AI instance
     */
    generateAI(name) {
        if (this.registeredAI.has(name)) {
            return new (this.registeredAI.get(name))();
        }
        else {
            throw `Cannot create AI with name ${name}, no AI with that name is registered`;
        }
    }
    update(deltaT) {
        // Run the ai for every active actor
        this.actors.forEach(actor => { if (actor.aiActive)
            actor.ai.update(deltaT); });
    }
}
exports.default = AIManager;

},{"../DataTypes/Map":7}],2:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A placeholder function for No Operation. Does nothing
 */
const NullFunc = () => { };
exports.default = NullFunc;

},{}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A linked-list for the edges in a @reference[Graph].
 */
class EdgeNode {
    /**
     * Creates a new EdgeNode
     * @param index The index of the node this edge connects to
     * @param weight The weight of this edge
     */
    constructor(index, weight) {
        this.y = index;
        this.next = null;
        this.weight = weight ? weight : 1;
    }
}
exports.default = EdgeNode;

},{}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_V = void 0;
const EdgeNode_1 = require("./EdgeNode");
exports.MAX_V = 100;
/**
 * An implementation of a graph data structure using edge lists. Inspired by The Algorithm Design Manual.
 */
class Graph {
    /**
     * Constructs a new graph
     * @param directed Whether or not this graph is directed
     */
    constructor(directed = false) {
        this.directed = directed;
        this.weighted = false;
        this.numVertices = 0;
        this.numEdges = 0;
        this.edges = new Array(exports.MAX_V);
        this.degree = new Array(exports.MAX_V);
    }
    /** Adds a node to this graph and returns the index of it
     * @returns The index of the new node
    */
    addNode() {
        this.numVertices++;
        return this.numVertices;
    }
    /** Adds an edge between node x and y, with an optional weight
     * @param x The index of the start of the edge
     * @param y The index of the end of the edge
     * @param weight The optional weight of the new edge
    */
    addEdge(x, y, weight) {
        let edge = new EdgeNode_1.default(y, weight);
        if (this.edges[x]) {
            edge.next = this.edges[x];
        }
        this.edges[x] = edge;
        if (!this.directed) {
            edge = new EdgeNode_1.default(x, weight);
            if (this.edges[y]) {
                edge.next = this.edges[y];
            }
            this.edges[y] = edge;
        }
        this.numEdges += 1;
    }
    /**
     * Checks whether or not an edge exists between two nodes.
     * This check is directional if this is a directed graph.
     * @param x The first node
     * @param y The second node
     * @returns true if an edge exists, false otherwise
     */
    edgeExists(x, y) {
        let edge = this.edges[x];
        while (edge !== null) {
            if (edge.y === y) {
                return true;
            }
            edge = edge.next;
        }
    }
    /**
     * Gets the edge list associated with node x
     * @param x The index of the node
     * @returns The head of a linked-list of edges
     */
    getEdges(x) {
        return this.edges[x];
    }
    /**
     * Gets the degree associated with node x
     * @param x The index of the node
     */
    getDegree(x) {
        return this.degree[x];
    }
    /**
     * Converts the specifed node into a string
     * @param index The index of the node to convert to a string
     * @returns The string representation of the node: "Node x"
     */
    nodeToString(index) {
        return "Node " + index;
    }
    /**
     * Converts the Graph into a string format
     * @returns The graph as a string
     */
    toString() {
        let retval = "";
        for (let i = 0; i < this.numVertices; i++) {
            let edge = this.edges[i];
            let edgeStr = "";
            while (edge !== undefined && edge !== null) {
                edgeStr += edge.y.toString();
                if (this.weighted) {
                    edgeStr += " (" + edge.weight + ")";
                }
                if (edge.next !== null) {
                    edgeStr += ", ";
                }
                edge = edge.next;
            }
            retval += this.nodeToString(i) + ": " + edgeStr + "\n";
        }
        return retval;
    }
}
exports.default = Graph;

},{"./EdgeNode":3}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graph_1 = require("./Graph");
/**
 * An extension of Graph that has nodes with positions in 2D space.
 * This is a weighted graph (though not inherently directd)
*/
class PositionGraph extends Graph_1.default {
    /**
     * Createes a new PositionGraph
     * @param directed Whether or not this graph is directed
     */
    constructor(directed = false) {
        super(directed);
        this.debugRender = () => {
            // for(let point of this.positions){
            // 	ctx.fillRect((point.x - origin.x - 4)*zoom, (point.y - origin.y - 4)*zoom, 8, 8);
            // }
        };
        this.positions = new Array(Graph_1.MAX_V);
    }
    /**
     * Adds a positioned node to this graph
     * @param position The position of the node to add
     * @returns The index of the added node
     */
    addPositionedNode(position) {
        this.positions[this.numVertices] = position;
        return this.addNode();
    }
    /**
     * Changes the position of a node.
     * Automatically adjusts the weights of the graph tied to this node.
     * As such, be warned that this function has an O(n + m) running time, and use it sparingly.
     * @param index The index of the node
     * @param position The new position of the node
     */
    setNodePosition(index, position) {
        this.positions[index] = position;
        // Recalculate all weights associated with this index
        for (let i = 0; i < this.numEdges; i++) {
            let edge = this.edges[i];
            while (edge !== null) {
                // If this node is on either side of the edge, recalculate weight
                if (i === index || edge.y === index) {
                    edge.weight = this.positions[i].distanceTo(this.positions[edge.y]);
                }
                edge = edge.next;
            }
        }
    }
    /**
     * Gets the position of a node
     * @param index The index of the node
     * @returns The position of the node
     */
    getNodePosition(index) {
        return this.positions[index];
    }
    /**
     * Adds an edge to this graph between node x and y.
     * Automatically calculates the weight of the edge as the distance between the nodes.
     * @param x The beginning of the edge
     * @param y The end of the edge
     */
    addEdge(x, y) {
        if (!this.positions[x] || !this.positions[y]) {
            throw "Can't add edge to un-positioned node!";
        }
        // Weight is the distance between the nodes
        let weight = this.positions[x].distanceTo(this.positions[y]);
        super.addEdge(x, y, weight);
    }
    // @override
    nodeToString(index) {
        return "Node " + index + " - " + this.positions[index].toString();
    }
}
exports.default = PositionGraph;

},{"./Graph":4}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRegion = void 0;
function isRegion(arg) {
    return arg && arg.size && arg.scale && arg.boundary;
}
exports.isRegion = isRegion;

},{}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Associates strings with elements of type T
 */
class Map {
    /** Creates a new map */
    constructor() {
        this.map = {};
    }
    /**
     * Adds a value T stored at a key.
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    add(key, value) {
        this.map[key] = value;
    }
    /**
     * Get the value associated with a key.
     * @param key The key of the item
     * @returns The item at the key or undefined
     */
    get(key) {
        return this.map[key];
    }
    /**
     * An alias of add. Sets the value stored at key to the new specified value
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    set(key, value) {
        this.add(key, value);
    }
    /**
     * Returns true if there is a value stored at the specified key, false otherwise.
     * @param key The key to check
     * @returns A boolean representing whether or not there is an item at the given key.
     */
    has(key) {
        return this.map[key] !== undefined;
    }
    /**
     * Returns an array of all of the keys in this map.
     * @returns An array containing all keys in the map.
     */
    keys() {
        return Object.keys(this.map);
    }
    // @implemented
    forEach(func) {
        Object.keys(this.map).forEach(key => func(key));
    }
    /**
     * Deletes an item associated with a key
     * @param key The key at which to delete an item
     */
    delete(key) {
        delete this.map[key];
    }
    // @implemented
    clear() {
        this.forEach(key => delete this.map[key]);
    }
    /**
     * Converts this map to a string representation.
     * @returns The string representation of this map.
     */
    toString() {
        let str = "";
        this.forEach((key) => str += key + " -> " + this.get(key).toString() + "\n");
        return str;
    }
}
exports.default = Map;

},{}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("./Vec2");
/** A 4x4 matrix0 */
class Mat4x4 {
    constructor() {
        this.mat = new Float32Array([
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0
        ]);
    }
    // Static members
    static get IDENTITY() {
        return new Mat4x4().identity();
    }
    static get ZERO() {
        return new Mat4x4().zero();
    }
    // Accessors
    set _00(x) {
        this.mat[0] = x;
    }
    set(col, row, value) {
        if (col < 0 || col > 3 || row < 0 || row > 3) {
            throw `Error - index (${col}, ${row}) is out of bounds for Mat4x4`;
        }
        this.mat[row * 4 + col] = value;
        return this;
    }
    get(col, row) {
        return this.mat[row * 4 + col];
    }
    setAll(...items) {
        this.mat.set(items);
        return this;
    }
    identity() {
        return this.setAll(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    zero() {
        return this.setAll(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    /**
     * Makes this Mat4x4 a rotation matrix of the specified number of radians ccw
     * @param zRadians The number of radians to rotate
     * @returns this Mat4x4
     */
    rotate(zRadians) {
        return this.setAll(Math.cos(zRadians), -Math.sin(zRadians), 0, 0, Math.sin(zRadians), Math.cos(zRadians), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    /**
     * Turns this Mat4x4 into a translation matrix of the specified translation
     * @param translation The translation in x and y
     * @returns this Mat4x4
     */
    translate(translation) {
        // If translation is a vec, get its array
        if (translation instanceof Vec2_1.default) {
            translation = translation.toArray();
        }
        return this.setAll(1, 0, 0, translation[0], 0, 1, 0, translation[1], 0, 0, 1, 0, 0, 0, 0, 1);
    }
    scale(scale) {
        // Make sure scale is a float32Array
        if (scale instanceof Vec2_1.default) {
            scale = scale.toArray();
        }
        else if (!(scale instanceof Float32Array)) {
            scale = new Float32Array([scale, scale]);
        }
        return this.setAll(scale[0], 0, 0, 0, 0, scale[1], 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    /**
     * Returns a new Mat4x4 that represents the right side multiplication THIS x OTHER
     * @param other The other Mat4x4 to multiply by
     * @returns a new Mat4x4 containing the product of these two Mat4x4s
     */
    mult(other, out) {
        let temp = new Float32Array(16);
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
                let value = 0;
                for (let k = 0; k < 4; k++) {
                    value += this.get(k, i) * other.get(j, k);
                }
                temp[j * 4 + i] = value;
            }
        }
        if (out !== undefined) {
            return out.setAll(...temp);
        }
        else {
            return new Mat4x4().setAll(...temp);
        }
    }
    /**
     * Multiplies all given matricies in order. e.g. MULT(A, B, C) -> A*B*C
     * @param mats A list of Mat4x4s to multiply in order
     * @returns A new Mat4x4 holding the result of the operation
     */
    static MULT(...mats) {
        // Create a new array
        let temp = Mat4x4.IDENTITY;
        // Multiply by every array in order, in place
        for (let i = 0; i < mats.length; i++) {
            temp.mult(mats[i], temp);
        }
        return temp;
    }
    toArray() {
        return this.mat;
    }
    toString() {
        return `|${this.mat[0].toFixed(2)}, ${this.mat[1].toFixed(2)}, ${this.mat[2].toFixed(2)}, ${this.mat[3].toFixed(2)}|\n` +
            `|${this.mat[4].toFixed(2)}, ${this.mat[5].toFixed(2)}, ${this.mat[6].toFixed(2)}, ${this.mat[7].toFixed(2)}|\n` +
            `|${this.mat[8].toFixed(2)}, ${this.mat[9].toFixed(2)}, ${this.mat[10].toFixed(2)}, ${this.mat[11].toFixed(2)}|\n` +
            `|${this.mat[12].toFixed(2)}, ${this.mat[13].toFixed(2)}, ${this.mat[14].toFixed(2)}, ${this.mat[15].toFixed(2)}|`;
    }
}
exports.default = Mat4x4;

},{"./Vec2":18}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A class that contains the area of overlap of two colliding objects to allow for sorting by the physics system.
 */
class AreaCollision {
    /**
     * Creates a new AreaCollision object
     * @param area The area of the collision
     * @param collider The other collider
     */
    constructor(area, collider, other, type, tile) {
        this.area = area;
        this.collider = collider;
        this.other = other;
        this.type = type;
        this.tile = tile;
    }
}
exports.default = AreaCollision;

},{}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
/**
 * An object representing the data collected from a physics hit between two geometric objects.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
class Hit {
    constructor() {
        /** The near times of the collision */
        this.nearTimes = Vec2_1.default.ZERO;
        /** The position of the collision */
        this.pos = Vec2_1.default.ZERO;
        /** The overlap distance of the hit */
        this.delta = Vec2_1.default.ZERO;
        /** The normal vector of the hit */
        this.normal = Vec2_1.default.ZERO;
    }
}
exports.default = Hit;

},{"../Vec2":18}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A FIFO queue with elements of type T
 */
class Queue {
    /**
     * Constructs a new queue
     * @param maxElements The maximum size of the stack
     */
    constructor(maxElements = 100) {
        this.MAX_ELEMENTS = maxElements;
        this.q = new Array(this.MAX_ELEMENTS);
        this.head = 0;
        this.tail = 0;
        this.size = 0;
    }
    /**
     * Adds an item to the back of the queue
     * @param item The item to add to the back of the queue
     */
    enqueue(item) {
        if ((this.tail + 1) % this.MAX_ELEMENTS === this.head) {
            throw new Error("Queue full - cannot add element");
        }
        this.size += 1;
        this.q[this.tail] = item;
        this.tail = (this.tail + 1) % this.MAX_ELEMENTS;
    }
    /**
     * Retrieves an item from the front of the queue
     * @returns The item at the front of the queue
     */
    dequeue() {
        if (this.head === this.tail) {
            throw new Error("Queue empty - cannot remove element");
        }
        this.size -= 1;
        let item = this.q[this.head];
        // Now delete the item
        delete this.q[this.head];
        this.head = (this.head + 1) % this.MAX_ELEMENTS;
        return item;
    }
    /**
     * Returns the item at the front of the queue, but does not remove it
     * @returns The item at the front of the queue
     */
    peekNext() {
        if (this.head === this.tail) {
            throw "Queue empty - cannot get element";
        }
        let item = this.q[this.head];
        return item;
    }
    /**
     * Returns true if the queue has items in it, false otherwise
     * @returns A boolean representing whether or not this queue has items
     */
    hasItems() {
        return this.head !== this.tail;
    }
    /**
     * Returns the number of elements in the queue.
     * @returns The size of the queue
     */
    getSize() {
        return this.size;
    }
    // @implemented
    clear() {
        this.forEach((item, index) => delete this.q[index]);
        this.size = 0;
        this.head = this.tail;
    }
    // @implemented
    forEach(func) {
        let i = this.head;
        while (i !== this.tail) {
            func(this.q[i], i);
            i = (i + 1) % this.MAX_ELEMENTS;
        }
    }
    /**
     * Converts this queue into a string format
     * @returns A string representing this queue
     */
    toString() {
        let retval = "";
        this.forEach((item, index) => {
            let str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    }
}
exports.default = Queue;

},{}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A container for info about a webGL shader program */
class WebGLProgramType {
    /**
     * Deletes this shader program
     */
    delete(gl) {
        // Clean up all aspects of this program
        if (this.program) {
            gl.deleteProgram(this.program);
        }
        if (this.vertexShader) {
            gl.deleteShader(this.vertexShader);
        }
        if (this.fragmentShader) {
            gl.deleteShader(this.fragmentShader);
        }
    }
}
exports.default = WebGLProgramType;

},{}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Shape_1 = require("./Shape");
const Vec2_1 = require("../Vec2");
const MathUtils_1 = require("../../Utils/MathUtils");
const Circle_1 = require("./Circle");
const Hit_1 = require("../Physics/Hit");
/**
 * An Axis-Aligned Bounding Box. In other words, a rectangle that is always aligned to the x-y grid.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
class AABB extends Shape_1.default {
    /**
     * Creates a new AABB
     * @param center The center of the AABB
     * @param halfSize The half size of the AABB - The distance from the center to an edge in x and y
     */
    constructor(center, halfSize) {
        super();
        this.center = center ? center : new Vec2_1.default(0, 0);
        this.halfSize = halfSize ? halfSize : new Vec2_1.default(0, 0);
    }
    /** Returns a point representing the top left corner of the AABB */
    get topLeft() {
        return new Vec2_1.default(this.left, this.top);
    }
    /** Returns a point representing the top right corner of the AABB */
    get topRight() {
        return new Vec2_1.default(this.right, this.top);
    }
    /** Returns a point representing the bottom left corner of the AABB */
    get bottomLeft() {
        return new Vec2_1.default(this.left, this.bottom);
    }
    /** Returns a point representing the bottom right corner of the AABB */
    get bottomRight() {
        return new Vec2_1.default(this.right, this.bottom);
    }
    // @override
    getBoundingRect() {
        return this.clone();
    }
    // @override
    getBoundingCircle() {
        let r = Math.max(this.hw, this.hh);
        return new Circle_1.default(this.center.clone(), r);
    }
    // @deprecated
    getHalfSize() {
        return this.halfSize;
    }
    // @deprecated
    setHalfSize(halfSize) {
        this.halfSize = halfSize;
    }
    // TODO - move these all to the Shape class
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPoint(point) {
        return point.x >= this.x - this.hw && point.x <= this.x + this.hw
            && point.y >= this.y - this.hh && point.y <= this.y + this.hh;
    }
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    intersectPoint(point) {
        let dx = point.x - this.x;
        let px = this.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        let dy = point.y - this.y;
        let py = this.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    }
    /**
     * A boolean check of whether this AABB contains a point with soft left and top boundaries.
     * In other words, if the top left is (0, 0), the point (0, 0) is not in the AABB
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPointSoft(point) {
        return point.x > this.x - this.hw && point.x <= this.x + this.hw
            && point.y > this.y - this.hh && point.y <= this.y + this.hh;
    }
    /**
     * Returns the data from the intersection of this AABB with a line segment from a point in a direction
     * @param point The point that the line segment starts from
     * @param delta The direction and distance of the segment
     * @param padding Pads the AABB to make it wider for the intersection test
     * @returns The Hit object representing the intersection, or null if there was no intersection
     */
    intersectSegment(point, delta, padding) {
        let paddingX = padding ? padding.x : 0;
        let paddingY = padding ? padding.y : 0;
        let scaleX = 1 / delta.x;
        let scaleY = 1 / delta.y;
        let signX = MathUtils_1.default.sign(scaleX);
        let signY = MathUtils_1.default.sign(scaleY);
        let tnearx = scaleX * (this.x - signX * (this.hw + paddingX) - point.x);
        let tneary = scaleY * (this.y - signY * (this.hh + paddingY) - point.y);
        let tfarx = scaleX * (this.x + signX * (this.hw + paddingX) - point.x);
        let tfary = scaleY * (this.y + signY * (this.hh + paddingY) - point.y);
        if (tnearx > tfary || tneary > tfarx) {
            // We aren't colliding - we clear one axis before intersecting another
            return null;
        }
        let tnear = Math.max(tnearx, tneary);
        // Double check for NaNs
        if (tnearx !== tnearx) {
            tnear = tneary;
        }
        else if (tneary !== tneary) {
            tnear = tnearx;
        }
        let tfar = Math.min(tfarx, tfary);
        if (tnear === -Infinity) {
            return null;
        }
        if (tnear >= 1 || tfar <= 0) {
            return null;
        }
        // We are colliding
        let hit = new Hit_1.default();
        hit.time = MathUtils_1.default.clamp01(tnear);
        hit.nearTimes.x = tnearx;
        hit.nearTimes.y = tneary;
        if (tnearx > tneary) {
            // We hit on the left or right size
            hit.normal.x = -signX;
            hit.normal.y = 0;
        }
        else if (Math.abs(tnearx - tneary) < 0.0001) {
            // We hit on the corner
            hit.normal.x = -signX;
            hit.normal.y = -signY;
            hit.normal.normalize();
        }
        else {
            // We hit on the top or bottom
            hit.normal.x = 0;
            hit.normal.y = -signY;
        }
        hit.delta.x = (1.0 - hit.time) * -delta.x;
        hit.delta.y = (1.0 - hit.time) * -delta.y;
        hit.pos.x = point.x + delta.x * hit.time;
        hit.pos.y = point.y + delta.y * hit.time;
        return hit;
    }
    // @override
    overlaps(other) {
        if (other instanceof AABB) {
            return this.overlapsAABB(other);
        }
        throw "Overlap not defined between these shapes.";
    }
    /**
     * A simple boolean check of whether this AABB overlaps another
     * @param other The other AABB to check against
     * @returns True if this AABB overlaps the other, false otherwise
     */
    overlapsAABB(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    }
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The collision sides stored in a Vec2 if the AABBs are touching, null otherwise
     */
    touchesAABB(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        // If one axis is just touching and the other is overlapping, true
        if ((px === 0 && py >= 0) || (py === 0 && px >= 0)) {
            let ret = new Vec2_1.default();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            if (py === 0) {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    }
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Also, if they are only touching corners, they are considered not touching.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The side of the touch, stored as a Vec2, or null if there is no touch
     */
    touchesAABBWithoutCorners(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        // If one axis is touching, and the other is strictly overlapping
        if ((px === 0 && py > 0) || (py === 0 && px > 0)) {
            let ret = new Vec2_1.default();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            else {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    }
    /**
     * Calculates the area of the overlap between this AABB and another
     * @param other The other AABB
     * @returns The area of the overlap between the AABBs
     */
    overlapArea(other) {
        let leftx = Math.max(this.x - this.hw, other.x - other.hw);
        let rightx = Math.min(this.x + this.hw, other.x + other.hw);
        let dx = rightx - leftx;
        let lefty = Math.max(this.y - this.hh, other.y - other.hh);
        let righty = Math.min(this.y + this.hh, other.y + other.hh);
        let dy = righty - lefty;
        if (dx < 0 || dy < 0)
            return 0;
        return dx * dy;
    }
    /**
     * Moves and resizes this rect from its current position to the position specified
     * @param velocity The movement of the rect from its position
     * @param fromPosition A position specified to be the starting point of sweeping
     * @param halfSize The halfSize of the sweeping rect
     */
    sweep(velocity, fromPosition, halfSize) {
        if (!fromPosition) {
            fromPosition = this.center;
        }
        if (!halfSize) {
            halfSize = this.halfSize;
        }
        let centerX = fromPosition.x + velocity.x / 2;
        let centerY = fromPosition.y + velocity.y / 2;
        let minX = Math.min(fromPosition.x - halfSize.x, fromPosition.x + velocity.x - halfSize.x);
        let minY = Math.min(fromPosition.y - halfSize.y, fromPosition.y + velocity.y - halfSize.y);
        this.center.set(centerX, centerY);
        this.halfSize.set(centerX - minX, centerY - minY);
    }
    // @override
    clone() {
        return new AABB(this.center.clone(), this.halfSize.clone());
    }
    /**
     * Converts this AABB to a string format
     * @returns (center: (x, y), halfSize: (x, y))
     */
    toString() {
        return "(center: " + this.center.toString() + ", half-size: " + this.halfSize.toString() + ")";
    }
}
exports.default = AABB;

},{"../../Utils/MathUtils":96,"../Physics/Hit":10,"../Vec2":18,"./Circle":14,"./Shape":15}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
const AABB_1 = require("./AABB");
const Shape_1 = require("./Shape");
/**
 * A Circle
 */
class Circle extends Shape_1.default {
    /**
     * Creates a new Circle
     * @param center The center of the circle
     * @param radius The radius of the circle
     */
    constructor(center, radius) {
        super();
        this._center = center ? center : new Vec2_1.default(0, 0);
        this.radius = radius ? radius : 0;
    }
    get center() {
        return this._center;
    }
    set center(center) {
        this._center = center;
    }
    get halfSize() {
        return new Vec2_1.default(this.radius, this.radius);
    }
    get r() {
        return this.radius;
    }
    set r(radius) {
        this.radius = radius;
    }
    // @override
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPoint(point) {
        return this.center.distanceSqTo(point) <= this.radius * this.radius;
    }
    // @override
    getBoundingRect() {
        return new AABB_1.default(this._center.clone(), new Vec2_1.default(this.radius, this.radius));
    }
    // @override
    getBoundingCircle() {
        return this.clone();
    }
    // @override
    overlaps(other) {
        throw new Error("Method not implemented.");
    }
    // @override
    clone() {
        return new Circle(this._center.clone(), this.radius);
    }
    toString() {
        return "(center: " + this.center.toString() + ", radius: " + this.radius + ")";
    }
}
exports.default = Circle;

},{"../Vec2":18,"./AABB":13,"./Shape":15}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
const AABB_1 = require("./AABB");
/**
 * An abstract Shape class that acts as an interface for better interactions with subclasses.
 */
class Shape {
    get x() {
        return this.center.x;
    }
    get y() {
        return this.center.y;
    }
    get hw() {
        return this.halfSize.x;
    }
    get hh() {
        return this.halfSize.y;
    }
    get top() {
        return this.y - this.hh;
    }
    get bottom() {
        return this.y + this.hh;
    }
    get left() {
        return this.x - this.hw;
    }
    get right() {
        return this.x + this.hw;
    }
    static getTimeOfCollision(A, velA, B, velB) {
        if (A instanceof AABB_1.default && B instanceof AABB_1.default) {
            return Shape.getTimeOfCollision_AABB_AABB(A, velA, B, velB);
        }
    }
    static getTimeOfCollision_AABB_AABB(A, velA, B, velB) {
        let posSmaller = A.center;
        let posLarger = B.center;
        let sizeSmaller = A.halfSize;
        let sizeLarger = B.halfSize;
        let firstContact = new Vec2_1.default(0, 0);
        let lastContact = new Vec2_1.default(0, 0);
        let collidingX = false;
        let collidingY = false;
        // Sort by position
        if (posLarger.x < posSmaller.x) {
            // Swap, because smaller is further right than larger
            let temp;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is left, B is right
        firstContact.x = Infinity;
        lastContact.x = Infinity;
        if (posLarger.x - sizeLarger.x >= posSmaller.x + sizeSmaller.x) {
            // If we aren't currently colliding
            let relVel = velA.x - velB.x;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.x = ((posLarger.x - sizeLarger.x) - (posSmaller.x + sizeSmaller.x)) / (relVel);
                lastContact.x = ((posLarger.x + sizeLarger.x) - (posSmaller.x - sizeSmaller.x)) / (relVel);
            }
        }
        else {
            collidingX = true;
        }
        if (posLarger.y < posSmaller.y) {
            // Swap, because smaller is further up than larger
            let temp;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is top, B is bottom
        firstContact.y = Infinity;
        lastContact.y = Infinity;
        if (posLarger.y - sizeLarger.y >= posSmaller.y + sizeSmaller.y) {
            // If we aren't currently colliding
            let relVel = velA.y - velB.y;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.y = ((posLarger.y - sizeLarger.y) - (posSmaller.y + sizeSmaller.y)) / (relVel);
                lastContact.y = ((posLarger.y + sizeLarger.y) - (posSmaller.y - sizeSmaller.y)) / (relVel);
            }
        }
        else {
            collidingY = true;
        }
        return [firstContact, lastContact, collidingX, collidingY];
    }
}
exports.default = Shape;

},{"../Vec2":18,"./AABB":13}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A LIFO stack with items of type T
 */
class Stack {
    /**
     * Constructs a new stack
     * @param maxElements The maximum size of the stack
     */
    constructor(maxElements = 100) {
        this.MAX_ELEMENTS = maxElements;
        this.stack = new Array(this.MAX_ELEMENTS);
        this.head = -1;
    }
    /**
     * Adds an item to the top of the stack
     * @param item The new item to add to the stack
     */
    push(item) {
        if (this.head + 1 === this.MAX_ELEMENTS) {
            throw "Stack full - cannot add element";
        }
        this.head += 1;
        this.stack[this.head] = item;
    }
    /**
     * Removes an item from the top of the stack
     * @returns The item at the top of the stack
     */
    pop() {
        if (this.head === -1) {
            throw "Stack empty - cannot remove element";
        }
        this.head -= 1;
        return this.stack[this.head + 1];
    }
    /**
     * Returns the element currently at the top of the stack
     * @returns The item at the top of the stack
     */
    peek() {
        if (this.head === -1) {
            throw "Stack empty - cannot get element";
        }
        return this.stack[this.head];
    }
    /** Returns true if this stack is empty
     * @returns A boolean that represents whether or not the stack is empty
    */
    isEmpty() {
        return this.head === -1;
    }
    // @implemented
    clear() {
        this.forEach((item, index) => delete this.stack[index]);
        this.head = -1;
    }
    /**
     * Returns the number of items currently in the stack
     * @returns The number of items in the stack
     */
    size() {
        return this.head + 1;
    }
    // @implemented
    forEach(func) {
        let i = 0;
        while (i <= this.head) {
            func(this.stack[i], i);
            i += 1;
        }
    }
    /**
     * Converts this stack into a string format
     * @returns A string representing this stack
     */
    toString() {
        let retval = "";
        this.forEach((item, index) => {
            let str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    }
}
exports.default = Stack;

},{}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../Vec2");
/**
 * The data representation of a Tileset for the game engine. This represents one image,
 * with a startIndex if required (as it is with Tiled using two images in one tilset).
 */
class Tileset {
    // TODO: Change this to be more general and work with other tileset formats
    constructor(tilesetData) {
        // Defer handling of the data to a helper class
        this.initFromTiledData(tilesetData);
    }
    /**
     * Initialize the tileset from the data from a Tiled json file
     * @param tiledData The parsed object from a Tiled json file
     */
    initFromTiledData(tiledData) {
        this.numRows = tiledData.tilecount / tiledData.columns;
        this.numCols = tiledData.columns;
        this.startIndex = tiledData.firstgid;
        this.endIndex = this.startIndex + tiledData.tilecount - 1;
        this.tileSize = new Vec2_1.default(tiledData.tilewidth, tiledData.tilewidth);
        this.imageKey = tiledData.image;
        this.imageSize = new Vec2_1.default(tiledData.imagewidth, tiledData.imageheight);
    }
    /**
     * Gets the image key associated with this tilemap
     * @returns The image key of this tilemap
     */
    getImageKey() {
        return this.imageKey;
    }
    /**
     * Returns a Vec2 containing the left and top offset from the image origin for this tile.
     * @param tileIndex The index of the tile from startIndex to endIndex of this tileset
     * @returns A Vec2 containing the offset for the specified tile.
     */
    getImageOffsetForTile(tileIndex) {
        // Get the true index
        let index = tileIndex - this.startIndex;
        let row = Math.floor(index / this.numCols);
        let col = index % this.numCols;
        let width = this.tileSize.x;
        let height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        return new Vec2_1.default(left, top);
    }
    /**
     * Gets the start index
     * @returns The start index
     */
    getStartIndex() {
        return this.startIndex;
    }
    /**
     * Gets the tile set
     * @returns A Vec2 containing the tile size
     */
    getTileSize() {
        return this.tileSize;
    }
    /**
     * Gets the number of rows in the tileset
     * @returns The number of rows
     */
    getNumRows() {
        return this.numRows;
    }
    /**
     * Gets the number of columns in the tilset
     * @returns The number of columns
     */
    getNumCols() {
        return this.numCols;
    }
    getTileCount() {
        return this.endIndex - this.startIndex + 1;
    }
    /**
     * Checks whether or not this tilset contains the specified tile index. This is used for rendering.
     * @param tileIndex The index of the tile to check
     * @returns A boolean representing whether or not this tilset uses the specified index
     */
    hasTile(tileIndex) {
        return tileIndex >= this.startIndex && tileIndex <= this.endIndex;
    }
    /**
     * Render a singular tile with index tileIndex from the tileset located at position dataIndex
     * @param ctx The rendering context
     * @param tileIndex The value of the tile to render
     * @param dataIndex The index of the tile in the data array
     * @param worldSize The size of the world
     * @param origin The viewport origin in the current layer
     * @param scale The scale of the tilemap
     */
    renderTile(ctx, tileIndex, dataIndex, maxCols, origin, scale, zoom) {
        let image = ResourceManager_1.default.getInstance().getImage(this.imageKey);
        // Get the true index
        let index = tileIndex - this.startIndex;
        let row = Math.floor(index / this.numCols);
        let col = index % this.numCols;
        let width = this.tileSize.x;
        let height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        // Calculate the position in the world to render the tile
        let x = Math.floor((dataIndex % maxCols) * width * scale.x);
        let y = Math.floor(Math.floor(dataIndex / maxCols) * height * scale.y);
        ctx.drawImage(image, left, top, width, height, Math.floor((x - origin.x) * zoom), Math.floor((y - origin.y) * zoom), Math.ceil(width * scale.x * zoom), Math.ceil(height * scale.y * zoom));
    }
}
exports.default = Tileset;

},{"../../ResourceManager/ResourceManager":77,"../Vec2":18}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("../Utils/MathUtils");
/**
 * A two-dimensional vector (x, y)
 */
class Vec2 {
    /**
     * Creates a new Vec2
     * @param x The x value of the vector
     * @param y The y value of the vector
     */
    constructor(x = 0, y = 0) {
        /**
         * When this vector changes its value, do something
         */
        this.onChange = () => { };
        this.vec = new Float32Array(2);
        this.vec[0] = x;
        this.vec[1] = y;
    }
    // Expose x and y with getters and setters
    get x() {
        return this.vec[0];
    }
    set x(x) {
        this.vec[0] = x;
        if (this.onChange) {
            this.onChange();
        }
    }
    get y() {
        return this.vec[1];
    }
    set y(y) {
        this.vec[1] = y;
        if (this.onChange) {
            this.onChange();
        }
    }
    static get ZERO() {
        return new Vec2(0, 0);
    }
    static get INF() {
        return new Vec2(Infinity, Infinity);
    }
    static get UP() {
        return new Vec2(0, -1);
    }
    static get DOWN() {
        return new Vec2(0, 1);
    }
    static get LEFT() {
        return new Vec2(-1, 0);
    }
    static get RIGHT() {
        return new Vec2(1, 0);
    }
    /**
     * The squared magnitude of the vector. This tends to be faster, so use it in situations where taking the
     * square root doesn't matter, like for comparing distances.
     * @returns The squared magnitude of the vector
     */
    magSq() {
        return this.x * this.x + this.y * this.y;
    }
    /**
     * The magnitude of the vector.
     * @returns The magnitude of the vector.
     */
    mag() {
        return Math.sqrt(this.magSq());
    }
    /**
     * Divdes x and y by the magnitude to obtain the unit vector in the direction of this vector.
     * @returns This vector as a unit vector.
     */
    normalize() {
        if (this.x === 0 && this.y === 0)
            return this;
        let mag = this.mag();
        this.x /= mag;
        this.y /= mag;
        return this;
    }
    /**
     * Works like normalize(), but returns a new Vec2
     * @returns A new vector that is the unit vector for this one
     */
    normalized() {
        if (this.isZero()) {
            return this;
        }
        let mag = this.mag();
        return new Vec2(this.x / mag, this.y / mag);
    }
    /**
     * Sets the x and y elements of this vector to zero.
     * @returns This vector, with x and y set to zero.
     */
    zero() {
        return this.set(0, 0);
    }
    /**
     * Sets the vector's x and y based on the angle provided. Goes counter clockwise.
     * @param angle The angle in radians
     * @param radius The magnitude of the vector at the specified angle
     * @returns This vector.
     */
    setToAngle(angle, radius = 1) {
        this.x = MathUtils_1.default.floorToPlace(Math.cos(angle) * radius, 5);
        this.y = MathUtils_1.default.floorToPlace(-Math.sin(angle) * radius, 5);
        return this;
    }
    /**
     * Returns a vector that point from this vector to another one
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided
     */
    vecTo(other) {
        return new Vec2(other.x - this.x, other.y - this.y);
    }
    /**
     * Returns a vector containing the direction from this vector to another
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided. This new Vec2 will be a unit vector.
     */
    dirTo(other) {
        return this.vecTo(other).normalize();
    }
    /**
     * Keeps the vector's direction, but sets its magnitude to be the provided magnitude
     * @param magnitude The magnitude the vector should be
     * @returns This vector with its magnitude set to the new magnitude
     */
    scaleTo(magnitude) {
        return this.normalize().scale(magnitude);
    }
    /**
     * Scales x and y by the number provided, or if two number are provided, scales them individually.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns This vector after scaling
     */
    scale(factor, yFactor = null) {
        if (yFactor !== null) {
            this.x *= factor;
            this.y *= yFactor;
            return this;
        }
        this.x *= factor;
        this.y *= factor;
        return this;
    }
    /**
     * Returns a scaled version of this vector without modifying it.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns A new vector that has the values of this vector after scaling
     */
    scaled(factor, yFactor = null) {
        return this.clone().scale(factor, yFactor);
    }
    /**
     * Rotates the vector counter-clockwise by the angle amount specified
     * @param angle The angle to rotate by in radians
     * @returns This vector after rotation.
     */
    rotateCCW(angle) {
        let cs = Math.cos(angle);
        let sn = Math.sin(angle);
        let tempX = this.x * cs - this.y * sn;
        let tempY = this.x * sn + this.y * cs;
        this.x = tempX;
        this.y = tempY;
        return this;
    }
    /**
     * Sets the vectors coordinates to be the ones provided
     * @param x The new x value for this vector
     * @param y The new y value for this vector
     * @returns This vector
     */
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    /**
     * Copies the values of the other Vec2 into this one.
     * @param other The Vec2 to copy
     * @returns This vector with its values set to the vector provided
     */
    copy(other) {
        return this.set(other.x, other.y);
    }
    /**
     * Adds this vector the another vector
     * @param other The Vec2 to add to this one
     * @returns This vector after adding the one provided
     */
    add(other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }
    /**
     * Increments the fields of this vector. Both are incremented with a, if only a is provided.
     * @param a The first number to increment by
     * @param b The second number to increment by
     * @returnss This vector after incrementing
     */
    inc(a, b) {
        if (b === undefined) {
            this.x += a;
            this.y += a;
        }
        else {
            this.x += a;
            this.y += b;
        }
        return this;
    }
    /**
     * Subtracts another vector from this vector
     * @param other The Vec2 to subtract from this one
     * @returns This vector after subtracting the one provided
     */
    sub(other) {
        this.x -= other.x;
        this.y -= other.y;
        return this;
    }
    /**
     * Multiplies this vector with another vector element-wise. In other words, this.x *= other.x and this.y *= other.y
     * @param other The Vec2 to multiply this one by
     * @returns This vector after multiplying its components by this one
     */
    mult(other) {
        this.x *= other.x;
        this.y *= other.y;
        return this;
    }
    /**
     * Divides this vector with another vector element-wise. In other words, this.x /= other.x and this.y /= other.y
     * @param other The vector to divide this one by
     * @returns This vector after division
     */
    div(other) {
        if (other.x === 0 || other.y === 0)
            throw "Divide by zero error";
        this.x /= other.x;
        this.y /= other.y;
        return this;
    }
    /**
     * Does an element wise remainder operation on this vector. this.x %= other.x and this.y %= other.y
     * @param other The other vector
     * @returns this vector
     */
    remainder(other) {
        this.x = this.x % other.x;
        this.y = this.y % other.y;
        return this;
    }
    /**
     * Returns the squared distance between this vector and another vector
     * @param other The vector to compute distance squared to
     * @returns The squared distance between this vector and the one provided
     */
    distanceSqTo(other) {
        return (this.x - other.x) * (this.x - other.x) + (this.y - other.y) * (this.y - other.y);
    }
    /**
     * Returns the distance between this vector and another vector
     * @param other The vector to compute distance to
     * @returns The distance between this vector and the one provided
     */
    distanceTo(other) {
        return Math.sqrt(this.distanceSqTo(other));
    }
    /**
     * Returns the dot product of this vector and another
     * @param other The vector to compute the dot product with
     * @returns The dot product of this vector and the one provided.
     */
    dot(other) {
        return this.x * other.x + this.y * other.y;
    }
    /**
     * Returns the angle counter-clockwise in radians from this vector to another vector
     * @param other The vector to compute the angle to
     * @returns The angle, rotating CCW, from this vector to the other vector
     */
    angleToCCW(other) {
        let dot = this.dot(other);
        let det = this.x * other.y - this.y * other.x;
        let angle = -Math.atan2(det, dot);
        if (angle < 0) {
            angle += 2 * Math.PI;
        }
        return angle;
    }
    /**
     * Returns a string representation of this vector rounded to 1 decimal point
     * @returns This vector as a string
     */
    toString() {
        return this.toFixed();
    }
    /**
     * Returns a string representation of this vector rounded to the specified number of decimal points
     * @param numDecimalPoints The number of decimal points to create a string to
     * @returns This vector as a string
     */
    toFixed(numDecimalPoints = 1) {
        return "(" + this.x.toFixed(numDecimalPoints) + ", " + this.y.toFixed(numDecimalPoints) + ")";
    }
    /**
     * Returns a new vector with the same coordinates as this one.
     * @returns A new Vec2 with the same values as this one
     */
    clone() {
        return new Vec2(this.x, this.y);
    }
    /**
     * Returns true if this vector and other have the EXACT same x and y (not assured to be safe for floats)
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    strictEquals(other) {
        return this.x === other.x && this.y === other.y;
    }
    /**
     * Returns true if this vector and other have the same x and y
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    equals(other) {
        let xEq = Math.abs(this.x - other.x) < 0.0000001;
        let yEq = Math.abs(this.y - other.y) < 0.0000001;
        return xEq && yEq;
    }
    /**
     * Returns true if this vector is the zero vector exactly (not assured to be safe for floats).
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    strictIsZero() {
        return this.x === 0 && this.y === 0;
    }
    /**
     * Returns true if this x and y for this vector are both zero.
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    isZero() {
        return Math.abs(this.x) < 0.0000001 && Math.abs(this.y) < 0.0000001;
    }
    /**
     * Sets the function that is called whenever this vector is changed.
     * @param f The function to be called
     */
    setOnChange(f) {
        this.onChange = f;
    }
    toArray() {
        return this.vec;
    }
    /**
     * Performs linear interpolation between two vectors
     * @param a The first vector
     * @param b The second vector
     * @param t The time of the lerp, with 0 being vector A, and 1 being vector B
     * @returns A new Vec2 representing the lerp between vector a and b.
     */
    static lerp(a, b, t) {
        return new Vec2(MathUtils_1.default.lerp(a.x, b.x, t), MathUtils_1.default.lerp(a.y, b.y, t));
    }
}
exports.default = Vec2;
Vec2.ZERO_STATIC = new Vec2(0, 0);

},{"../Utils/MathUtils":96}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const Vec2_1 = require("../DataTypes/Vec2");
const Color_1 = require("../Utils/Color");
/**
 * A util class for rendering Debug messages to the canvas.
 */
class Debug {
    /**
     * Add a message to display on the debug screen
     * @param id A unique ID for this message
     * @param messages The messages to print to the debug screen
     */
    static log(id, ...messages) {
        // let message = "";
        // for(let i = 0; i < messages.length; i++){
        // 	message += messages[i].toString();
        // }
        // Join all messages with spaces
        let message = messages.map((m) => m.toString()).join(" ");
        this.logMessages.add(id, message);
    }
    /**
     * Deletes a a key from the log and stops it from keeping up space on the screen
     * @param id The id of the log item to clear
     */
    static clearLogItem(id) {
        this.logMessages.delete(id);
    }
    /**
     * Sets the list of nodes to render with the debugger
     * @param nodes The new list of nodes
     */
    static setNodes(nodes) {
        this.nodes = nodes;
    }
    /**
     * Draws a box at the specified position
     * @param center The center of the box
     * @param halfSize The dimensions of the box
     * @param filled A boolean for whether or not the box is filled
     * @param color The color of the box to draw
     */
    static drawBox(center, halfSize, filled, color) {
        let alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.fillRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        else {
            let lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.strokeRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        this.debugRenderingContext.globalAlpha = alpha;
    }
    /**
     * Draws a circle at the specified position
     * @param center The center of the circle
     * @param radius The dimensions of the box
     * @param filled A boolean for whether or not the circle is filled
     * @param color The color of the circle
     */
    static drawCircle(center, radius, filled, color) {
        let alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.fill();
        }
        else {
            let lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.stroke();
        }
        this.debugRenderingContext.globalAlpha = alpha;
    }
    /**
     * Draws a ray at the specified position
     * @param from The starting position of the ray
     * @param to The ending position of the ray
     * @param color The color of the ray
     */
    static drawRay(from, to, color) {
        this.debugRenderingContext.lineWidth = 2;
        this.debugRenderingContext.strokeStyle = color.toString();
        this.debugRenderingContext.beginPath();
        this.debugRenderingContext.moveTo(from.x, from.y);
        this.debugRenderingContext.lineTo(to.x, to.y);
        this.debugRenderingContext.closePath();
        this.debugRenderingContext.stroke();
    }
    /**
     * Draws a point at the specified position
     * @param pos The position of the point
     * @param color The color of the point
     */
    static drawPoint(pos, color) {
        let pointSize = 6;
        this.debugRenderingContext.fillStyle = color.toString();
        this.debugRenderingContext.fillRect(pos.x - pointSize / 2, pos.y - pointSize / 2, pointSize, pointSize);
    }
    /**
     * Sets the default rendering color for text for the debugger
     * @param color The color to render the text
     */
    static setDefaultTextColor(color) {
        this.defaultTextColor = color;
    }
    /**
     * Performs any necessary setup operations on the Debug canvas
     * @param canvas The debug canvas
     * @param width The desired width of the canvas
     * @param height The desired height of the canvas
     * @returns The rendering context extracted from the canvas
     */
    static initializeDebugCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.debugCanvasSize = new Vec2_1.default(width, height);
        this.debugRenderingContext = canvas.getContext("2d");
        return this.debugRenderingContext;
    }
    /** Clears the debug canvas */
    static clearCanvas() {
        this.debugRenderingContext.clearRect(0, 0, this.debugCanvasSize.x, this.debugCanvasSize.y);
    }
    /** Renders the text and nodes sent to the Debug system */
    static render() {
        this.renderText();
        this.renderNodes();
    }
    /** Renders the text sent to the Debug canvas */
    static renderText() {
        let y = 20;
        this.debugRenderingContext.font = "20px Arial";
        this.debugRenderingContext.fillStyle = this.defaultTextColor.toString();
        // Draw all of the text
        this.logMessages.forEach((key) => {
            this.debugRenderingContext.fillText(this.logMessages.get(key), 10, y);
            y += 30;
        });
    }
    /** Renders the nodes registered with the debug canvas */
    static renderNodes() {
        if (this.nodes) {
            this.nodes.forEach(node => {
                node.debugRender();
            });
        }
    }
}
exports.default = Debug;
/** A map of log messages to display on the screen */
Debug.logMessages = new Map_1.default();
/** The rendering color for text */
Debug.defaultTextColor = Color_1.default.WHITE;

},{"../DataTypes/Map":7,"../DataTypes/Vec2":18,"../Utils/Color":93}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = require("../Utils/Color");
// @ignorePage
class Stats extends Object {
    static initStats() {
        let canvas = document.getElementById("stats-canvas");
        canvas.width = this.CANVAS_WIDTH;
        canvas.height = this.CANVAS_HEIGHT;
        this.ctx = canvas.getContext("2d");
        this.statsDiv = document.getElementById("stats-display");
        this.prevfps = new Array();
        this.prevClearTimes = new Array();
        this.SGClearTimes = new Array();
        this.avgSGClearTime = 0;
        this.prevFillTimes = new Array();
        this.SGFillTimes = new Array();
        this.avgSGFillTime = 0;
        this.prevUpdateTimes = new Array();
        this.SGUpdateTimes = new Array();
        this.avgSGUpdateTime = 0;
        this.prevQueryTimes = new Array();
        this.SGQueryTimes = new Array();
        this.avgSGQueryTime = 0;
        let clearTime = document.createElement("span");
        clearTime.setAttribute("id", "sgclear");
        let fillTime = document.createElement("span");
        fillTime.setAttribute("id", "sgfill");
        let updateTime = document.createElement("span");
        updateTime.setAttribute("id", "sgupdate");
        let queryTime = document.createElement("span");
        queryTime.setAttribute("id", "sgquery");
        let br1 = document.createElement("br");
        let br2 = document.createElement("br");
        let br3 = document.createElement("br");
        this.statsDiv.append(clearTime, br1, fillTime, br2, updateTime, br3, queryTime);
        this.graphChoices = document.getElementById("chart-option");
        let option1 = document.createElement("option");
        option1.value = "prevfps";
        option1.label = "FPS";
        let option2 = document.createElement("option");
        option2.value = "prevClearTimes";
        option2.label = "Clear Time";
        let option3 = document.createElement("option");
        option3.value = "prevFillTimes";
        option3.label = "Fill time";
        let option4 = document.createElement("option");
        option4.value = "prevUpdateTimes";
        option4.label = "Update time";
        let option5 = document.createElement("option");
        option5.value = "prevQueryTimes";
        option5.label = "Query Time";
        let optionAll = document.createElement("option");
        optionAll.value = "all";
        optionAll.label = "All";
        this.graphChoices.append(option1, option2, option3, option4, option5, optionAll);
    }
    static updateFPS(fps) {
        this.prevfps.push(fps);
        if (this.prevfps.length > Stats.NUM_POINTS) {
            this.prevfps.shift();
        }
        if (this.SGClearTimes.length > 0) {
            this.prevClearTimes.push(this.avgSGClearTime);
            if (this.prevClearTimes.length > this.NUM_POINTS) {
                this.prevClearTimes.shift();
            }
        }
        if (this.SGFillTimes.length > 0) {
            this.prevFillTimes.push(this.avgSGFillTime);
            if (this.prevFillTimes.length > this.NUM_POINTS) {
                this.prevFillTimes.shift();
            }
        }
        if (this.SGUpdateTimes.length > 0) {
            this.prevUpdateTimes.push(this.avgSGUpdateTime);
            if (this.prevUpdateTimes.length > this.NUM_POINTS) {
                this.prevUpdateTimes.shift();
            }
        }
        if (this.SGQueryTimes.length > 0) {
            this.prevQueryTimes.push(this.avgSGQueryTime);
            if (this.prevQueryTimes.length > this.NUM_POINTS) {
                this.prevQueryTimes.shift();
            }
        }
        this.updateSGStats();
    }
    static log(key, data) {
        if (key === "sgclear") {
            this.SGClearTimes.push(data);
            if (this.SGClearTimes.length > 100) {
                this.SGClearTimes.shift();
            }
        }
        else if (key === "sgfill") {
            this.SGFillTimes.push(data);
            if (this.SGFillTimes.length > 100) {
                this.SGFillTimes.shift();
            }
        }
        else if (key === "sgupdate") {
            this.SGUpdateTimes.push(data);
            if (this.SGUpdateTimes.length > 100) {
                this.SGUpdateTimes.shift();
            }
        }
        else if (key === "sgquery") {
            this.SGQueryTimes.push(data);
            if (this.SGQueryTimes.length > 1000) {
                this.SGQueryTimes.shift();
            }
        }
    }
    static render() {
        // Display stats
        this.drawCharts();
    }
    static drawCharts() {
        this.ctx.clearRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT);
        let paramString = this.graphChoices.value;
        if (paramString === "prevfps" || paramString === "all") {
            let param = this.prevfps;
            let color = Color_1.default.BLUE.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevClearTimes" || paramString === "all") {
            let param = this.prevClearTimes;
            let color = Color_1.default.RED.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevFillTimes" || paramString === "all") {
            let param = this.prevFillTimes;
            let color = Color_1.default.GREEN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevUpdateTimes" || paramString === "all") {
            let param = this.prevUpdateTimes;
            let color = Color_1.default.CYAN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevQueryTimes" || paramString === "all") {
            let param = this.prevQueryTimes;
            let color = Color_1.default.ORANGE.toString();
            this.drawChart(param, color);
        }
    }
    static drawChart(param, color) {
        this.ctx.strokeStyle = Color_1.default.BLACK.toString();
        this.ctx.beginPath();
        this.ctx.moveTo(10, 10);
        this.ctx.lineTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.beginPath();
        this.ctx.moveTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.lineTo(this.CANVAS_WIDTH - 10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        let max = Math.max(...param);
        let prevX = 10;
        let prevY = this.CANVAS_HEIGHT - 10 - param[0] / max * (this.CANVAS_HEIGHT - 20);
        this.ctx.strokeStyle = color;
        for (let i = 1; i < param.length; i++) {
            let fps = param[i];
            let x = 10 + i * (this.CANVAS_WIDTH - 20) / this.NUM_POINTS;
            let y = this.CANVAS_HEIGHT - 10 - fps / max * (this.CANVAS_HEIGHT - 20);
            this.ctx.beginPath();
            this.ctx.moveTo(prevX, prevY);
            this.ctx.lineTo(x, y);
            this.ctx.closePath();
            this.ctx.stroke();
            prevX = x;
            prevY = y;
        }
    }
    static updateSGStats() {
        if (this.SGClearTimes.length > 0) {
            this.avgSGClearTime = this.SGClearTimes.reduce((acc, val) => acc + val) / this.SGClearTimes.length;
        }
        if (this.SGFillTimes.length > 0) {
            this.avgSGFillTime = this.SGFillTimes.reduce((acc, val) => acc + val) / this.SGFillTimes.length;
        }
        if (this.SGUpdateTimes.length > 0) {
            this.avgSGUpdateTime = this.SGUpdateTimes.reduce((acc, val) => acc + val) / this.SGUpdateTimes.length;
        }
        if (this.SGQueryTimes.length > 0) {
            this.avgSGQueryTime = this.SGQueryTimes.reduce((acc, val) => acc + val) / this.SGQueryTimes.length;
        }
        document.getElementById("sgclear").innerHTML = "Avg SG clear time: " + this.avgSGClearTime;
        document.getElementById("sgfill").innerHTML = "Avg SG fill time: " + this.avgSGFillTime;
        document.getElementById("sgupdate").innerHTML = "Avg SG update time: " + this.avgSGUpdateTime;
        document.getElementById("sgquery").innerHTML = "Avg SG query time: " + this.avgSGQueryTime;
    }
}
exports.default = Stats;
Stats.NUM_POINTS = 60;
Stats.CANVAS_WIDTH = 300;
Stats.CANVAS_HEIGHT = 300;

},{"../Utils/Color":93}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("./EventQueue");
const GameEvent_1 = require("./GameEvent");
/**
 * An event emitter object other systems can use to hook into the EventQueue.
 * Provides an easy interface for firing off events.
 */
class Emitter {
    /** Creates a new Emitter */
    constructor() {
        this.eventQueue = EventQueue_1.default.getInstance();
    }
    /**
     * Emit and event of type eventType with the data packet data
     * @param eventType The name of the event to fire off
     * @param data A @reference[Map] or record containing any data about the event
     */
    fireEvent(eventType, data = null) {
        this.eventQueue.addEvent(new GameEvent_1.default(eventType, data));
    }
}
exports.default = Emitter;

},{"./EventQueue":22,"./GameEvent":23}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const Map_1 = require("../DataTypes/Map");
const GameEventType_1 = require("./GameEventType");
/**
 * The main event system of the game engine.
 * Events are sent to the EventQueue, which handles distribution to any systems that are listening for those events.
 * This allows for handling of input without having classes directly hook into javascript event handles,
 * and allows otherwise separate classes to communicate with each other cleanly, such as a Player object
 * requesting a sound be played by the audio system.
 *
 * The distribution of @reference[GameEvent]s happens as follows:
 *
 * Events are recieved throughout a frame and are queued up by the EventQueue.
 * At the beginning of the next frame, events are sent out to any receivers that are hooked into the event type.
 * @reference[Receiver]s are then free to process events as they see fit.
 *
 * Overall, the EventQueue can be considered as something similar to an email server,
 * and the @reference[Receiver]s can be considered as the client inboxes.
 *
 * See @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/event-queue.html) for more discussion on EventQueues
 */
class EventQueue {
    constructor() {
        this.MAX_SIZE = 100;
        this.q = new Queue_1.default(this.MAX_SIZE);
        this.receivers = new Map_1.default();
    }
    /** Retrieves the instance of the Singleton EventQueue */
    static getInstance() {
        if (this.instance === null) {
            this.instance = new EventQueue();
        }
        return this.instance;
    }
    /** Adds an event to the EventQueue.
     * This is exposed to the rest of the game engine through the @reference[Emitter] class */
    addEvent(event) {
        this.q.enqueue(event);
    }
    /**
     * Associates a receiver with a type of event. Every time this event appears in the future,
     * it will be given to the receiver (and any others watching that type).
     * This is exposed to the rest of the game engine through the @reference[Receiver] class
     * @param receiver The event receiver
     * @param type The type or types of events to subscribe to
     */
    subscribe(receiver, type) {
        if (type instanceof Array) {
            // If it is an array, subscribe to all event types
            for (let t of type) {
                this.addListener(receiver, t);
            }
        }
        else {
            this.addListener(receiver, type);
        }
    }
    /**
     * Unsubscribes the specified receiver from all events, or from whatever events are provided
     * @param receiver The receiver to unsubscribe
     * @param keys The events to unsubscribe from. If none are provided, unsubscribe from all
     */
    unsubscribe(receiver, ...events) {
        this.receivers.forEach(eventName => {
            // If keys were provided, only continue if this key is one of them
            if (events.length > 0 && events.indexOf(eventName) === -1)
                return;
            // Find the index of our receiver for this key
            let index = this.receivers.get(eventName).indexOf(receiver);
            // If an index was found, remove the receiver
            if (index !== -1) {
                this.receivers.get(eventName).splice(index, 1);
            }
        });
    }
    // Associate the receiver and the type
    addListener(receiver, type) {
        if (this.receivers.has(type)) {
            this.receivers.get(type).push(receiver);
        }
        else {
            this.receivers.add(type, [receiver]);
        }
    }
    update(deltaT) {
        while (this.q.hasItems()) {
            // Retrieve each event
            let event = this.q.dequeue();
            // If a receiver has this event type, send it the event
            if (this.receivers.has(event.type)) {
                for (let receiver of this.receivers.get(event.type)) {
                    receiver.receive(event);
                }
            }
            // If a receiver is subscribed to all events, send it the event
            if (this.receivers.has(GameEventType_1.GameEventType.ALL)) {
                for (let receiver of this.receivers.get(GameEventType_1.GameEventType.ALL)) {
                    receiver.receive(event);
                }
            }
        }
    }
}
exports.default = EventQueue;
EventQueue.instance = null;

},{"../DataTypes/Map":7,"../DataTypes/Queue":11,"./GameEventType":24}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * A representation of an in-game event that is passed through the @reference[EventQueue]
 */
class GameEvent {
    /**
     * Creates a new GameEvent.
     * This is handled implicitly through the @reference[Emitter] class
     * @param type The type of the GameEvent
     * @param data The data contained by the GameEvent
     */
    constructor(type, data = null) {
        // Parse the game event data
        if (data === null) {
            this.data = new Map_1.default();
        }
        else if (!(data instanceof Map_1.default)) {
            // data is a raw object, unpack
            this.data = new Map_1.default();
            for (let key in data) {
                this.data.add(key, data[key]);
            }
        }
        else {
            this.data = data;
        }
        this.type = type;
        this.time = Date.now();
    }
    /**
     * Checks the type of the GameEvent
     * @param type The type to check
     * @returns True if the GameEvent is the specified type, false otherwise.
     */
    isType(type) {
        return this.type === type;
    }
    /**
     * Returns this GameEvent as a string
     * @returns The string representation of the GameEvent
     */
    toString() {
        return this.type + ": @" + this.time;
    }
}
exports.default = GameEvent;

},{"../DataTypes/Map":7}],24:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
exports.GameEventType = void 0;
var GameEventType;
(function (GameEventType) {
    /**
     * Mouse Down event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_DOWN"] = "mouse_down";
    /**
     * Mouse Up event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_UP"] = "mouse_up";
    /**
     * Mouse Move event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_MOVE"] = "mouse_move";
    /**
     * Key Down event. Has data: {key: string - The key that is down}
     */
    GameEventType["KEY_DOWN"] = "key_down";
    /**
     * Key Up event. Has data: {key: string - The key that is up}
     */
    GameEventType["KEY_UP"] = "key_up";
    /**
     * Canvas Blur event. Has data: {}
     */
    GameEventType["CANVAS_BLUR"] = "canvas_blur";
    /**
     * Mouse wheel up event. Has data: {}
     */
    GameEventType["WHEEL_UP"] = "wheel_up";
    /**
     * Mouse wheel down event. Has data: {}
     */
    GameEventType["WHEEL_DOWN"] = "wheel_down";
    /**
     * Start Recording event. Has data: {}
     */
    GameEventType["START_RECORDING"] = "start_recording";
    /**
     * Stop Recording event. Has data: {}
     */
    GameEventType["STOP_RECORDING"] = "stop_recording";
    /**
     * Play Recording event. Has data: {}
     */
    GameEventType["PLAY_RECORDING"] = "play_recording";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_SOUND"] = "play_sound";
    /**
     * Play Sound event. Has data: {key: string}
     */
    GameEventType["STOP_SOUND"] = "stop_sound";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean, channel: AudioChannelType }
     */
    GameEventType["PLAY_SFX"] = "play_sfx";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_MUSIC"] = "play_music";
    /**
     * Mute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["MUTE_CHANNEL"] = "mute_channel";
    /**
     * Unmute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["UNMUTE_CHANNEL"] = "unmute_channel";
    /**
     * Encompasses all event types. Used for receivers only.
     */
    GameEventType["ALL"] = "all";
})(GameEventType = exports.GameEventType || (exports.GameEventType = {}));

},{}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const EventQueue_1 = require("./EventQueue");
/**
 * Receives subscribed events from the EventQueue.
 */
class Receiver {
    /** Creates a new Receiver */
    constructor() {
        this.MAX_SIZE = 100;
        this.q = new Queue_1.default(this.MAX_SIZE);
    }
    destroy() {
        EventQueue_1.default.getInstance().unsubscribe(this);
    }
    /**
     * Adds these types of events to this receiver's queue every update.
     * @param eventTypes The types of events this receiver will be subscribed to
     */
    subscribe(eventTypes) {
        EventQueue_1.default.getInstance().subscribe(this, eventTypes);
        this.q.clear();
    }
    /**
     * Adds an event to the queue of this reciever. This is used by the @reference[EventQueue] to distribute events
     * @param event The event to receive
     */
    receive(event) {
        try {
            this.q.enqueue(event);
        }
        catch (e) {
            console.warn("Receiver overflow for event " + event.toString());
            throw e;
        }
    }
    /**
     * Retrieves the next event from the receiver's queue
     * @returns The next GameEvent
     */
    getNextEvent() {
        return this.q.dequeue();
    }
    /**
     * Looks at the next event in the receiver's queue, but doesn't remove it from the queue
     * @returns The next GameEvent
     */
    peekNextEvent() {
        return this.q.peekNext();
    }
    /**
     * Returns true if the receiver has any events in its queue
     * @returns True if the receiver has another event, false otherwise
     */
    hasNextEvent() {
        return this.q.hasItems();
    }
    /**
     * Ignore all events this frame
     */
    ignoreEvents() {
        this.q.clear();
    }
}
exports.default = Receiver;

},{"../DataTypes/Queue":11,"./EventQueue":22}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Receiver_1 = require("../Events/Receiver");
const Map_1 = require("../DataTypes/Map");
const Vec2_1 = require("../DataTypes/Vec2");
const EventQueue_1 = require("../Events/EventQueue");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Receives input events from the @reference[EventQueue] and allows for easy access of information about input by other systems
 */
class Input {
    /**
     * Initializes the Input object
     * @param viewport A reference to the viewport of the game
     */
    static initialize(viewport, keyMap) {
        Input.viewport = viewport;
        Input.mousePressed = false;
        Input.mouseJustPressed = false;
        Input.receiver = new Receiver_1.default();
        Input.keyJustPressed = new Map_1.default();
        Input.keyPressed = new Map_1.default();
        Input.mousePosition = new Vec2_1.default(0, 0);
        Input.mousePressPosition = new Vec2_1.default(0, 0);
        Input.scrollDirection = 0;
        Input.justScrolled = false;
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
        // Initialize the keymap
        Input.keyMap = new Map_1.default();
        // Add all keys to the keymap
        for (let entry in keyMap) {
            let name = keyMap[entry].name;
            let keys = keyMap[entry].keys;
            Input.keyMap.add(name, keys);
        }
        Input.eventQueue = EventQueue_1.default.getInstance();
        // Subscribe to all input events
        Input.eventQueue.subscribe(Input.receiver, [GameEventType_1.GameEventType.MOUSE_DOWN, GameEventType_1.GameEventType.MOUSE_UP, GameEventType_1.GameEventType.MOUSE_MOVE,
            GameEventType_1.GameEventType.KEY_DOWN, GameEventType_1.GameEventType.KEY_UP, GameEventType_1.GameEventType.CANVAS_BLUR, GameEventType_1.GameEventType.WHEEL_UP, GameEventType_1.GameEventType.WHEEL_DOWN]);
    }
    static update(deltaT) {
        // Reset the justPressed values to false
        Input.mouseJustPressed = false;
        Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
        Input.justScrolled = false;
        Input.scrollDirection = 0;
        while (Input.receiver.hasNextEvent()) {
            let event = Input.receiver.getNextEvent();
            // Handle each event type
            if (event.type === GameEventType_1.GameEventType.MOUSE_DOWN) {
                Input.mouseJustPressed = true;
                Input.mousePressed = true;
                Input.mousePressPosition = event.data.get("position");
                Input.mouseButtonPressed = event.data.get("button");
            }
            if (event.type === GameEventType_1.GameEventType.MOUSE_UP) {
                Input.mousePressed = false;
            }
            if (event.type === GameEventType_1.GameEventType.MOUSE_MOVE) {
                Input.mousePosition = event.data.get("position");
            }
            if (event.type === GameEventType_1.GameEventType.KEY_DOWN) {
                let key = event.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                if (!Input.keyPressed.get(key)) {
                    Input.keyJustPressed.set(key, true);
                    Input.keyPressed.set(key, true);
                }
            }
            if (event.type === GameEventType_1.GameEventType.KEY_UP) {
                let key = event.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                Input.keyPressed.set(key, false);
            }
            if (event.type === GameEventType_1.GameEventType.CANVAS_BLUR) {
                Input.clearKeyPresses();
            }
            if (event.type === GameEventType_1.GameEventType.WHEEL_UP) {
                Input.scrollDirection = -1;
                Input.justScrolled = true;
            }
            else if (event.type === GameEventType_1.GameEventType.WHEEL_DOWN) {
                Input.scrollDirection = 1;
                Input.justScrolled = true;
            }
        }
    }
    static clearKeyPresses() {
        Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
        Input.keyPressed.forEach((key) => Input.keyPressed.set(key, false));
    }
    /**
     * Returns whether or not a key was newly pressed Input frame.
     * If the key is still pressed from last frame and wasn't re-pressed, Input will return false.
     * @param key The key
     * @returns True if the key was just pressed, false otherwise
     */
    static isKeyJustPressed(key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyJustPressed.has(key)) {
            return Input.keyJustPressed.get(key);
        }
        else {
            return false;
        }
    }
    /**
     * Returns an array of all of the keys that are newly pressed Input frame.
     * If a key is still pressed from last frame and wasn't re-pressed, it will not be in Input list.
     * @returns An array of all of the newly pressed keys.
     */
    static getKeysJustPressed() {
        if (Input.keysDisabled)
            return [];
        let keys = Array();
        Input.keyJustPressed.forEach(key => {
            if (Input.keyJustPressed.get(key)) {
                keys.push(key);
            }
        });
        return keys;
    }
    /**
     * Returns whether or not a key is being pressed.
     * @param key The key
     * @returns True if the key is currently pressed, false otherwise
     */
    static isKeyPressed(key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyPressed.has(key)) {
            return Input.keyPressed.get(key);
        }
        else {
            return false;
        }
    }
    /**
     * Changes the binding of an input name to keys
     * @param inputName The name of the input
     * @param keys The corresponding keys
     */
    static changeKeyBinding(inputName, keys) {
        Input.keyMap.set(inputName, keys);
    }
    /**
     * Clears all key bindings
     */
    static clearAllKeyBindings() {
        Input.keyMap.clear();
    }
    /**
     * Returns whether or not an input was just pressed this frame
     * @param inputName The name of the input
     * @returns True if the input was just pressed, false otherwise
     */
    static isJustPressed(inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            const keys = Input.keyMap.get(inputName);
            let justPressed = false;
            for (let key of keys) {
                justPressed = justPressed || Input.isKeyJustPressed(key);
            }
            return justPressed;
        }
        else {
            return false;
        }
    }
    /**
     * Returns whether or not an input is currently pressed
     * @param inputName The name of the input
     * @returns True if the input is pressed, false otherwise
     */
    static isPressed(inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            const keys = Input.keyMap.get(inputName);
            let pressed = false;
            for (let key of keys) {
                pressed = pressed || Input.isKeyPressed(key);
            }
            return pressed;
        }
        else {
            return false;
        }
    }
    /**
     *
     * Returns whether or not the mouse was newly pressed Input frame.
     * @param mouseButton Optionally specify which mouse click you want to know was pressed.
     * 0 for left click, 1 for middle click, 2 for right click.
     * @returns True if the mouse was just pressed, false otherwise
     */
    static isMouseJustPressed(mouseButton) {
        if (mouseButton || mouseButton === 0) {
            return Input.mouseJustPressed && !Input.mouseDisabled && mouseButton == this.mouseButtonPressed;
        }
        return Input.mouseJustPressed && !Input.mouseDisabled;
    }
    /**
     * Returns whether or not the mouse is currently pressed
     * @param mouseButton Optionally specify which mouse click you want to know was pressed.
     * 0 for left click, 1 for middle click, 2 for right click.
     * @returns True if the mouse is currently pressed, false otherwise
     */
    static isMousePressed(mouseButton) {
        if (mouseButton) {
            return Input.mousePressed && !Input.mouseDisabled && mouseButton == this.mouseButtonPressed;
        }
        return Input.mousePressed && !Input.mouseDisabled;
    }
    /**
     * Returns whether the user scrolled or not
     * @returns True if the user just scrolled Input frame, false otherwise
     */
    static didJustScroll() {
        return Input.justScrolled && !Input.mouseDisabled;
    }
    /**
     * Gets the direction of the scroll
     * @returns -1 if the user scrolled up, 1 if they scrolled down
     */
    static getScrollDirection() {
        return Input.scrollDirection;
    }
    /**
     * Gets the position of the player's mouse
     * @returns The mouse position stored as a Vec2
     */
    static getMousePosition() {
        return Input.mousePosition.scaled(1 / this.viewport.getZoomLevel());
    }
    /**
     * Gets the position of the player's mouse in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    static getGlobalMousePosition() {
        return Input.mousePosition.clone().scale(1 / this.viewport.getZoomLevel()).add(Input.viewport.getOrigin());
    }
    /**
     * Gets the position of the last mouse press
     * @returns The mouse position stored as a Vec2
     */
    static getMousePressPosition() {
        return Input.mousePressPosition;
    }
    /**
     * Gets the position of the last mouse press in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    static getGlobalMousePressPosition() {
        return Input.mousePressPosition.clone().add(Input.viewport.getOrigin());
    }
    /**
     * Disables all keypress and mouse click inputs
     */
    static disableInput() {
        Input.keysDisabled = true;
        Input.mouseDisabled = true;
    }
    /**
     * Enables all keypress and mouse click inputs
     */
    static enableInput() {
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
    }
}
exports.default = Input;

},{"../DataTypes/Map":7,"../DataTypes/Vec2":18,"../Events/EventQueue":22,"../Events/GameEventType":24,"../Events/Receiver":25}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("../Events/EventQueue");
const Vec2_1 = require("../DataTypes/Vec2");
const GameEvent_1 = require("../Events/GameEvent");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Handles communication with the web browser to receive asynchronous events and send them to the @reference[EventQueue]
 */
class InputHandler {
    /**
     * Creates a new InputHandler
     * @param canvas The game canvas
     */
    constructor(canvas) {
        this.handleMouseDown = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let button = event.button;
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_DOWN, { position: pos, button: button });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseUp = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_UP, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseMove = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_MOVE, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyDown = (event) => {
            let key = this.getKey(event);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_DOWN, { key: key });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyUp = (event) => {
            let key = this.getKey(event);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_UP, { key: key });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleBlur = (event) => {
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.CANVAS_BLUR, {});
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleContextMenu = (event) => {
            event.preventDefault();
            event.stopPropagation();
        };
        this.handleWheel = (event) => {
            event.preventDefault();
            event.stopPropagation();
            let gameEvent;
            if (event.deltaY < 0) {
                gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_UP, {});
            }
            else {
                gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_DOWN, {});
            }
            this.eventQueue.addEvent(gameEvent);
        };
        this.eventQueue = EventQueue_1.default.getInstance();
        canvas.onmousedown = (event) => this.handleMouseDown(event, canvas);
        canvas.onmouseup = (event) => this.handleMouseUp(event, canvas);
        canvas.oncontextmenu = this.handleContextMenu;
        canvas.onmousemove = (event) => this.handleMouseMove(event, canvas);
        document.onkeydown = this.handleKeyDown;
        document.onkeyup = this.handleKeyUp;
        document.onblur = this.handleBlur;
        document.oncontextmenu = this.handleBlur;
        document.onwheel = this.handleWheel;
    }
    getKey(keyEvent) {
        return keyEvent.key.toLowerCase();
    }
    getMousePosition(mouseEvent, canvas) {
        let rect = canvas.getBoundingClientRect();
        let x = mouseEvent.clientX - rect.left;
        let y = mouseEvent.clientY - rect.top;
        return new Vec2_1.default(x, y);
    }
}
exports.default = InputHandler;

},{"../DataTypes/Vec2":18,"../Events/EventQueue":22,"../Events/GameEvent":23,"../Events/GameEventType":24}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignorePage
/**
 * Sets up the environment of the game engine
 */
class EnvironmentInitializer {
    static setup() {
        CanvasRenderingContext2D.prototype.roundedRect = function (x, y, w, h, r) {
            // Clamp the radius between 0 and the min of the width or height
            if (r < 0)
                r = 0;
            if (r > Math.min(w, h))
                r = Math.min(w, h);
            // Draw the rounded rect
            this.beginPath();
            // Top
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.arcTo(x + w, y, x + w, y + r, r);
            // Right
            this.lineTo(x + w, y + h - r);
            this.arcTo(x + w, y + h, x + w - r, y + h, r);
            // Bottom
            this.lineTo(x + r, y + h);
            this.arcTo(x, y + h, x, y + h - r, r);
            // Left
            this.lineTo(x, y + r);
            this.arcTo(x, y, x + r, y, r);
            this.closePath();
        };
        CanvasRenderingContext2D.prototype.strokeRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.stroke();
        };
        CanvasRenderingContext2D.prototype.fillRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.fill();
        };
    }
}
exports.default = EnvironmentInitializer;

},{}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameLoop_1 = require("./GameLoop");
const Debug_1 = require("../Debug/Debug");
const Stats_1 = require("../Debug/Stats");
/**
 * A game loop with a fixed update time and a variable render time.
 * Every frame, the game updates until all time since the last frame has been processed.
 * If too much time has passed, such as if the last update was too slow,
 * or if the browser was put into the background, the loop will panic and discard time.
 * A render happens at the end of every frame. This happens as fast as possible unless specified.
 * A loop of this type allows for deterministic behavior - No matter what the frame rate is, the update should behave the same,
 * as it is occuring in a fixed interval.
 */
class FixedUpdateGameLoop extends GameLoop_1.default {
    constructor() {
        super();
        /**
         * The main loop of the game. Updates until the current time is reached. Renders once
         * @param timestamp The current time in ms
         */
        this.doFrame = (timestamp) => {
            // If a pause was executed, stop doing the loop.
            if (this.paused) {
                return;
            }
            // Request animation frame to prepare for another update or render
            window.requestAnimationFrame((t) => this.doFrame(t));
            // If we are trying to render too soon, do nothing.
            if (timestamp < this.lastFrameTime + this.minFrameDelay) {
                return;
            }
            // A frame is actually happening
            this.startFrame(timestamp);
            // Update while there is still time to make up. If we do too many update steps, panic and exit the loop.
            this.numUpdateSteps = 0;
            let panic = false;
            while (this.frameDelta >= this.updateTimestep) {
                // Do an update
                this._doUpdate(this.updateTimestep / 1000);
                // Remove the update step time from the time we have to process
                this.frameDelta -= this.updateTimestep;
                // Increment steps and check if we've done too many
                this.numUpdateSteps++;
                if (this.numUpdateSteps > 100) {
                    panic = true;
                    break;
                }
            }
            // Updates are done, render
            this._doRender();
            // Wrap up the frame
            this.finishFrame(panic);
        };
        this.maxUpdateFPS = 60;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
        this.frameDelta = 0;
        this.lastFrameTime = 0;
        this.minFrameDelay = 0;
        this.frame = 0;
        this.fps = this.maxUpdateFPS; // Initialize the fps to the max allowed fps
        this.fpsUpdateInterval = 1000;
        this.lastFpsUpdate = 0;
        this.framesSinceLastFpsUpdate = 0;
        this.started = false;
        this.paused = false;
        this.running = false;
        this.numUpdateSteps = 0;
    }
    getFPS() {
        return 0;
    }
    /**
     * Updates the frame count and sum of time for the framerate of the game
     * @param timestep The current time in ms
     */
    updateFPS(timestamp) {
        this.fps = 0.9 * this.framesSinceLastFpsUpdate * 1000 / (timestamp - this.lastFpsUpdate) + (1 - 0.9) * this.fps;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        Debug_1.default.log("fps", "FPS: " + this.fps.toFixed(1));
        Stats_1.default.updateFPS(this.fps);
    }
    /**
 * Changes the maximum allowed physics framerate of the game
 * @param initMax The max framerate
 */
    setMaxUpdateFPS(initMax) {
        this.maxUpdateFPS = initMax;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
    }
    /**
     * Sets the maximum rendering framerate
     * @param maxFPS The max framerate
     */
    setMaxFPS(maxFPS) {
        this.minFrameDelay = 1000 / maxFPS;
    }
    /**
     * This function is called when the game loop panics, i.e. it tries to process too much time in an entire frame.
     * This will reset the amount of time back to zero.
     * @returns The amount of time we are discarding from processing.
     */
    resetFrameDelta() {
        let oldFrameDelta = this.frameDelta;
        this.frameDelta = 0;
        return oldFrameDelta;
    }
    /**
     * Starts up the game loop and calls the first requestAnimationFrame
     */
    start() {
        if (!this.started) {
            this.started = true;
            window.requestAnimationFrame((timestamp) => this.doFirstFrame(timestamp));
        }
    }
    pause() {
        this.paused = true;
    }
    resume() {
        this.paused = false;
    }
    /**
     * The first game frame - initializes the first frame time and begins the render
     * @param timestamp The current time in ms
     */
    doFirstFrame(timestamp) {
        this.running = true;
        this._doRender();
        this.lastFrameTime = timestamp;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        window.requestAnimationFrame((t) => this.doFrame(t));
    }
    /**
     * Handles any processing that needs to be done at the start of the frame
     * @param timestamp The time of the frame in ms
     */
    startFrame(timestamp) {
        // Update the amount of time we need our update to process
        this.frameDelta += timestamp - this.lastFrameTime;
        // Set the new time of the last frame
        this.lastFrameTime = timestamp;
        // Update the estimate of the framerate
        if (timestamp > this.lastFpsUpdate + this.fpsUpdateInterval) {
            this.updateFPS(timestamp);
        }
        // Increment the number of frames
        this.frame++;
        this.framesSinceLastFpsUpdate++;
    }
    /**
     * Wraps up the frame and handles the panic state if there is one
     * @param panic Whether or not the loop panicked
     */
    finishFrame(panic) {
        if (panic) {
            var discardedTime = Math.round(this.resetFrameDelta());
            console.warn('Main loop panicked, probably because the browser tab was put in the background. Discarding ' + discardedTime + 'ms');
        }
    }
}
exports.default = FixedUpdateGameLoop;

},{"../Debug/Debug":19,"../Debug/Stats":20,"./GameLoop":31}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("../Events/EventQueue");
const Input_1 = require("../Input/Input");
const InputHandler_1 = require("../Input/InputHandler");
const Recorder_1 = require("../Playback/Recorder");
const Debug_1 = require("../Debug/Debug");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const Viewport_1 = require("../SceneGraph/Viewport");
const SceneManager_1 = require("../Scene/SceneManager");
const AudioManager_1 = require("../Sound/AudioManager");
const Stats_1 = require("../Debug/Stats");
const CanvasRenderer_1 = require("../Rendering/CanvasRenderer");
const Color_1 = require("../Utils/Color");
const GameOptions_1 = require("./GameOptions");
const FixedUpdateGameLoop_1 = require("./FixedUpdateGameLoop");
const EnvironmentInitializer_1 = require("./EnvironmentInitializer");
const Vec2_1 = require("../DataTypes/Vec2");
const RegistryManager_1 = require("../Registry/RegistryManager");
const WebGLRenderer_1 = require("../Rendering/WebGLRenderer");
/**
 * The main loop of the game engine.
 * Handles the update order, and initializes all subsystems.
 * The Game manages the update cycle, and requests animation frames to render to the browser.
 */
class Game {
    /**
     * Creates a new Game
     * @param options The options for Game initialization
     */
    constructor(options) {
        // Before anything else, build the environment
        EnvironmentInitializer_1.default.setup();
        // Typecast the config object to a GameConfig object
        this.gameOptions = GameOptions_1.default.parse(options);
        this.showDebug = this.gameOptions.showDebug;
        this.showStats = this.gameOptions.showStats;
        // Create an instance of a game loop
        this.loop = new FixedUpdateGameLoop_1.default();
        // Get the game canvas and give it a background color
        this.GAME_CANVAS = document.getElementById("game-canvas");
        this.DEBUG_CANVAS = document.getElementById("debug-canvas");
        // Give the canvas a size and get the rendering context
        this.WIDTH = this.gameOptions.canvasSize.x;
        this.HEIGHT = this.gameOptions.canvasSize.y;
        // This step MUST happen before the resource manager does anything
        if (this.gameOptions.useWebGL) {
            this.renderingManager = new WebGLRenderer_1.default();
        }
        else {
            this.renderingManager = new CanvasRenderer_1.default();
        }
        this.initializeGameWindow();
        this.ctx = this.renderingManager.initializeCanvas(this.GAME_CANVAS, this.WIDTH, this.HEIGHT);
        this.clearColor = new Color_1.default(this.gameOptions.clearColor.r, this.gameOptions.clearColor.g, this.gameOptions.clearColor.b);
        // Initialize debugging and stats
        Debug_1.default.initializeDebugCanvas(this.DEBUG_CANVAS, this.WIDTH, this.HEIGHT);
        Stats_1.default.initStats();
        if (this.gameOptions.showStats) {
            // Find the stats output and make it no longer hidden
            document.getElementById("stats").hidden = false;
        }
        // Size the viewport to the game canvas
        const canvasSize = new Vec2_1.default(this.WIDTH, this.HEIGHT);
        this.viewport = new Viewport_1.default(canvasSize, this.gameOptions.zoomLevel);
        // Initialize all necessary game subsystems
        this.eventQueue = EventQueue_1.default.getInstance();
        this.inputHandler = new InputHandler_1.default(this.GAME_CANVAS);
        Input_1.default.initialize(this.viewport, this.gameOptions.inputs);
        this.recorder = new Recorder_1.default();
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.sceneManager = new SceneManager_1.default(this.viewport, this.renderingManager);
        this.audioManager = AudioManager_1.default.getInstance();
    }
    /**
     * Set up the game window that holds the canvases
     */
    initializeGameWindow() {
        const gameWindow = document.getElementById("game-window");
        // Set the height of the game window
        gameWindow.style.width = this.WIDTH + "px";
        gameWindow.style.height = this.HEIGHT + "px";
    }
    /**
     * Retreives the SceneManager from the Game
     * @returns The SceneManager
     */
    getSceneManager() {
        return this.sceneManager;
    }
    /**
     * Starts the game
     */
    start(InitialScene, options) {
        // Set the update function of the loop
        this.loop.doUpdate = (deltaT) => this.update(deltaT);
        // Set the render function of the loop
        this.loop.doRender = () => this.render();
        // Preload registry items
        RegistryManager_1.default.preload();
        // Load the items with the resource manager
        this.resourceManager.loadResourcesFromQueue(() => {
            // When we're done loading, start the loop
            console.log("Finished Preload - loading first scene");
            this.sceneManager.changeToScene(InitialScene, {}, options);
            this.loop.start();
        });
    }
    /**
     * Updates all necessary subsystems of the game. Defers scene updates to the sceneManager
     * @param deltaT The time sine the last update
     */
    update(deltaT) {
        try {
            // Handle all events that happened since the start of the last loop
            this.eventQueue.update(deltaT);
            // Update the input data structures so game objects can see the input
            Input_1.default.update(deltaT);
            // Update the recording of the game
            this.recorder.update(deltaT);
            // Update all scenes
            this.sceneManager.update(deltaT);
            // Update all sounds
            this.audioManager.update(deltaT);
            // Load or unload any resources if needed
            this.resourceManager.update(deltaT);
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Update - Crashing gracefully");
            console.error(e);
        }
    }
    /**
     * Clears the canvas and defers scene rendering to the sceneManager. Renders the debug canvas
     */
    render() {
        try {
            // Clear the canvases
            Debug_1.default.clearCanvas();
            this.renderingManager.clear(this.clearColor);
            this.sceneManager.render();
            // Hacky debug mode
            if (Input_1.default.isKeyJustPressed("g")) {
                this.showDebug = !this.showDebug;
            }
            // Debug render
            if (this.showDebug) {
                Debug_1.default.render();
            }
            if (this.showStats) {
                Stats_1.default.render();
            }
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Render - Crashing gracefully");
            console.error(e);
        }
    }
}
exports.default = Game;

},{"../DataTypes/Vec2":18,"../Debug/Debug":19,"../Debug/Stats":20,"../Events/EventQueue":22,"../Input/Input":26,"../Input/InputHandler":27,"../Playback/Recorder":56,"../Registry/RegistryManager":59,"../Rendering/CanvasRenderer":65,"../Rendering/WebGLRenderer":70,"../ResourceManager/ResourceManager":77,"../Scene/SceneManager":85,"../SceneGraph/Viewport":89,"../Sound/AudioManager":90,"../Utils/Color":93,"./EnvironmentInitializer":28,"./FixedUpdateGameLoop":29,"./GameOptions":32}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NullFunc_1 = require("../DataTypes/Functions/NullFunc");
/**
 * The main game loop of the game. Keeps track of fps and handles scheduling of updates and rendering.
 * This class is left abstract, so that a subclass can handle exactly how the loop is scheduled.
 * For an example of different types of game loop scheduling, check out @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/game-loop.html)
 */
class GameLoop {
    constructor() {
        /** The function to call when an update occurs */
        this._doUpdate = NullFunc_1.default;
        /** The function to call when a render occurs */
        this._doRender = NullFunc_1.default;
    }
    set doUpdate(update) {
        this._doUpdate = update;
    }
    set doRender(render) {
        this._doRender = render;
    }
}
exports.default = GameLoop;

},{"../DataTypes/Functions/NullFunc":2}],32:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
/** The options for initializing the @reference[GameLoop] */
class GameOptions {
    /**
     * Parses the data in the raw options object
     * @param options The game options as a Record
     * @returns A version of the options converted to a GameOptions object
     */
    static parse(options) {
        let gOpt = new GameOptions();
        gOpt.canvasSize = options.canvasSize ? options.canvasSize : { x: 800, y: 600 };
        gOpt.zoomLevel = options.zoomLevel ? options.zoomLevel : 1;
        gOpt.clearColor = options.clearColor ? options.clearColor : { r: 255, g: 255, b: 255 };
        gOpt.inputs = options.inputs ? options.inputs : [];
        gOpt.showDebug = !!options.showDebug;
        gOpt.showStats = !!options.showStats;
        gOpt.useWebGL = !!options.useWebGL;
        return gOpt;
    }
}
exports.default = GameOptions;

},{}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameNode_1 = require("./GameNode");
const Vec2_1 = require("../DataTypes/Vec2");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const Debug_1 = require("../Debug/Debug");
const Color_1 = require("../Utils/Color");
/**
 * The representation of an object in the game world that can be drawn to the screen
 */
class CanvasNode extends GameNode_1.default {
    constructor() {
        super();
        /** A flag for whether or not the CanvasNode is visible */
        this.visible = true;
        this._size = new Vec2_1.default(0, 0);
        this._size.setOnChange(() => this.sizeChanged());
        this._scale = new Vec2_1.default(1, 1);
        this._scale.setOnChange(() => this.scaleChanged());
        this._boundary = new AABB_1.default();
        this.updateBoundary();
        this._hasCustomShader = false;
    }
    get alpha() {
        return this._alpha;
    }
    set alpha(a) {
        this._alpha = a;
    }
    get size() {
        return this._size;
    }
    set size(size) {
        this._size = size;
        // Enter as a lambda to bind "this"
        this._size.setOnChange(() => this.sizeChanged());
        this.sizeChanged();
    }
    get scale() {
        return this._scale;
    }
    set scale(scale) {
        this._scale = scale;
        // Enter as a lambda to bind "this"
        this._scale.setOnChange(() => this.scaleChanged());
        this.scaleChanged();
    }
    set scaleX(value) {
        this.scale.x = value;
    }
    set scaleY(value) {
        this.scale.y = value;
    }
    get hasCustomShader() {
        return this._hasCustomShader;
    }
    get customShaderKey() {
        return this._customShaderKey;
    }
    // @override
    positionChanged() {
        super.positionChanged();
        this.updateBoundary();
    }
    /** Called if the size vector is changed or replaced. */
    sizeChanged() {
        this.updateBoundary();
    }
    /** Called if the scale vector is changed or replaced */
    scaleChanged() {
        this.updateBoundary();
    }
    // @docIgnore
    /** Called if the position, size, or scale of the CanvasNode is changed. Updates the boundary. */
    updateBoundary() {
        this._boundary.center.set(this.position.x, this.position.y);
        this._boundary.halfSize.set(this.size.x * this.scale.x / 2, this.size.y * this.scale.y / 2);
    }
    get boundary() {
        return this._boundary;
    }
    get sizeWithZoom() {
        let zoom = this.scene.getViewScale();
        return this.boundary.halfSize.clone().scaled(zoom, zoom);
    }
    /**
     * Adds a custom shader to this CanvasNode
     * @param key The registry key of the ShaderType
     */
    useCustomShader(key) {
        this._hasCustomShader = true;
        this._customShaderKey = key;
    }
    /**
     * Returns true if the point (x, y) is inside of this canvas object
     * @param x The x position of the point
     * @param y The y position of the point
     * @returns A flag representing whether or not this node contains the point.
     */
    contains(x, y) {
        return this._boundary.containsPoint(new Vec2_1.default(x, y));
    }
    // @implemented
    debugRender() {
        Debug_1.default.drawBox(this.relativePosition, this.sizeWithZoom, false, Color_1.default.BLUE);
        super.debugRender();
    }
}
exports.default = CanvasNode;

},{"../DataTypes/Shapes/AABB":13,"../DataTypes/Vec2":18,"../Debug/Debug":19,"../Utils/Color":93,"./GameNode":34}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenableProperties = void 0;
const Vec2_1 = require("../DataTypes/Vec2");
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const Region_1 = require("../DataTypes/Interfaces/Region");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const TweenController_1 = require("../Rendering/Animations/TweenController");
const Debug_1 = require("../Debug/Debug");
const Color_1 = require("../Utils/Color");
const Circle_1 = require("../DataTypes/Shapes/Circle");
/**
 * The representation of an object in the game world.
 * To construct GameNodes, see the @reference[Scene] documentation.
 */
class GameNode {
    // Constructor docs are ignored, as the user should NOT create new GameNodes with a raw constructor
    constructor() {
        /*---------- PHYSICAL ----------*/
        this.hasPhysics = false;
        this.moving = false;
        this.frozen = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isColliding = false;
        this.pathfinding = false;
        this._position = new Vec2_1.default(0, 0);
        this._position.setOnChange(() => this.positionChanged());
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.tweens = new TweenController_1.default(this);
        this.rotation = 0;
    }
    destroy() {
        this.tweens.destroy();
        this.receiver.destroy();
        if (this.hasPhysics) {
            this.removePhysics();
        }
        if (this._ai) {
            this._ai.destroy();
            delete this._ai;
            this.scene.getAIManager().removeActor(this);
        }
        this.scene.remove(this);
        this.layer.removeNode(this);
    }
    /*---------- POSITIONED ----------*/
    get position() {
        return this._position;
    }
    set position(pos) {
        this._position = pos;
        this._position.setOnChange(() => this.positionChanged());
        this.positionChanged();
    }
    get relativePosition() {
        return this.inRelativeCoordinates(this.position);
    }
    /**
     * Converts a point to coordinates relative to the zoom and origin of this node
     * @param point The point to conver
     * @returns A new Vec2 representing the point in relative coordinates
     */
    inRelativeCoordinates(point) {
        let origin = this.scene.getViewTranslation(this);
        let zoom = this.scene.getViewScale();
        return point.clone().sub(origin).scale(zoom);
    }
    /*---------- UNIQUE ----------*/
    get id() {
        return this._id;
    }
    set id(id) {
        // id can only be set once
        if (this._id === undefined) {
            this._id = id;
        }
        else {
            throw "Attempted to assign id to object that already has id.";
        }
    }
    /*---------- PHYSICAL ----------*/
    // @implemented
    /**
     * @param velocity The velocity with which to move the object.
     */
    move(velocity) {
        if (this.frozen)
            return;
        this.moving = true;
        this._velocity = velocity;
    }
    ;
    moveOnPath(speed, path) {
        if (this.frozen)
            return;
        this.path = path;
        let dir = path.getMoveDirection(this);
        this.moving = true;
        this.pathfinding = true;
        this._velocity = dir.scale(speed);
    }
    // @implemented
    /**
     * @param velocity The velocity with which the object will move.
     */
    finishMove() {
        this.moving = false;
        this.position.add(this._velocity);
        if (this.pathfinding) {
            this.path.handlePathProgress(this);
            this.path = null;
            this.pathfinding = false;
        }
    }
    // @implemented
    /**
     * @param collisionShape The collider for this object. If this has a region (implements Region),
     * it will be used when no collision shape is specified (or if collision shape is null).
     * @param isCollidable Whether this is collidable or not. True by default.
     * @param isStatic Whether this is static or not. False by default
     */
    addPhysics(collisionShape, colliderOffset, isCollidable = true, isStatic = false) {
        // Initialize the physics variables
        this.hasPhysics = true;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = true;
        this.isCollidable = isCollidable;
        this.isStatic = isStatic;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = new Array(32);
        this.triggerExits = new Array(32);
        this._velocity = Vec2_1.default.ZERO;
        this.sweptRect = new AABB_1.default();
        this.collidedWithTilemap = false;
        this.group = -1; // The default group, collides with everything
        // Set the collision shape if provided, or simply use the the region if there is one.
        if (collisionShape) {
            this.collisionShape = collisionShape;
            this.collisionShape.center = this.position;
        }
        else if (Region_1.isRegion(this)) {
            // If the gamenode has a region and no other is specified, use that
            this.collisionShape = this.boundary.clone();
        }
        else {
            throw "No collision shape specified for physics object.";
        }
        // If we were provided with a collider offset, set it. Otherwise there is no offset, so use the zero vector
        if (colliderOffset) {
            this.colliderOffset = colliderOffset;
        }
        else {
            this.colliderOffset = Vec2_1.default.ZERO;
        }
        // Initialize the swept rect
        this.sweptRect = this.collisionShape.getBoundingRect();
        // Register the object with physics
        this.scene.getPhysicsManager().registerObject(this);
    }
    /** Removes this object from the physics system */
    removePhysics() {
        // Remove this from the physics manager
        this.scene.getPhysicsManager().deregisterObject(this);
        // Nullify all physics fields
        this.hasPhysics = false;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isCollidable = false;
        this.isStatic = false;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = null;
        this.triggerExits = null;
        this._velocity = Vec2_1.default.ZERO;
        this.sweptRect = null;
        this.collidedWithTilemap = false;
        this.group = -1;
        this.collisionShape = null;
        this.colliderOffset = Vec2_1.default.ZERO;
        this.sweptRect = null;
    }
    /** Disables physics movement for this node */
    freeze() {
        this.frozen = true;
    }
    /** Reenables physics movement for this node */
    unfreeze() {
        this.frozen = false;
    }
    /** Prevents this object from participating in all collisions and triggers. It can still move. */
    disablePhysics() {
        this.active = false;
    }
    /** Enables this object to participate in collisions and triggers. This is only necessary if disablePhysics was called */
    enablePhysics() {
        this.active = true;
    }
    /**
     * Sets the collider for this GameNode
     * @param collider The new collider to use
     */
    setCollisionShape(collider) {
        this.collisionShape = collider;
        this.collisionShape.center.copy(this.position);
    }
    // @implemented
    /**
     * Sets this object to be a trigger for a specific group
     * @param group The name of the group that activates the trigger
     * @param onEnter The name of the event to send when this trigger is activated
     * @param onExit The name of the event to send when this trigger stops being activated
     */
    setTrigger(group, onEnter, onExit) {
        // Make this object a trigger
        this.isTrigger = true;
        // Get the number of the physics layer
        let layerNumber = this.scene.getPhysicsManager().getGroupNumber(group);
        if (layerNumber === 0) {
            console.warn(`Trigger for GameNode ${this.id} not set - group "${group}" was not recognized by the physics manager.`);
            return;
        }
        // Add this to the trigger mask
        this.triggerMask |= layerNumber;
        // Layer numbers are bits, so get which bit it is
        let index = Math.log2(layerNumber);
        // Set the event names
        this.triggerEnters[index] = onEnter;
        this.triggerExits[index] = onExit;
    }
    ;
    // @implemented
    /**
     * @param group The physics group this node should belong to
     */
    setGroup(group) {
        this.scene.getPhysicsManager().setGroup(this, group);
    }
    // @implemened
    getLastVelocity() {
        return this._velocity;
    }
    /*---------- ACTOR ----------*/
    get ai() {
        return this._ai;
    }
    set ai(ai) {
        if (!this._ai) {
            // If we haven't been previously had an ai, register us with the ai manager
            this.scene.getAIManager().registerActor(this);
        }
        this._ai = ai;
        this.aiActive = true;
    }
    // @implemented
    addAI(ai, options, type) {
        if (!this._ai) {
            this.scene.getAIManager().registerActor(this);
        }
        if (typeof ai === "string") {
            this._ai = this.scene.getAIManager().generateAI(ai);
        }
        else {
            this._ai = new ai();
        }
        // Question, how much do we want different type of AI to be handled the same, i.e. should GoapAI and AI similar methods and signatures for the sake of unity
        this._ai.initializeAI(this, options);
        this.aiActive = true;
    }
    // @implemented
    setAIActive(active, options) {
        this.aiActive = active;
        if (this.aiActive) {
            this.ai.activate(options);
        }
    }
    /*---------- TWEENABLE PROPERTIES ----------*/
    set positionX(value) {
        this.position.x = value;
    }
    set positionY(value) {
        this.position.y = value;
    }
    /*---------- GAME NODE ----------*/
    /**
     * Sets the scene for this object.
     * @param scene The scene this object belongs to.
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Gets the scene this object is in.
     * @returns The scene this object belongs to
    */
    getScene() {
        return this.scene;
    }
    /**
     * Sets the layer of this object.
     * @param layer The layer this object will be on.
     */
    setLayer(layer) {
        this.layer = layer;
    }
    /**
     * Returns the layer this object is on.
     * @returns This layer this object is on.
    */
    getLayer() {
        return this.layer;
    }
    /** Called if the position vector is modified or replaced */
    positionChanged() {
        if (this.collisionShape) {
            if (this.colliderOffset) {
                this.collisionShape.center = this.position.clone().add(this.colliderOffset);
            }
            else {
                this.collisionShape.center = this.position.clone();
            }
        }
    }
    ;
    /**
     * Updates this GameNode
     * @param deltaT The timestep of the update.
     */
    update(deltaT) {
        // Defer event handling to AI.
        while (this.receiver.hasNextEvent()) {
            this._ai.handleEvent(this.receiver.getNextEvent());
        }
    }
    // @implemented
    debugRender() {
        // Draw the position of this GameNode
        Debug_1.default.drawPoint(this.relativePosition, Color_1.default.BLUE);
        // If velocity is not zero, draw a vector for it
        if (this._velocity && !this._velocity.isZero()) {
            Debug_1.default.drawRay(this.relativePosition, this._velocity.clone().scaleTo(20).add(this.relativePosition), Color_1.default.BLUE);
        }
        // If this has a collider, draw it
        if (this.collisionShape) {
            let color = this.isColliding ? Color_1.default.RED : Color_1.default.GREEN;
            if (this.isTrigger) {
                color = Color_1.default.MAGENTA;
            }
            color.a = 0.2;
            if (this.collisionShape instanceof AABB_1.default) {
                Debug_1.default.drawBox(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.halfSize.scaled(this.scene.getViewScale()), true, color);
            }
            else if (this.collisionShape instanceof Circle_1.default) {
                Debug_1.default.drawCircle(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.hw * this.scene.getViewScale(), true, color);
            }
        }
    }
}
exports.default = GameNode;
var TweenableProperties;
(function (TweenableProperties) {
    TweenableProperties["posX"] = "positionX";
    TweenableProperties["posY"] = "positionY";
    TweenableProperties["scaleX"] = "scaleX";
    TweenableProperties["scaleY"] = "scaleY";
    TweenableProperties["rotation"] = "rotation";
    TweenableProperties["alpha"] = "alpha";
})(TweenableProperties = exports.TweenableProperties || (exports.TweenableProperties = {}));

},{"../DataTypes/Interfaces/Region":6,"../DataTypes/Shapes/AABB":13,"../DataTypes/Shapes/Circle":14,"../DataTypes/Vec2":18,"../Debug/Debug":19,"../Events/Emitter":21,"../Events/Receiver":25,"../Rendering/Animations/TweenController":63,"../Utils/Color":93}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("./CanvasNode");
const Color_1 = require("../Utils/Color");
/**
 * The representation of a game object that doesn't rely on any resources to render - it is drawn to the screen by the canvas
 */
class Graphic extends CanvasNode_1.default {
    constructor() {
        super();
        this.color = Color_1.default.RED;
    }
    get alpha() {
        return this.color.a;
    }
    set alpha(a) {
        this.color.a = a;
    }
    // @deprecated
    /**
     * Sets the color of the Graphic. DEPRECATED
     * @param color The new color of the Graphic.
     */
    setColor(color) {
        this.color = color;
    }
    set colorR(r) {
        this.color.r = r;
    }
    get colorR() {
        return this.color.r;
    }
    set colorG(g) {
        this.color.g = g;
    }
    get colorG() {
        return this.color.g;
    }
    set colorB(b) {
        this.color.b = b;
    }
    get colorB() {
        return this.color.b;
    }
}
exports.default = Graphic;

},{"../Utils/Color":93,"./CanvasNode":33}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphicType = void 0;
var GraphicType;
(function (GraphicType) {
    GraphicType["POINT"] = "POINT";
    GraphicType["RECT"] = "RECT";
    GraphicType["LINE"] = "LINE";
    GraphicType["PARTICLE"] = "PARTICLE";
})(GraphicType = exports.GraphicType || (exports.GraphicType = {}));

},{}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
class Line extends Graphic_1.default {
    constructor(start, end) {
        super();
        this.start = start;
        this.end = end;
        this.thickness = 2;
        // Does this really have a meaning for lines?
        this.size.set(5, 5);
    }
    set start(pos) {
        this.position = pos;
    }
    get start() {
        return this.position;
    }
    set end(pos) {
        this._end = pos;
    }
    get end() {
        return this._end;
    }
}
exports.default = Line;

},{"../Graphic":35}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = require("./Point");
/**
 * - Position X
- Velocity (speed and direction) X
- Color X
- Lifetime
- Age can be handled as lifetime
- Shape X
- Size X
- Transparency X
 */
class Particle extends Point_1.default {
    constructor(position, size, mass) {
        // Are we making this a circle?
        super(position);
        this.inUse = false;
        this.mass = mass;
    }
    setParticleActive(lifetime, position) {
        this.age = lifetime;
        this.inUse = true;
        this.visible = true;
        this.position = position;
    }
    decrementAge(decay) {
        this.age -= decay;
    }
    setParticleInactive() {
        this.inUse = false;
        this.visible = false;
    }
    set velY(y) {
        this.vel.y = y;
    }
    get velY() {
        return this.vel.y;
    }
}
exports.default = Particle;

},{"./Point":39}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
/** A basic point to be drawn on the screen. */
class Point extends Graphic_1.default {
    constructor(position) {
        // Are we making this a circle?
        super();
        this.position = position;
        this.size.set(5, 5);
    }
}
exports.default = Point;

},{"../Graphic":35}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
const Color_1 = require("../../Utils/Color");
/** A basic rectangle to be drawn on the screen. */
class Rect extends Graphic_1.default {
    constructor(position, size) {
        super();
        this.position = position;
        this.size = size;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.borderWidth = 0;
    }
    /**
     * Sets the border color of this rectangle
     * @param color The border color
     */
    setBorderColor(color) {
        this.borderColor = color;
    }
    // @deprecated
    getBorderColor() {
        return this.borderColor;
    }
    /**
     * Sets the border width of this rectangle
     * @param width The width of the rectangle in pixels
     */
    setBorderWidth(width) {
        this.borderWidth = width;
    }
    getBorderWidth() {
        return this.borderWidth;
    }
}
exports.default = Rect;

},{"../../Utils/Color":93,"../Graphic":35}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = require("./Sprite");
const AnimationManager_1 = require("../../Rendering/Animations/AnimationManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/** An sprite with specified animation frames. */
class AnimatedSprite extends Sprite_1.default {
    constructor(spritesheet) {
        super(spritesheet.name);
        this.numCols = spritesheet.columns;
        this.numRows = spritesheet.rows;
        // Set the size of the sprite to the sprite size specified by the spritesheet
        this.size.set(spritesheet.spriteWidth, spritesheet.spriteHeight);
        this.animation = new AnimationManager_1.default(this);
        // Add the animations to the animated sprite
        for (let animation of spritesheet.animations) {
            this.animation.add(animation.name, animation);
        }
    }
    get cols() {
        return this.numCols;
    }
    get rows() {
        return this.numRows;
    }
    /**
     * Gets the image offset for the current index of animation
     * @param index The index we're at in the animation
     * @returns A Vec2 containing the image offset
     */
    getAnimationOffset(index) {
        return new Vec2_1.default((index % this.numCols) * this.size.x, Math.floor(index / this.numCols) * this.size.y);
    }
}
exports.default = AnimatedSprite;

},{"../../DataTypes/Vec2":18,"../../Rendering/Animations/AnimationManager":60,"./Sprite":42}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("../CanvasNode");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/**
 * The representation of a sprite - an in-game image
 */
class Sprite extends CanvasNode_1.default {
    constructor(imageId) {
        super();
        this.imageId = imageId;
        let image = ResourceManager_1.default.getInstance().getImage(this.imageId);
        this.size = new Vec2_1.default(image.width, image.height);
        this.imageOffset = Vec2_1.default.ZERO;
        this.invertX = false;
        this.invertY = false;
    }
    /**
     * Sets the offset of the sprite from (0, 0) in the image's coordinates
     * @param offset The offset of the sprite from (0, 0) in image coordinates
     */
    setImageOffset(offset) {
        this.imageOffset = offset;
    }
}
exports.default = Sprite;

},{"../../DataTypes/Vec2":18,"../../ResourceManager/ResourceManager":77,"../CanvasNode":33}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const CanvasNode_1 = require("./CanvasNode");
/**
 * The representation of a tilemap - this can consist of a combination of tilesets in one layer
 */
class Tilemap extends CanvasNode_1.default {
    // TODO: Make this no longer be specific to Tiled
    constructor(tilemapData, layer, tilesets, scale) {
        super();
        this.tilesets = tilesets;
        this.tileSize = new Vec2_1.default(0, 0);
        this.name = layer.name;
        let tilecount = 0;
        for (let tileset of tilesets) {
            tilecount += tileset.getTileCount() + 1;
        }
        this.collisionMap = new Array(tilecount);
        for (let i = 0; i < this.collisionMap.length; i++) {
            this.collisionMap[i] = false;
        }
        // Defer parsing of the data to child classes - this allows for isometric vs. orthographic tilemaps and handling of Tiled data or other data
        this.parseTilemapData(tilemapData, layer);
        this.scale.set(scale.x, scale.y);
    }
    /**
     * Returns an array of the tilesets associated with this tilemap
     * @returns An array of all of the tilesets assocaited with this tilemap.
     */
    getTilesets() {
        return this.tilesets;
    }
    /**
     * Returns the size of tiles in this tilemap as they appear in the game world after scaling
     * @returns A vector containing the size of tiles in this tilemap as they appear in the game world after scaling.
     */
    getTileSize() {
        return this.tileSize.scaled(this.scale.x, this.scale.y);
    }
    /**
     * Gets the tile size taking zoom into account
     * @returns The tile size with zoom
    */
    getTileSizeWithZoom() {
        let zoom = this.scene.getViewScale();
        return this.getTileSize().scale(zoom);
    }
    /**
     * Adds this tilemap to the physics system
    */
    addPhysics() {
        this.hasPhysics = true;
        this.active = true;
        this.group = -1;
        this.scene.getPhysicsManager().registerTilemap(this);
    }
}
exports.default = Tilemap;

},{"../DataTypes/Vec2":18,"./CanvasNode":33}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Tilemap_1 = require("../Tilemap");
const Vec2_1 = require("../../DataTypes/Vec2");
const Debug_1 = require("../../Debug/Debug");
const Color_1 = require("../../Utils/Color");
/**
 * The representation of an orthogonal tilemap - i.e. a top down or platformer tilemap
 */
class OrthogonalTilemap extends Tilemap_1.default {
    // @override
    parseTilemapData(tilemapData, layer) {
        // The size of the tilemap in local space
        this.numCols = tilemapData.width;
        this.numRows = tilemapData.height;
        // The size of tiles
        this.tileSize.set(tilemapData.tilewidth, tilemapData.tileheight);
        // The size of the tilemap on the canvas
        this.size.set(this.numCols * this.tileSize.x, this.numRows * this.tileSize.y);
        this.position.copy(this.size.scaled(0.5));
        this.data = layer.data;
        this.visible = layer.visible;
        // Whether the tilemap is collidable or not
        this.isCollidable = false;
        if (layer.properties) {
            for (let item of layer.properties) {
                if (item.name === "Collidable") {
                    this.isCollidable = item.value;
                    // Set all tiles besides "empty: 0" to be collidable
                    for (let i = 1; i < this.collisionMap.length; i++) {
                        this.collisionMap[i] = true;
                    }
                }
            }
        }
    }
    /**
     * Gets the dimensions of the tilemap
     * @returns A Vec2 containing the number of columns and the number of rows in the tilemap.
     */
    getDimensions() {
        return new Vec2_1.default(this.numCols, this.numRows);
    }
    /**
     * Gets the data value of the tile at the specified world position
     * @param worldCoords The coordinates in world space
     * @returns The data value of the tile
     */
    getTileAtWorldPosition(worldCoords) {
        let localCoords = this.getColRowAt(worldCoords);
        return this.getTileAtRowCol(localCoords);
    }
    /**
     * Get the tile at the specified row and column
     * @param rowCol The coordinates in tilemap space
     * @returns The data value of the tile
     */
    getTileAtRowCol(rowCol) {
        if (rowCol.x < 0 || rowCol.x >= this.numCols || rowCol.y < 0 || rowCol.y >= this.numRows) {
            return -1;
        }
        return this.data[rowCol.y * this.numCols + rowCol.x];
    }
    /**
     * Gets the world position of the tile at the specified index
     * @param index The index of the tile
     * @returns A Vec2 containing the world position of the tile
     */
    getTileWorldPosition(index) {
        // Get the local position
        let col = index % this.numCols;
        let row = Math.floor(index / this.numCols);
        // Get the world position
        let x = col * this.tileSize.x;
        let y = row * this.tileSize.y;
        return new Vec2_1.default(x, y);
    }
    /**
     * Gets the data value of the tile at the specified index
     * @param index The index of the tile
     * @returns The data value of the tile
     */
    getTile(index) {
        return this.data[index];
    }
    // @override
    setTile(index, type) {
        this.data[index] = type;
    }
    /**
     * Sets the tile at the specified row and column
     * @param rowCol The position of the tile in tilemap space
     * @param type The new data value of the tile
     */
    setTileAtRowCol(rowCol, type) {
        let index = rowCol.y * this.numCols + rowCol.x;
        this.setTile(index, type);
    }
    /**
     * Returns true if the tile at the specified row and column of the tilemap is collidable
     * @param indexOrCol The index of the tile or the column it is in
     * @param row The row the tile is in
     * @returns A flag representing whether or not the tile is collidable.
     */
    isTileCollidable(indexOrCol, row) {
        // The value of the tile
        let tile = 0;
        if (row) {
            // We have a column and a row
            tile = this.getTileAtRowCol(new Vec2_1.default(indexOrCol, row));
            if (tile < 0) {
                return false;
            }
        }
        else {
            if (indexOrCol < 0 || indexOrCol >= this.data.length) {
                // Tiles that don't exist aren't collidable
                return false;
            }
            // We have an index
            tile = this.getTile(indexOrCol);
        }
        return this.collisionMap[tile];
    }
    /**
     * Takes in world coordinates and returns the row and column of the tile at that position
     * @param worldCoords The coordinates of the potential tile in world space
     * @returns A Vec2 containing the coordinates of the potential tile in tilemap space
     */
    getColRowAt(worldCoords) {
        let col = Math.floor(worldCoords.x / this.tileSize.x / this.scale.x);
        let row = Math.floor(worldCoords.y / this.tileSize.y / this.scale.y);
        return new Vec2_1.default(col, row);
    }
    // @override
    update(deltaT) { }
    // @override
    debugRender() {
        // Half of the tile size
        let zoomedHalfTileSize = this.getTileSizeWithZoom().scaled(0.5);
        let halfTileSize = this.getTileSize().scaled(0.5);
        // The center of the top left tile
        let topLeft = this.position.clone().sub(this.size.scaled(0.5));
        // A vec to store the center
        let center = Vec2_1.default.ZERO;
        for (let col = 0; col < this.numCols; col++) {
            // Calculate the x-position
            center.x = topLeft.x + col * 2 * halfTileSize.x + halfTileSize.x;
            for (let row = 0; row < this.numRows; row++) {
                if (this.isCollidable && this.isTileCollidable(col, row)) {
                    // Calculate the y-position
                    center.y = topLeft.y + row * 2 * halfTileSize.y + halfTileSize.y;
                    // Draw a box for this tile
                    Debug_1.default.drawBox(this.inRelativeCoordinates(center), zoomedHalfTileSize, false, Color_1.default.BLUE);
                }
            }
        }
    }
}
exports.default = OrthogonalTilemap;

},{"../../DataTypes/Vec2":18,"../../Debug/Debug":19,"../../Utils/Color":93,"../Tilemap":43}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("./CanvasNode");
const Color_1 = require("../Utils/Color");
const Vec2_1 = require("../DataTypes/Vec2");
const Input_1 = require("../Input/Input");
/**
 * The representation of a UIElement - the parent class of things like buttons
 */
class UIElement extends CanvasNode_1.default {
    constructor(position) {
        super();
        this.position = position;
        this.backgroundColor = new Color_1.default(0, 0, 0, 0);
        this.borderColor = new Color_1.default(0, 0, 0, 0);
        this.borderRadius = 5;
        this.borderWidth = 1;
        this.padding = Vec2_1.default.ZERO;
        this.onClick = null;
        this.onClickEventId = null;
        this.onRelease = null;
        this.onReleaseEventId = null;
        this.onEnter = null;
        this.onEnterEventId = null;
        this.onLeave = null;
        this.onLeaveEventId = null;
        this.isClicked = false;
        this.isEntered = false;
    }
    // @deprecated
    setBackgroundColor(color) {
        this.backgroundColor = color;
    }
    // @deprecated
    setPadding(padding) {
        this.padding.copy(padding);
    }
    update(deltaT) {
        super.update(deltaT);
        // See of this object was just clicked
        if (Input_1.default.isMouseJustPressed()) {
            let clickPos = Input_1.default.getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y) && this.visible && !this.layer.isHidden()) {
                this.isClicked = true;
                if (this.onClick !== null) {
                    this.onClick();
                }
                if (this.onClickEventId !== null) {
                    let data = {};
                    this.emitter.fireEvent(this.onClickEventId, data);
                }
            }
        }
        // If the mouse wasn't just pressed, then we definitely weren't clicked
        if (!Input_1.default.isMousePressed()) {
            if (this.isClicked) {
                this.isClicked = false;
            }
        }
        // Check if the mouse is hovering over this element
        let mousePos = Input_1.default.getMousePosition();
        if (mousePos && this.contains(mousePos.x, mousePos.y)) {
            this.isEntered = true;
            if (this.onEnter !== null) {
                this.onEnter();
            }
            if (this.onEnterEventId !== null) {
                let data = {};
                this.emitter.fireEvent(this.onEnterEventId, data);
            }
        }
        else if (this.isEntered) {
            this.isEntered = false;
            if (this.onLeave !== null) {
                this.onLeave();
            }
            if (this.onLeaveEventId !== null) {
                let data = {};
                this.emitter.fireEvent(this.onLeaveEventId, data);
            }
        }
        else if (this.isClicked) {
            // If mouse is dragged off of element while down, it is not clicked anymore
            this.isClicked = false;
        }
    }
    /**
     * Overridable method for calculating background color - useful for elements that want to be colored on different after certain events
     * @returns The background color of the UIElement
     */
    calculateBackgroundColor() {
        return this.backgroundColor;
    }
    /**
     * Overridable method for calculating border color - useful for elements that want to be colored on different after certain events
     * @returns The border color of the UIElement
     */
    calculateBorderColor() {
        return this.borderColor;
    }
}
exports.default = UIElement;

},{"../DataTypes/Vec2":18,"../Input/Input":26,"../Utils/Color":93,"./CanvasNode":33}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Label_1 = require("./Label");
const Color_1 = require("../../Utils/Color");
/** A clickable button UIElement */
class Button extends Label_1.default {
    constructor(position, text) {
        super(position, text);
        this.backgroundColor = new Color_1.default(150, 75, 203);
        this.borderColor = new Color_1.default(41, 46, 30);
        this.textColor = new Color_1.default(255, 255, 255);
    }
    // @override
    calculateBackgroundColor() {
        // Change the background color if clicked or hovered
        if (this.isEntered && !this.isClicked) {
            return this.backgroundColor.lighten();
        }
        else if (this.isClicked) {
            return this.backgroundColor.darken();
        }
        else {
            return this.backgroundColor;
        }
    }
}
exports.default = Button;

},{"../../Utils/Color":93,"./Label":47}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HAlign = exports.VAlign = void 0;
const Vec2_1 = require("../../DataTypes/Vec2");
const Color_1 = require("../../Utils/Color");
const UIElement_1 = require("../UIElement");
/** A basic text-containing label */
class Label extends UIElement_1.default {
    constructor(position, text) {
        super(position);
        this.text = text;
        this.textColor = new Color_1.default(0, 0, 0, 1);
        this.font = "Arial";
        this.fontSize = 30;
        this.hAlign = "center";
        this.vAlign = "center";
        this.sizeAssigned = false;
    }
    // @deprecated
    setText(text) {
        this.text = text;
    }
    // @deprecated
    setTextColor(color) {
        this.textColor = color;
    }
    /**
     * Gets a string containg the font details for rendering
     * @returns A string containing the font details
     */
    getFontString() {
        return this.fontSize + "px " + this.font;
    }
    /**
     * Overridable method for calculating text color - useful for elements that want to be colored on different after certain events
     * @returns a string containg the text color
     */
    calculateTextColor() {
        return this.textColor.toStringRGBA();
    }
    /**
     * Uses the canvas to calculate the width of the text
     * @param ctx The rendering context
     * @returns A number representing the rendered text width
     */
    calculateTextWidth(ctx) {
        ctx.font = this.fontSize + "px " + this.font;
        return ctx.measureText(this.text).width;
    }
    setHAlign(align) {
        this.hAlign = align;
    }
    setVAlign(align) {
        this.vAlign = align;
    }
    /**
     * Calculate the offset of the text - this is used for rendering text with different alignments
     * @param ctx The rendering context
     * @returns The offset of the text in a Vec2
     */
    calculateTextOffset(ctx) {
        let textWidth = this.calculateTextWidth(ctx);
        let offset = new Vec2_1.default(0, 0);
        let hDiff = this.size.x - textWidth;
        if (this.hAlign === HAlign.CENTER) {
            offset.x = hDiff / 2;
        }
        else if (this.hAlign === HAlign.RIGHT) {
            offset.x = hDiff;
        }
        if (this.vAlign === VAlign.TOP) {
            ctx.textBaseline = "top";
            offset.y = 0;
        }
        else if (this.vAlign === VAlign.BOTTOM) {
            ctx.textBaseline = "bottom";
            offset.y = this.size.y;
        }
        else {
            ctx.textBaseline = "middle";
            offset.y = this.size.y / 2;
        }
        return offset;
    }
    sizeChanged() {
        super.sizeChanged();
        this.sizeAssigned = true;
    }
    /**
     * Automatically sizes the element to the text within it
     * @param ctx The rendering context
     */
    autoSize(ctx) {
        let width = this.calculateTextWidth(ctx);
        let height = this.fontSize;
        this.size.set(width + this.padding.x * 2, height + this.padding.y * 2);
        this.sizeAssigned = true;
    }
    /**
     * Initially assigns a size to the UIElement if none is provided
     * @param ctx The rendering context
     */
    handleInitialSizing(ctx) {
        if (!this.sizeAssigned) {
            this.autoSize(ctx);
        }
    }
    /** On the next render, size this element to it's current text using its current font size */
    sizeToText() {
        this.sizeAssigned = false;
    }
}
exports.default = Label;
var VAlign;
(function (VAlign) {
    VAlign["TOP"] = "top";
    VAlign["CENTER"] = "center";
    VAlign["BOTTOM"] = "bottom";
})(VAlign = exports.VAlign || (exports.VAlign = {}));
var HAlign;
(function (HAlign) {
    HAlign["LEFT"] = "left";
    HAlign["CENTER"] = "center";
    HAlign["RIGHT"] = "right";
})(HAlign = exports.HAlign || (exports.HAlign = {}));

},{"../../DataTypes/Vec2":18,"../../Utils/Color":93,"../UIElement":45}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const Input_1 = require("../../Input/Input");
const Color_1 = require("../../Utils/Color");
const MathUtils_1 = require("../../Utils/MathUtils");
const UIElement_1 = require("../UIElement");
/** A slider UIElement */
class Slider extends UIElement_1.default {
    constructor(position, initValue) {
        super(position);
        this.value = initValue;
        this.nibColor = Color_1.default.RED;
        this.sliderColor = Color_1.default.BLACK;
        this.backgroundColor = Color_1.default.TRANSPARENT;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.nibSize = new Vec2_1.default(10, 20);
        // Set a default size
        this.size.set(200, 20);
    }
    /**
     * Retrieves the value of the slider
     * @returns The value of the slider
     */
    getValue() {
        return this.value;
    }
    /** A method called in response to the value changing */
    valueChanged() {
        if (this.onValueChange) {
            this.onValueChange(this.value);
        }
        if (this.onValueChangeEventId) {
            this.emitter.fireEvent(this.onValueChangeEventId, { target: this, value: this.value });
        }
    }
    update(deltaT) {
        super.update(deltaT);
        if (this.isClicked) {
            let val = MathUtils_1.default.invLerp(this.position.x - this.size.x / 2, this.position.x + this.size.x / 2, Input_1.default.getMousePosition().x);
            this.value = MathUtils_1.default.clamp01(val);
            this.valueChanged();
        }
    }
}
exports.default = Slider;

},{"../../DataTypes/Vec2":18,"../../Input/Input":26,"../../Utils/Color":93,"../../Utils/MathUtils":96,"../UIElement":45}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = require("../../Utils/Color");
const Label_1 = require("./Label");
const Input_1 = require("../../Input/Input");
/** A text input UIElement */
class TextInput extends Label_1.default {
    constructor(position) {
        super(position, "");
        this.focused = false;
        this.cursorCounter = 0;
        // Give a default size to the x only
        this.size.set(200, this.fontSize);
        this.hAlign = "left";
        this.borderColor = Color_1.default.BLACK;
        this.backgroundColor = Color_1.default.WHITE;
    }
    update(deltaT) {
        super.update(deltaT);
        if (Input_1.default.isMouseJustPressed()) {
            let clickPos = Input_1.default.getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y)) {
                this.focused = true;
                this.cursorCounter = 30;
            }
            else {
                this.focused = false;
            }
        }
        if (this.focused) {
            let keys = Input_1.default.getKeysJustPressed();
            let nums = "1234567890";
            let specialChars = "`~!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?";
            let letters = "qwertyuiopasdfghjklzxcvbnm";
            let mask = nums + specialChars + letters;
            keys = keys.filter(key => mask.includes(key));
            let shiftPressed = Input_1.default.isKeyPressed("shift");
            let backspacePressed = Input_1.default.isKeyJustPressed("backspace");
            let spacePressed = Input_1.default.isKeyJustPressed("space");
            if (backspacePressed) {
                this.text = this.text.substring(0, this.text.length - 1);
            }
            else if (spacePressed) {
                this.text += " ";
            }
            else if (keys.length > 0) {
                if (shiftPressed) {
                    this.text += keys[0].toUpperCase();
                }
                else {
                    this.text += keys[0];
                }
            }
        }
    }
}
exports.default = TextInput;

},{"../../Input/Input":26,"../../Utils/Color":93,"./Label":47}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIElementType = void 0;
var UIElementType;
(function (UIElementType) {
    UIElementType["BUTTON"] = "BUTTON";
    UIElementType["LABEL"] = "LABEL";
    UIElementType["SLIDER"] = "SLIDER";
    UIElementType["TEXT_INPUT"] = "TEXTINPUT";
})(UIElementType = exports.UIElementType || (exports.UIElementType = {}));

},{}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * The manager class for navigation.
 * Handles all navigable entities, such and allows them to be accessed by outside systems by requesting a path
 * from one position to another.
 */
class NavigationManager {
    constructor() {
        this.navigableEntities = new Map_1.default();
    }
    /**
     * Adds a navigable entity to the NavigationManager
     * @param navName The name of the navigable entitry
     * @param nav The actual Navigable instance
     */
    addNavigableEntity(navName, nav) {
        this.navigableEntities.add(navName, nav);
    }
    /**
     * Gets a path frome one point to another using a specified Navigable object
     * @param navName The name of the registered Navigable object
     * @param fromPosition The starting position of navigation
     * @param toPosition The ending position of Navigation
     * @param direct If true, go direct from fromPosition to toPosition, don't use NavMesh
     * @returns A NavigationPath containing the route to take over the Navigable entity to get between the provided positions.
     */
    getPath(navName, fromPosition, toPosition, direct) {
        let nav = this.navigableEntities.get(navName);
        return nav.getNavigationPath(fromPosition.clone(), toPosition.clone(), direct);
    }
}
exports.default = NavigationManager;

},{"../DataTypes/Map":7}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
/**
 * A path that AIs can follow. Uses finishMove() in Physical to determine progress on the route
 */
class NavigationPath {
    /**
     * Constructs a new NavigationPath
     * @param path The path of nodes to take
     */
    constructor(path) {
        this.path = path;
        this.currentMoveDirection = Vec2_1.default.ZERO;
        this.distanceThreshold = 4;
    }
    /**
     * Returns the status of navigation along this NavigationPath
     * @returns True if the node has reached the end of the path, false otherwise
     */
    isDone() {
        return this.path.isEmpty();
    }
    /**
     * Gets the movement direction in the current position along the path
     * @param node The node to move along the path
     * @returns The movement direction as a Vec2
     */
    getMoveDirection(node) {
        // Return direction to next point in the nav
        return node.position.dirTo(this.path.peek());
    }
    /**
     * Updates this NavigationPath to the current state of the GameNode
     * @param node The node moving along the path
     */
    handlePathProgress(node) {
        if (node.position.distanceSqTo(this.path.peek()) < this.distanceThreshold * this.distanceThreshold) {
            // We've reached our node, move on to the next destination
            this.path.pop();
        }
    }
    toString() {
        return this.path.toString();
    }
}
exports.default = NavigationPath;

},{"../DataTypes/Vec2":18}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = require("../DataTypes/Stack");
const GraphUtils_1 = require("../Utils/GraphUtils");
const NavigationPath_1 = require("./NavigationPath");
/**
 * An implementation of a Navmesh. Navmeshes are graphs in the game world along which nodes can move.
 */
class Navmesh {
    /**
     * Creates a new Navmesh from the points in the speecified graph
     * @param graph The graph to construct a navmesh from
     */
    constructor(graph) {
        this.graph = graph;
    }
    // @implemented
    getNavigationPath(fromPosition, toPosition, direct) {
        let start = this.getClosestNode(fromPosition);
        let end = this.getClosestNode(toPosition);
        let pathStack = new Stack_1.default(this.graph.numVertices);
        // Push the final position and the final position in the graph
        pathStack.push(toPosition.clone());
        if (direct) {
            return new NavigationPath_1.default(pathStack);
        }
        pathStack.push(this.graph.positions[end]);
        let parent = GraphUtils_1.default.djikstra(this.graph, start);
        // Add all parents along the path
        let i = end;
        while (parent[i] !== -1) {
            pathStack.push(this.graph.positions[parent[i]]);
            i = parent[i];
        }
        return new NavigationPath_1.default(pathStack);
    }
    /**
     * Gets the closest node in this Navmesh to the specified position
     * @param position The position to query
     * @returns The index of the closest node in the Navmesh to the position
     */
    getClosestNode(position) {
        let n = this.graph.numVertices;
        let i = 1;
        let index = 0;
        let dist = position.distanceSqTo(this.graph.positions[0]);
        while (i < n) {
            let d = position.distanceSqTo(this.graph.positions[i]);
            if (d < dist) {
                dist = d;
                index = i;
            }
            i++;
        }
        return index;
    }
}
exports.default = Navmesh;

},{"../DataTypes/Stack":16,"../Utils/GraphUtils":95,"./NavigationPath":52}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PhysicsManager_1 = require("./PhysicsManager");
const Vec2_1 = require("../DataTypes/Vec2");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const OrthogonalTilemap_1 = require("../Nodes/Tilemaps/OrthogonalTilemap");
const AreaCollision_1 = require("../DataTypes/Physics/AreaCollision");
/**
 * ALGORITHM:
 * 	In an effort to keep things simple and working effectively, each dynamic node will resolve its
 * 	collisions considering the rest of the world as static.
 *
 * 	Collision detecting will happen first. This can be considered a broad phase, but it is not especially
 * 	efficient, as it does not need to be for this game engine. Every dynamic node is checked against every
 * 	other node for collision area. If collision area is non-zero (meaning the current node sweeps into another),
 * 	it is added to a list of hits.
 *
 * 	INITIALIZATION:
 * 		- Physics constants are reset
 * 		- Swept shapes are recalculated. If a node isn't moving, it is skipped.
 *
 * 	COLLISION DETECTION:
 * 		- For a node, collision area will be calculated using the swept AABB of the node against every other AABB in a static state
 * 		- These collisions will be sorted by area in descending order
 *
 * 	COLLISION RESOLUTION:
 * 		- For each hit, time of collision is calculated using a swept line through the AABB of the static node expanded
 * 			with minkowski sums (discretely, but the concept is there)
 * 		- The collision is resolved based on the near time of the collision (from method of separated axes)
 * 			- X is resolved by near x, Y by near y.
 * 			- There is some fudging to allow for sliding along walls of separate colliders. Sorting by area also helps with this.
 * 			- Corner to corner collisions are resolve to favor x-movement. This is in consideration of platformers, to give
 * 				the player some help with jumps
 *
 * 	Pros:
 * 		- Everything happens with a consistent time. There is a distinct before and after for each resolution.
 * 		- No back-tracking needs to be done. Once we resolve a node, it is definitively resolved.
 *
 * 	Cons:
 * 		- Nodes that are processed early have movement priority over other nodes. This can lead to some undesirable interactions.
 */
class BasicPhysicsManager extends PhysicsManager_1.default {
    constructor(options) {
        super();
        this.staticNodes = new Array();
        this.dynamicNodes = new Array();
        this.tilemaps = new Array();
        this.collisionMasks = new Array(32);
        // Parse options
        this.parseOptions(options);
    }
    /**
     * Parses the options for constructing the physics manager
     * @param options A record of options
     */
    parseOptions(options) {
        if (options.groupNames !== undefined && options.collisions !== undefined) {
            for (let i = 0; i < options.groupNames.length; i++) {
                let group = options.groupNames[i];
                // Register the group name and number
                this.groupNames[i] = group;
                this.groupMap.set(group, 1 << i);
                let collisionMask = 0;
                for (let j = 0; j < options.collisions[i].length; j++) {
                    if (options.collisions[i][j]) {
                        collisionMask |= 1 << j;
                    }
                }
                this.collisionMasks[i] = collisionMask;
            }
        }
    }
    // @override
    registerObject(node) {
        if (node.isStatic) {
            // Static and not collidable
            this.staticNodes.push(node);
        }
        else {
            // Dynamic and not collidable
            this.dynamicNodes.push(node);
        }
    }
    // @override
    deregisterObject(node) {
        if (node.isStatic) {
            // Remove the node from the static list
            const index = this.staticNodes.indexOf(node);
            this.staticNodes.splice(index, 1);
        }
        else {
            // Remove the node from the dynamic list
            const index = this.dynamicNodes.indexOf(node);
            this.dynamicNodes.splice(index, 1);
        }
    }
    // @override
    registerTilemap(tilemap) {
        this.tilemaps.push(tilemap);
    }
    // @override
    deregisterTilemap(tilemap) {
        const index = this.tilemaps.indexOf(tilemap);
        this.tilemaps.splice(index, 1);
    }
    // @override
    update(deltaT) {
        for (let node of this.dynamicNodes) {
            /*---------- INITIALIZATION PHASE ----------*/
            // Clear frame dependent boolean values for each node
            node.onGround = false;
            node.onCeiling = false;
            node.onWall = false;
            node.collidedWithTilemap = false;
            node.isColliding = false;
            // If this node is not active, don't process it
            if (!node.active) {
                continue;
            }
            // Update the swept shapes of each node
            if (node.moving) {
                // If moving, reflect that in the swept shape
                node.sweptRect.sweep(node._velocity, node.collisionShape.center, node.collisionShape.halfSize);
            }
            else {
                // If our node isn't moving, don't bother to check it (other nodes will detect if they run into it)
                node._velocity.zero();
                continue;
            }
            /*---------- DETECTION PHASE ----------*/
            // Gather a set of overlaps
            let overlaps = new Array();
            let groupIndex = node.group === -1 ? -1 : Math.log2(node.group);
            // First, check this node against every static node (order doesn't actually matter here, since we sort anyways)
            for (let other of this.staticNodes) {
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                let collider = other.collisionShape.getBoundingRect();
                let area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                }
            }
            // Then, check it against every dynamic node
            for (let other of this.dynamicNodes) {
                // Ignore ourselves
                if (node === other)
                    continue;
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                let collider = other.collisionShape.getBoundingRect();
                let area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                }
            }
            // Lastly, gather a set of AABBs from the tilemap.
            // This step involves the most extra work, so it is abstracted into a method
            for (let tilemap of this.tilemaps) {
                // Ignore inactive tilemaps
                if (!tilemap.active)
                    continue;
                if (tilemap instanceof OrthogonalTilemap_1.default) {
                    this.collideWithOrthogonalTilemap(node, tilemap, overlaps);
                }
            }
            // Sort the overlaps by area
            overlaps = overlaps.sort((a, b) => b.area - a.area);
            // Keep track of hits to use later
            let hits = [];
            /*---------- RESOLUTION PHASE ----------*/
            // For every overlap, determine if we need to collide with it and when
            for (let overlap of overlaps) {
                // Ignore nodes we don't interact with
                if (groupIndex !== -1 && overlap.other.group !== -1 && ((this.collisionMasks[groupIndex] & overlap.other.group) === 0))
                    continue;
                // Do a swept line test on the static AABB with this AABB size as padding (this is basically using a minkowski sum!)
                // Start the sweep at the position of this node with a delta of _velocity
                const point = node.collisionShape.center;
                const delta = node._velocity;
                const padding = node.collisionShape.halfSize;
                const otherAABB = overlap.collider;
                const hit = otherAABB.intersectSegment(node.collisionShape.center, node._velocity, node.collisionShape.halfSize);
                overlap.hit = hit;
                if (hit !== null) {
                    hits.push(hit);
                    // We got a hit, resolve with the time inside of the hit
                    let tnearx = hit.nearTimes.x;
                    let tneary = hit.nearTimes.y;
                    // Allow edge clipping (edge overlaps don't count, only area overlaps)
                    // Importantly don't allow both cases to be true. Then we clip through corners. Favor x to help players land jumps
                    if (tnearx < 1.0 && (point.y === otherAABB.top - padding.y || point.y === otherAABB.bottom + padding.y) && delta.x !== 0) {
                        tnearx = 1.0;
                    }
                    else if (tneary < 1.0 && (point.x === otherAABB.left - padding.x || point.x === otherAABB.right + padding.x) && delta.y !== 0) {
                        tneary = 1.0;
                    }
                    if (hit.nearTimes.x >= 0 && hit.nearTimes.x < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.x = node._velocity.x * tnearx;
                            node.isColliding = true;
                        }
                    }
                    if (hit.nearTimes.y >= 0 && hit.nearTimes.y < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.y = node._velocity.y * tneary;
                            node.isColliding = true;
                        }
                    }
                }
            }
            /*---------- INFORMATION/TRIGGER PHASE ----------*/
            // Check if we ended up on the ground, ceiling or wall
            // Also check for triggers
            for (let overlap of overlaps) {
                // Check for a trigger. If we care about the trigger, react
                if (overlap.other.isTrigger && (overlap.other.triggerMask & node.group)) {
                    // Get the bit that this group is represented by
                    let index = Math.floor(Math.log2(node.group));
                    // Extract the triggerEnter event name
                    this.emitter.fireEvent(overlap.other.triggerEnters[index], {
                        node: node.id,
                        other: overlap.other.id
                    });
                }
                // Ignore collision sides for nodes we don't interact with
                if (groupIndex !== -1 && overlap.other.group !== -1 && ((this.collisionMasks[groupIndex] & overlap.other.group) === 0))
                    continue;
                // Only check for direction if the overlap was collidable
                if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                    let collisionSide = overlap.collider.touchesAABBWithoutCorners(node.collisionShape.getBoundingRect());
                    if (collisionSide !== null) {
                        // If we touch, not including corner cases, check the collision normal
                        if (overlap.hit !== null) {
                            // If we hit a tilemap, keep track of it
                            if (overlap.type == "Tilemap") {
                                node.collidedWithTilemap = true;
                            }
                            if (collisionSide.y === -1) {
                                // Node is on top of overlap, so onGround
                                node.onGround = true;
                            }
                            else if (collisionSide.y === 1) {
                                // Node is on bottom of overlap, so onCeiling
                                node.onCeiling = true;
                            }
                            else {
                                // Node wasn't touching on y, so it is touching on x
                                node.onWall = true;
                            }
                        }
                    }
                }
            }
            // Resolve the collision with the node, and move it
            node.finishMove();
        }
    }
    /**
     * Handles a collision between this node and an orthogonal tilemap
     * @param node The node
     * @param tilemap The tilemap the node may be colliding with
     * @param overlaps The list of overlaps
     */
    collideWithOrthogonalTilemap(node, tilemap, overlaps) {
        // Get the min and max x and y coordinates of the moving node
        let min = new Vec2_1.default(node.sweptRect.left, node.sweptRect.top);
        let max = new Vec2_1.default(node.sweptRect.right, node.sweptRect.bottom);
        // Convert the min/max x/y to the min and max row/col in the tilemap array
        let minIndex = tilemap.getColRowAt(min);
        let maxIndex = tilemap.getColRowAt(max);
        let tileSize = tilemap.getTileSize();
        // Loop over all possible tiles (which isn't many in the scope of the velocity per frame)
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (tilemap.isTileCollidable(col, row)) {
                    // Get the position of this tile
                    let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                    // Create a new collider for this tile
                    let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                    // Calculate collision area between the node and the tile
                    let area = node.sweptRect.overlapArea(collider);
                    if (area > 0) {
                        // We had a collision
                        overlaps.push(new AreaCollision_1.default(area, collider, tilemap, "Tilemap", new Vec2_1.default(col, row)));
                    }
                }
            }
        }
    }
}
exports.default = BasicPhysicsManager;

},{"../DataTypes/Physics/AreaCollision":9,"../DataTypes/Shapes/AABB":13,"../DataTypes/Vec2":18,"../Nodes/Tilemaps/OrthogonalTilemap":44,"./PhysicsManager":55}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const Map_1 = require("../DataTypes/Map");
/**
 * An abstract physics manager.
 * This class exposes functions for subclasses to implement that should allow for a working physics system to be created.
 */
class PhysicsManager {
    constructor() {
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        // The creation and implementation of layers is deferred to the subclass
        this.groupMap = new Map_1.default();
        this.groupNames = new Array();
    }
    destroy() {
        this.receiver.destroy();
    }
    /**
     * Sets the physics layer of the GameNode
     * @param node The GameNode
     * @param group The group that the GameNode should be on
     */
    setGroup(node, group) {
        node.group = this.groupMap.get(group);
    }
    /**
     * Retrieves the layer number associated with the provided name
     * @param layer The name of the layer
     * @returns The layer number, or 0 if there is not a layer with that name registered
     */
    getGroupNumber(group) {
        if (this.groupMap.has(group)) {
            return this.groupMap.get(group);
        }
        else {
            return 0;
        }
    }
    /**
     * Gets all group names associated with the number provided
     * @param groups A mask of groups
     * @returns All groups contained in the mask
     */
    getGroupNames(groups) {
        if (groups === -1) {
            return [PhysicsManager.DEFAULT_GROUP];
        }
        else {
            let g = 1;
            let names = [];
            for (let i = 0; i < 32; i++) {
                if (g & groups) {
                    // This group is in the groups number
                    names.push(this.groupNames[i]);
                }
                // Shift the bit over
                g = g << 1;
            }
        }
    }
}
exports.default = PhysicsManager;
/** The default group name */
PhysicsManager.DEFAULT_GROUP = "Default";

},{"../DataTypes/Map":7,"../Events/Emitter":21,"../Events/Receiver":25}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const Receiver_1 = require("../Events/Receiver");
const EventQueue_1 = require("../Events/EventQueue");
const GameEventType_1 = require("../Events/GameEventType");
// @ignorePage
class Recorder {
    constructor() {
        this.receiver = new Receiver_1.default();
        this.log = new Queue_1.default(1000);
        this.recording = false;
        this.playing = false;
        this.frame = 0;
        this.eventQueue = EventQueue_1.default.getInstance();
        this.eventQueue.subscribe(this.receiver, "all");
    }
    update(deltaT) {
        if (this.recording) {
            this.frame += 1;
        }
        if (this.playing) {
            // If playing, ignore events, just feed the record to the event queue
            this.receiver.ignoreEvents();
            /*
                While there is a next item, and while it should occur in this frame,
                send the event. i.e., while current_frame * current_delta_t is greater
                than recorded_frame * recorded_delta_t
            */
            while (this.log.hasItems()
                && this.log.peekNext().frame * this.log.peekNext().delta < this.frame * deltaT) {
                let event = this.log.dequeue().event;
                console.log(event);
                this.eventQueue.addEvent(event);
            }
            if (!this.log.hasItems()) {
                this.playing = false;
            }
            this.frame += 1;
        }
        else {
            // If not playing, handle events
            while (this.receiver.hasNextEvent()) {
                let event = this.receiver.getNextEvent();
                if (event.type === GameEventType_1.GameEventType.STOP_RECORDING) {
                    this.recording = false;
                }
                if (this.recording) {
                    this.log.enqueue(new LogItem(this.frame, deltaT, event));
                }
                if (event.type === GameEventType_1.GameEventType.START_RECORDING) {
                    this.log.clear();
                    this.recording = true;
                    this.frame = 0;
                }
                if (event.type === GameEventType_1.GameEventType.PLAY_RECORDING) {
                    this.frame = 0;
                    this.recording = false;
                    this.playing = true;
                }
            }
        }
    }
}
exports.default = Recorder;
class LogItem {
    constructor(frame, deltaT, event) {
        this.frame = frame;
        this.delta = deltaT;
        this.event = event;
    }
}

},{"../DataTypes/Queue":11,"../Events/EventQueue":22,"../Events/GameEventType":24,"../Events/Receiver":25}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
/** */
class Registry extends Map_1.default {
}
exports.default = Registry;

},{"../../DataTypes/Map":7}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LabelShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType");
const PointShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/PointShaderType");
const RectShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/RectShaderType");
const SpriteShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Registry_1 = require("./Registry");
/**
 * A registry that handles shaders
 */
class ShaderRegistry extends Registry_1.default {
    constructor() {
        super(...arguments);
        this.registryItems = new Array();
    }
    /**
     * Preloads all built-in shaders
     */
    preload() {
        // Get the resourceManager and queue all built-in shaders for preloading
        const rm = ResourceManager_1.default.getInstance();
        // Queue a load for the point shader
        this.registerAndPreloadItem(ShaderRegistry.POINT_SHADER, PointShaderType_1.default, "builtin/shaders/point.vshader", "builtin/shaders/point.fshader");
        // Queue a load for the rect shader
        this.registerAndPreloadItem(ShaderRegistry.RECT_SHADER, RectShaderType_1.default, "builtin/shaders/rect.vshader", "builtin/shaders/rect.fshader");
        // Queue a load for the sprite shader
        this.registerAndPreloadItem(ShaderRegistry.SPRITE_SHADER, SpriteShaderType_1.default, "builtin/shaders/sprite.vshader", "builtin/shaders/sprite.fshader");
        // Queue a load for the label shader
        this.registerAndPreloadItem(ShaderRegistry.LABEL_SHADER, LabelShaderType_1.default, "builtin/shaders/label.vshader", "builtin/shaders/label.fshader");
        // Queue a load for any preloaded items
        for (let item of this.registryItems) {
            const shader = new item.constr(item.key);
            shader.initBufferObject();
            this.add(item.key, shader);
            // Load if desired
            if (item.preload !== undefined) {
                rm.shader(item.key, item.preload.vshaderLocation, item.preload.fshaderLocation);
            }
        }
    }
    /**
     * Registers a shader in the registry and loads it before the game begins
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     * @param vshaderLocation The location of the vertex shader
     * @param fshaderLocation the location of the fragment shader
     */
    registerAndPreloadItem(key, constr, vshaderLocation, fshaderLocation) {
        let shaderPreload = new ShaderPreload();
        shaderPreload.vshaderLocation = vshaderLocation;
        shaderPreload.fshaderLocation = fshaderLocation;
        let registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        registryItem.preload = shaderPreload;
        this.registryItems.push(registryItem);
    }
    /**
     * Registers a shader in the registry. NOTE: If you use this, you MUST load the shader before use.
     * If you wish to preload the shader, use registerAndPreloadItem()
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     */
    registerItem(key, constr) {
        let registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        this.registryItems.push(registryItem);
    }
}
exports.default = ShaderRegistry;
// Shader names
ShaderRegistry.POINT_SHADER = "point";
ShaderRegistry.RECT_SHADER = "rect";
ShaderRegistry.SPRITE_SHADER = "sprite";
ShaderRegistry.LABEL_SHADER = "label";
class ShaderRegistryItem {
}
class ShaderPreload {
}

},{"../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType":72,"../../Rendering/WebGLRendering/ShaderTypes/PointShaderType":73,"../../Rendering/WebGLRendering/ShaderTypes/RectShaderType":75,"../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType":76,"../../ResourceManager/ResourceManager":77,"./Registry":57}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const ShaderRegistry_1 = require("./Registries/ShaderRegistry");
/**
 * The Registry is the system's way of converting classes and types into string
 * representations for use elsewhere in the application.
 * It allows classes to be accessed without explicitly using constructors in code,
 * and for resources to be loaded at Game creation time.
 */
class RegistryManager {
    static preload() {
        this.shaders.preload();
        this.registries.forEach((key) => this.registries.get(key).preload());
    }
    static addCustomRegistry(name, registry) {
        this.registries.add(name, registry);
    }
    static getRegistry(key) {
        return this.registries.get(key);
    }
}
exports.default = RegistryManager;
RegistryManager.shaders = new ShaderRegistry_1.default();
/** Additional custom registries to add to the registry manager */
RegistryManager.registries = new Map_1.default();

},{"../DataTypes/Map":7,"./Registries/ShaderRegistry":58}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
const Emitter_1 = require("../../Events/Emitter");
const AnimationTypes_1 = require("./AnimationTypes");
/**
 * An animation manager class for an animated CanvasNode.
 * This class keeps track of the possible animations, as well as the current animation state,
 * and abstracts all interactions with playing, pausing, and stopping animations as well as
 * creating new animations from the CanvasNode.
 */
class AnimationManager {
    /**
     * Creates a new AnimationManager
     * @param owner The owner of the AnimationManager
     */
    constructor(owner) {
        this.owner = owner;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.currentAnimation = "";
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.loop = false;
        this.animations = new Map_1.default();
        this.onEndEvent = null;
        this.emitter = new Emitter_1.default();
    }
    /**
     * Add an animation to this sprite
     * @param key The unique key of the animation
     * @param animation The animation data
     */
    add(key, animation) {
        this.animations.add(key, animation);
    }
    /**
     * Gets the index specified by the current animation and current frame
     * @returns The index in the current animation
     */
    getIndex() {
        if (this.animations.has(this.currentAnimation)) {
            return this.animations.get(this.currentAnimation).frames[this.currentFrame].index;
        }
        else {
            // No current animation, warn the user
            console.warn(`Animation index was requested, but the current animation: ${this.currentAnimation} was invalid`);
            return 0;
        }
    }
    /**
     * Determines whether the specified animation is currently playing
     * @param key The key of the animation to check
     * @returns true if the specified animation is playing, false otherwise
     */
    isPlaying(key) {
        return this.currentAnimation === key && this.animationState === AnimationTypes_1.AnimationState.PLAYING;
    }
    /**
     * Retrieves the current animation index and advances the animation frame
     * @returns The index of the animation frame
     */
    getIndexAndAdvanceAnimation() {
        // If we aren't playing, we won't be advancing the animation
        if (!(this.animationState === AnimationTypes_1.AnimationState.PLAYING)) {
            return this.getIndex();
        }
        if (this.animations.has(this.currentAnimation)) {
            let currentAnimation = this.animations.get(this.currentAnimation);
            let index = currentAnimation.frames[this.currentFrame].index;
            // Advance the animation
            this.frameProgress += 1;
            if (this.frameProgress >= currentAnimation.frames[this.currentFrame].duration) {
                // We have been on this frame for its whole duration, go to the next one
                this.frameProgress = 0;
                this.currentFrame += 1;
                if (this.currentFrame >= currentAnimation.frames.length) {
                    // We have reached the end of this animation
                    if (this.loop) {
                        this.currentFrame = 0;
                        this.frameProgress = 0;
                    }
                    else {
                        this.endCurrentAnimation();
                    }
                }
            }
            // Return the current index
            return index;
        }
        else {
            // No current animation, can't advance. Warn the user
            console.warn(`Animation index and advance was requested, but the current animation (${this.currentAnimation}) in node with id: ${this.owner.id} was invalid`);
            return 0;
        }
    }
    /** Ends the current animation and fires any necessary events, as well as starting any new animations */
    endCurrentAnimation() {
        this.currentFrame = 0;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        if (this.onEndEvent !== null) {
            this.emitter.fireEvent(this.onEndEvent, { owner: this.owner.id, animation: this.currentAnimation });
        }
        // If there is a pending animation, play it
        if (this.pendingAnimation !== null) {
            this.play(this.pendingAnimation, this.pendingLoop, this.pendingOnEnd);
        }
    }
    /**
     * Plays the specified animation. Does not restart it if it is already playing
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    playIfNotAlready(animation, loop, onEnd) {
        if (this.currentAnimation !== animation) {
            this.play(animation, loop, onEnd);
        }
    }
    /**
     * Plays the specified animation
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    play(animation, loop, onEnd) {
        this.currentAnimation = animation;
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        // If loop arg was provided, use that
        if (loop !== undefined) {
            this.loop = loop;
        }
        else {
            // Otherwise, use what the json file specified
            this.loop = this.animations.get(animation).repeat;
        }
        if (onEnd !== undefined) {
            this.onEndEvent = onEnd;
        }
        else {
            this.onEndEvent = null;
        }
        // Reset pending animation
        this.pendingAnimation = null;
    }
    /**
     * Queues a single animation to be played after the current one. Does NOT stack.
     * Queueing additional animations past 1 will just replace the queued animation
     * @param animation The animation to queue
     * @param loop Whether or not the loop the queued animation
     * @param onEnd The event to fire when the queued animation ends
     */
    queue(animation, loop = false, onEnd) {
        this.pendingAnimation = animation;
        this.pendingLoop = loop;
        if (onEnd !== undefined) {
            this.pendingOnEnd = onEnd;
        }
        else {
            this.pendingOnEnd = null;
        }
    }
    /** Pauses the current animation */
    pause() {
        this.animationState = AnimationTypes_1.AnimationState.PAUSED;
    }
    /** Resumes the current animation if possible */
    resume() {
        if (this.animationState === AnimationTypes_1.AnimationState.PAUSED) {
            this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    }
    /** Stops the current animation. The animation cannot be resumed after this. */
    stop() {
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
    }
}
exports.default = AnimationManager;

},{"../../DataTypes/Map":7,"../../Events/Emitter":21,"./AnimationTypes":61}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenData = exports.TweenEffect = exports.AnimationData = exports.AnimationState = void 0;
// @ignorePage
var AnimationState;
(function (AnimationState) {
    AnimationState[AnimationState["STOPPED"] = 0] = "STOPPED";
    AnimationState[AnimationState["PAUSED"] = 1] = "PAUSED";
    AnimationState[AnimationState["PLAYING"] = 2] = "PLAYING";
})(AnimationState = exports.AnimationState || (exports.AnimationState = {}));
class AnimationData {
    constructor() {
        this.repeat = false;
    }
}
exports.AnimationData = AnimationData;
class TweenEffect {
}
exports.TweenEffect = TweenEffect;
class TweenData {
}
exports.TweenData = TweenData;

},{}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ParticleSystemManager {
    constructor() {
        this.particleSystems = new Array();
    }
    static getInstance() {
        if (ParticleSystemManager.instance === null) {
            ParticleSystemManager.instance = new ParticleSystemManager();
        }
        return ParticleSystemManager.instance;
    }
    registerParticleSystem(system) {
        this.particleSystems.push(system);
    }
    deregisterParticleSystem(system) {
        let index = this.particleSystems.indexOf(system);
        this.particleSystems.splice(index, 1);
    }
    clearParticleSystems() {
        this.particleSystems = new Array();
    }
    update(deltaT) {
        for (let particleSystem of this.particleSystems) {
            particleSystem.update(deltaT);
        }
    }
}
exports.default = ParticleSystemManager;
ParticleSystemManager.instance = null;

},{}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
const AnimationTypes_1 = require("./AnimationTypes");
const EaseFunctions_1 = require("../../Utils/EaseFunctions");
const MathUtils_1 = require("../../Utils/MathUtils");
const TweenManager_1 = require("./TweenManager");
const Emitter_1 = require("../../Events/Emitter");
/**
 * A manager for the tweens of a GameNode.
 * Tweens are short animations played by interpolating between two properties using an easing function.
 * For a good visual representation of easing functions, check out @link(https://easings.net/)(https://easings.net/).
 * Multiple tween can be played at the same time, as long as they don't change the same property.
 * This allows for some interesting polishes or animations that may be very difficult to do with sprite work alone
 * - especially pixel art (such as rotations or scaling).
 */
class TweenController {
    /**
     * Creates a new TweenController
     * @param owner The owner of the TweenController
     */
    constructor(owner) {
        this.owner = owner;
        this.tweens = new Map_1.default();
        this.emitter = new Emitter_1.default();
        // Give ourselves to the TweenManager
        TweenManager_1.default.getInstance().registerTweenController(this);
    }
    /**
     * Destroys this TweenController
     */
    destroy() {
        // Only the gamenode and the tween manager should have a reference to this
        delete this.owner.tweens;
        TweenManager_1.default.getInstance().deregisterTweenController(this);
    }
    /**
     * Add a tween to this game node
     * @param key The name of the tween
     * @param tween The data of the tween
     */
    add(key, tween) {
        let typedTween = tween;
        // Initialize members that we need (and the user didn't provide)
        typedTween.progress = 0;
        typedTween.elapsedTime = 0;
        typedTween.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.tweens.add(key, typedTween);
    }
    /**
     * Play a tween with a certain name
     * @param key The name of the tween to play
     * @param loop Whether or not the tween should loop
     */
    play(key, loop) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            // Set loop if needed
            if (loop !== undefined) {
                tween.loop = loop;
            }
            // Set the initial values
            for (let effect of tween.effects) {
                if (effect.resetOnComplete) {
                    effect.initialValue = this.owner[effect.property];
                }
            }
            // Start the tween running
            tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
            tween.elapsedTime = 0;
            tween.progress = 0;
            tween.reversing = false;
        }
        else {
            console.warn(`Tried to play tween "${key}" on node with id ${this.owner.id}, but no such tween exists`);
        }
    }
    /**
     * Pauses a playing tween. Does not affect tweens that are stopped.
     * @param key The name of the tween to pause.
     */
    pause(key) {
        if (this.tweens.has(key)) {
            this.tweens.get(key).animationState = AnimationTypes_1.AnimationState.PAUSED;
        }
    }
    /**
     * Resumes a paused tween.
     * @param key The name of the tween to resume
     */
    resume(key) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PAUSED)
                tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    }
    /**
     * Stops a currently playing tween
     * @param key The key of the tween
     */
    stop(key) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            tween.animationState = AnimationTypes_1.AnimationState.STOPPED;
            // Return to the initial values
            for (let effect of tween.effects) {
                if (effect.resetOnComplete) {
                    this.owner[effect.property] = effect.initialValue;
                }
            }
        }
    }
    /**
     * The natural stop of a currently playing tween
     * @param key The key of the tween
     */
    end(key) {
        this.stop(key);
        if (this.tweens.has(key)) {
            // Get the tween
            let tween = this.tweens.get(key);
            // If it has an onEnd, send an event
            if (tween.onEnd) {
                this.emitter.fireEvent(tween.onEnd, { key: key, node: this.owner.id });
            }
        }
    }
    /**
     * Stops all currently playing tweens
     */
    stopAll() {
        this.tweens.forEach(key => this.stop(key));
    }
    update(deltaT) {
        this.tweens.forEach(key => {
            let tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PLAYING) {
                // Update the progress of the tween
                tween.elapsedTime += deltaT * 1000;
                // If we're past the startDelay, do the tween
                if (tween.elapsedTime >= tween.startDelay) {
                    if (!tween.reversing && tween.elapsedTime >= tween.startDelay + tween.duration) {
                        // If we're over time, stop the tween, loop, or reverse
                        if (tween.reverseOnComplete) {
                            // If we're over time and can reverse, do so
                            tween.reversing = true;
                        }
                        else if (tween.loop) {
                            // If we can't reverse and can loop, do so
                            tween.elapsedTime -= tween.duration;
                        }
                        else {
                            // We aren't looping and can't reverse, so stop
                            this.end(key);
                        }
                    }
                    // Check for the end of reversing
                    if (tween.reversing && tween.elapsedTime >= tween.startDelay + 2 * tween.duration) {
                        if (tween.loop) {
                            tween.reversing = false;
                            tween.elapsedTime -= 2 * tween.duration;
                        }
                        else {
                            this.end(key);
                        }
                    }
                    // Update the progress, make sure it is between 0 and 1. Errors from this should never be large
                    if (tween.reversing) {
                        tween.progress = MathUtils_1.default.clamp01((2 * tween.duration - (tween.elapsedTime - tween.startDelay)) / tween.duration);
                    }
                    else {
                        tween.progress = MathUtils_1.default.clamp01((tween.elapsedTime - tween.startDelay) / tween.duration);
                    }
                    for (let effect of tween.effects) {
                        // Get the value from the ease function that corresponds to our progress
                        let ease = EaseFunctions_1.default[effect.ease](tween.progress);
                        // Use the value to lerp the property
                        let value = MathUtils_1.default.lerp(effect.start, effect.end, ease);
                        // Assign the value of the property
                        this.owner[effect.property] = value;
                    }
                }
            }
        });
    }
}
exports.default = TweenController;

},{"../../DataTypes/Map":7,"../../Events/Emitter":21,"../../Utils/EaseFunctions":94,"../../Utils/MathUtils":96,"./AnimationTypes":61,"./TweenManager":64}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TweenManager {
    constructor() {
        this.tweenControllers = new Array();
    }
    static getInstance() {
        if (TweenManager.instance === null) {
            TweenManager.instance = new TweenManager();
        }
        return TweenManager.instance;
    }
    registerTweenController(controller) {
        this.tweenControllers.push(controller);
    }
    deregisterTweenController(controller) {
        let index = this.tweenControllers.indexOf(controller);
        this.tweenControllers.splice(index, 1);
    }
    clearTweenControllers() {
        this.tweenControllers = new Array();
    }
    update(deltaT) {
        for (let tweenController of this.tweenControllers) {
            tweenController.update(deltaT);
        }
    }
}
exports.default = TweenManager;
TweenManager.instance = null;

},{}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Nodes/Graphic");
const Point_1 = require("../Nodes/Graphics/Point");
const Rect_1 = require("../Nodes/Graphics/Rect");
const Sprite_1 = require("../Nodes/Sprites/Sprite");
const OrthogonalTilemap_1 = require("../Nodes/Tilemaps/OrthogonalTilemap");
const UIElement_1 = require("../Nodes/UIElement");
const GraphicRenderer_1 = require("./CanvasRendering/GraphicRenderer");
const RenderingManager_1 = require("./RenderingManager");
const TilemapRenderer_1 = require("./CanvasRendering/TilemapRenderer");
const UIElementRenderer_1 = require("./CanvasRendering/UIElementRenderer");
const Label_1 = require("../Nodes/UIElements/Label");
const Button_1 = require("../Nodes/UIElements/Button");
const Slider_1 = require("../Nodes/UIElements/Slider");
const TextInput_1 = require("../Nodes/UIElements/TextInput");
const AnimatedSprite_1 = require("../Nodes/Sprites/AnimatedSprite");
const Vec2_1 = require("../DataTypes/Vec2");
const Line_1 = require("../Nodes/Graphics/Line");
const Debug_1 = require("../Debug/Debug");
/**
 * An implementation of the RenderingManager class using CanvasRenderingContext2D.
 */
class CanvasRenderer extends RenderingManager_1.default {
    constructor() {
        super();
    }
    // @override
    setScene(scene) {
        this.scene = scene;
        this.graphicRenderer.setScene(scene);
        this.tilemapRenderer.setScene(scene);
        this.uiElementRenderer.setScene(scene);
    }
    // @override
    initializeCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = new Vec2_1.default(width, height);
        this.ctx = canvas.getContext("2d");
        this.graphicRenderer = new GraphicRenderer_1.default(this.ctx);
        this.tilemapRenderer = new TilemapRenderer_1.default(this.ctx);
        this.uiElementRenderer = new UIElementRenderer_1.default(this.ctx);
        // For crisp pixel art
        this.ctx.imageSmoothingEnabled = false;
        return this.ctx;
    }
    // @override
    render(visibleSet, tilemaps, uiLayers) {
        // Sort by depth, then by visible set by y-value
        visibleSet.sort((a, b) => {
            if (a.getLayer().getDepth() === b.getLayer().getDepth()) {
                return (a.boundary.bottom) - (b.boundary.bottom);
            }
            else {
                return a.getLayer().getDepth() - b.getLayer().getDepth();
            }
        });
        let tilemapIndex = 0;
        let tilemapLength = tilemaps.length;
        let visibleSetIndex = 0;
        let visibleSetLength = visibleSet.length;
        while (tilemapIndex < tilemapLength || visibleSetIndex < visibleSetLength) {
            // Check conditions where we've already reached the edge of one list
            if (tilemapIndex >= tilemapLength) {
                // Only render the remaining visible set
                let node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
                continue;
            }
            if (visibleSetIndex >= visibleSetLength) {
                // Only render tilemaps
                this.renderTilemap(tilemaps[tilemapIndex++]);
                continue;
            }
            // Render whichever is further down
            if (tilemaps[tilemapIndex].getLayer().getDepth() <= visibleSet[visibleSetIndex].getLayer().getDepth()) {
                this.renderTilemap(tilemaps[tilemapIndex++]);
            }
            else {
                let node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
            }
        }
        // Render the uiLayers on top of everything else
        let sortedUILayers = new Array();
        uiLayers.forEach(key => sortedUILayers.push(uiLayers.get(key)));
        sortedUILayers = sortedUILayers.sort((ui1, ui2) => ui1.getDepth() - ui2.getDepth());
        sortedUILayers.forEach(uiLayer => {
            if (!uiLayer.isHidden())
                uiLayer.getItems().forEach(node => {
                    if (node.visible) {
                        this.renderNode(node);
                    }
                });
        });
    }
    /**
     * Renders a specified CanvasNode
     * @param node The CanvasNode to render
     */
    renderNode(node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        // Move the canvas to the position of the node and rotate
        let xScale = 1;
        let yScale = 1;
        if (node instanceof Sprite_1.default) {
            xScale = node.invertX ? -1 : 1;
            yScale = node.invertY ? -1 : 1;
        }
        this.ctx.setTransform(xScale, 0, 0, yScale, (node.position.x - this.origin.x) * this.zoom, (node.position.y - this.origin.y) * this.zoom);
        this.ctx.rotate(-node.rotation);
        let globalAlpha = this.ctx.globalAlpha;
        if (node instanceof Rect_1.default) {
            Debug_1.default.log("node" + node.id, "Node" + node.id + " Alpha: " + node.alpha);
        }
        this.ctx.globalAlpha = node.alpha;
        if (node instanceof AnimatedSprite_1.default) {
            this.renderAnimatedSprite(node);
        }
        else if (node instanceof Sprite_1.default) {
            this.renderSprite(node);
        }
        else if (node instanceof Graphic_1.default) {
            this.renderGraphic(node);
        }
        else if (node instanceof UIElement_1.default) {
            this.renderUIElement(node);
        }
        this.ctx.globalAlpha = globalAlpha;
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    // @override
    renderSprite(sprite) {
        // Get the image from the resource manager
        let image = this.resourceManager.getImage(sprite.imageId);
        /*
            Coordinates in the space of the image:
                image crop start -> x, y
                image crop size  -> w, h
            Coordinates in the space of the world
                image draw start -> x, y
                image draw size  -> w, h
        */
        this.ctx.drawImage(image, sprite.imageOffset.x, sprite.imageOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    }
    // @override
    renderAnimatedSprite(sprite) {
        // Get the image from the resource manager
        let image = this.resourceManager.getImage(sprite.imageId);
        let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
        let animationOffset = sprite.getAnimationOffset(animationIndex);
        /*
            Coordinates in the space of the image:
                image crop start -> x, y
                image crop size  -> w, h
            Coordinates in the space of the world (given we moved)
                image draw start -> -w/2, -h/2
                image draw size  -> w, h
        */
        this.ctx.drawImage(image, sprite.imageOffset.x + animationOffset.x, sprite.imageOffset.y + animationOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    }
    // @override
    renderGraphic(graphic) {
        if (graphic instanceof Point_1.default) {
            this.graphicRenderer.renderPoint(graphic, this.zoom);
        }
        else if (graphic instanceof Line_1.default) {
            this.graphicRenderer.renderLine(graphic, this.origin, this.zoom);
        }
        else if (graphic instanceof Rect_1.default) {
            this.graphicRenderer.renderRect(graphic, this.zoom);
        }
    }
    // @override
    renderTilemap(tilemap) {
        if (tilemap instanceof OrthogonalTilemap_1.default) {
            this.tilemapRenderer.renderOrthogonalTilemap(tilemap);
        }
    }
    // @override
    renderUIElement(uiElement) {
        if (uiElement instanceof Label_1.default) {
            this.uiElementRenderer.renderLabel(uiElement);
        }
        else if (uiElement instanceof Button_1.default) {
            this.uiElementRenderer.renderButton(uiElement);
        }
        else if (uiElement instanceof Slider_1.default) {
            this.uiElementRenderer.renderSlider(uiElement);
        }
        else if (uiElement instanceof TextInput_1.default) {
            this.uiElementRenderer.renderTextInput(uiElement);
        }
    }
    clear(clearColor) {
        this.ctx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
        this.ctx.fillStyle = clearColor.toString();
        this.ctx.fillRect(0, 0, this.worldSize.x, this.worldSize.y);
    }
}
exports.default = CanvasRenderer;

},{"../DataTypes/Vec2":18,"../Debug/Debug":19,"../Nodes/Graphic":35,"../Nodes/Graphics/Line":37,"../Nodes/Graphics/Point":39,"../Nodes/Graphics/Rect":40,"../Nodes/Sprites/AnimatedSprite":41,"../Nodes/Sprites/Sprite":42,"../Nodes/Tilemaps/OrthogonalTilemap":44,"../Nodes/UIElement":45,"../Nodes/UIElements/Button":46,"../Nodes/UIElements/Label":47,"../Nodes/UIElements/Slider":48,"../Nodes/UIElements/TextInput":49,"./CanvasRendering/GraphicRenderer":66,"./CanvasRendering/TilemapRenderer":67,"./CanvasRendering/UIElementRenderer":68,"./RenderingManager":69}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[Graphic]s
 */
class GraphicRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this GraphicRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders a point
     * @param point The point to render
     * @param zoom The zoom level
     */
    renderPoint(point, zoom) {
        this.ctx.fillStyle = point.color.toStringRGBA();
        this.ctx.fillRect((-point.size.x / 2) * zoom, (-point.size.y / 2) * zoom, point.size.x * zoom, point.size.y * zoom);
    }
    renderLine(line, origin, zoom) {
        this.ctx.strokeStyle = line.color.toStringRGBA();
        this.ctx.lineWidth = line.thickness;
        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.lineTo((line.end.x - line.start.x) * zoom, (line.end.y - line.start.y) * zoom);
        this.ctx.closePath();
        this.ctx.stroke();
    }
    /**
     * Renders a rect
     * @param rect The rect to render
     * @param zoom The zoom level
     */
    renderRect(rect, zoom) {
        // Draw the interior of the rect
        if (rect.color.a !== 0) {
            this.ctx.fillStyle = rect.color.toStringRGB();
            this.ctx.fillRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
        // Draw the border of the rect if it isn't transparent
        if (rect.borderColor.a !== 0) {
            this.ctx.strokeStyle = rect.getBorderColor().toStringRGB();
            this.ctx.lineWidth = rect.getBorderWidth();
            this.ctx.strokeRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
    }
}
exports.default = GraphicRenderer;

},{"../../ResourceManager/ResourceManager":77}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/**
 * A utility class for the @reference[CanvasRenderer] to render @reference[Tilemap]s
 */
class TilemapRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this TilemapRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders an orthogonal tilemap
     * @param tilemap The tilemap to render
     */
    renderOrthogonalTilemap(tilemap) {
        let previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = tilemap.getLayer().getAlpha();
        let origin = this.scene.getViewTranslation(tilemap);
        let size = this.scene.getViewport().getHalfSize();
        let zoom = this.scene.getViewScale();
        let bottomRight = origin.clone().add(size.scaled(2 * zoom));
        if (tilemap.visible) {
            let minColRow = tilemap.getColRowAt(origin);
            let maxColRow = tilemap.getColRowAt(bottomRight);
            for (let x = minColRow.x; x <= maxColRow.x; x++) {
                for (let y = minColRow.y; y <= maxColRow.y; y++) {
                    // Get the tile at this position
                    let tile = tilemap.getTileAtRowCol(new Vec2_1.default(x, y));
                    // Extract the rot/flip parameters if there are any
                    const mask = (0xE << 28);
                    const rotFlip = ((mask & tile) >> 28) & 0xF;
                    tile = tile & ~mask;
                    // Find the tileset that owns this tile index and render
                    for (let tileset of tilemap.getTilesets()) {
                        if (tileset.hasTile(tile)) {
                            this.renderTile(tileset, tile, x, y, origin, tilemap.scale, zoom, rotFlip);
                        }
                    }
                }
            }
        }
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a tile
     * @param tileset The tileset this tile belongs to
     * @param tileIndex The index of the tile
     * @param tilemapRow The row of the tile in the tilemap
     * @param tilemapCol The column of the tile in the tilemap
     * @param origin The origin of the viewport
     * @param scale The scale of the tilemap
     * @param zoom The zoom level of the viewport
     */
    renderTile(tileset, tileIndex, tilemapRow, tilemapCol, origin, scale, zoom, rotFlip) {
        let image = this.resourceManager.getImage(tileset.getImageKey());
        // Get the true index
        let index = tileIndex - tileset.getStartIndex();
        // Get the row and col of the tile in image space
        let row = Math.floor(index / tileset.getNumCols());
        let col = index % tileset.getNumCols();
        let width = tileset.getTileSize().x;
        let height = tileset.getTileSize().y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        // Calculate the position in the world to render the tile
        let x = Math.floor(tilemapRow * width * scale.x);
        let y = Math.floor(tilemapCol * height * scale.y);
        let worldX = Math.floor((x - origin.x) * zoom);
        let worldY = Math.floor((y - origin.y) * zoom);
        let worldWidth = Math.ceil(width * scale.x * zoom);
        let worldHeight = Math.ceil(height * scale.y * zoom);
        if (rotFlip !== 0) {
            let scaleX = 1;
            let scaleY = 1;
            let shearX = 0;
            let shearY = 0;
            // Flip on the x-axis
            if (rotFlip & 8) {
                scaleX = -1;
            }
            // Flip on the y-axis
            if (rotFlip & 4) {
                scaleY = -1;
            }
            // Flip over the line y=x
            if (rotFlip & 2) {
                shearX = scaleY;
                shearY = scaleX;
                scaleX = 0;
                scaleY = 0;
            }
            this.ctx.setTransform(scaleX, shearX, shearY, scaleY, worldX + worldWidth / 2, worldY + worldHeight / 2);
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, -worldWidth / 2, -worldHeight / 2, worldWidth, worldHeight);
            if (rotFlip !== 0) {
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
        }
        else {
            // No rotations, don't do the calculations, just render the tile
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, worldX, worldY, worldWidth, worldHeight);
        }
    }
}
exports.default = TilemapRenderer;

},{"../../DataTypes/Vec2":18,"../../ResourceManager/ResourceManager":77}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const MathUtils_1 = require("../../Utils/MathUtils");
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[UIElement]s
 */
class UIElementRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this UIElementRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders a label
     * @param label The label to render
     */
    renderLabel(label) {
        // If the size is unassigned (by the user or automatically) assign it
        label.handleInitialSizing(this.ctx);
        // Grab the global alpha so we can adjust it for this render
        let previousAlpha = this.ctx.globalAlpha;
        // Get the font and text position in label
        this.ctx.font = label.getFontString();
        let offset = label.calculateTextOffset(this.ctx);
        // Stroke and fill a rounded rect and give it text
        this.ctx.globalAlpha = label.backgroundColor.a;
        this.ctx.fillStyle = label.calculateBackgroundColor().toStringRGBA();
        this.ctx.fillRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.strokeStyle = label.calculateBorderColor().toStringRGBA();
        this.ctx.globalAlpha = label.borderColor.a;
        this.ctx.lineWidth = label.borderWidth;
        this.ctx.strokeRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.fillStyle = label.calculateTextColor();
        this.ctx.globalAlpha = label.textColor.a;
        this.ctx.fillText(label.text, offset.x - label.size.x / 2, offset.y - label.size.y / 2);
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a button
     * @param button The button to render
     */
    renderButton(button) {
        this.renderLabel(button);
    }
    /**
     * Renders a slider
     * @param slider The slider to render
     */
    renderSlider(slider) {
        // Grab the global alpha so we can adjust it for this render
        let previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = slider.getLayer().getAlpha();
        // Calcualate the slider size
        let sliderSize = new Vec2_1.default(slider.size.x, 2);
        // Draw the slider
        this.ctx.fillStyle = slider.sliderColor.toString();
        this.ctx.fillRoundedRect(-sliderSize.x / 2, -sliderSize.y / 2, sliderSize.x, sliderSize.y, slider.borderRadius);
        // Calculate the nib size and position
        let x = MathUtils_1.default.lerp(-slider.size.x / 2, slider.size.x / 2, slider.getValue());
        // Draw the nib
        this.ctx.fillStyle = slider.nibColor.toString();
        this.ctx.fillRoundedRect(x - slider.nibSize.x / 2, -slider.nibSize.y / 2, slider.nibSize.x, slider.nibSize.y, slider.borderRadius);
        // Reset the alpha
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a textInput
     * @param textInput The textInput to render
     */
    renderTextInput(textInput) {
        // Show a cursor sometimes
        if (textInput.focused && textInput.cursorCounter % 60 > 30) {
            textInput.text += "|";
        }
        this.renderLabel(textInput);
        if (textInput.focused) {
            if (textInput.cursorCounter % 60 > 30) {
                textInput.text = textInput.text.substring(0, textInput.text.length - 1);
            }
            textInput.cursorCounter += 1;
            if (textInput.cursorCounter >= 60) {
                textInput.cursorCounter = 0;
            }
        }
    }
}
exports.default = UIElementRenderer;

},{"../../DataTypes/Vec2":18,"../../ResourceManager/ResourceManager":77,"../../Utils/MathUtils":96}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
/**
 * An abstract framework to put all rendering in once place in the application
 */
class RenderingManager {
    constructor() {
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /**
     * Sets the scene currently being rendered
     * @param scene The current Scene
     */
    setScene(scene) {
        this.scene = scene;
    }
}
exports.default = RenderingManager;

},{"../ResourceManager/ResourceManager":77}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const Graphic_1 = require("../Nodes/Graphic");
const Point_1 = require("../Nodes/Graphics/Point");
const Rect_1 = require("../Nodes/Graphics/Rect");
const AnimatedSprite_1 = require("../Nodes/Sprites/AnimatedSprite");
const Sprite_1 = require("../Nodes/Sprites/Sprite");
const UIElement_1 = require("../Nodes/UIElement");
const Label_1 = require("../Nodes/UIElements/Label");
const ShaderRegistry_1 = require("../Registry/Registries/ShaderRegistry");
const RegistryManager_1 = require("../Registry/RegistryManager");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const ParallaxLayer_1 = require("../Scene/Layers/ParallaxLayer");
const RenderingManager_1 = require("./RenderingManager");
class WebGLRenderer extends RenderingManager_1.default {
    initializeCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = Vec2_1.default.ZERO;
        this.worldSize.x = width;
        this.worldSize.y = height;
        // Get the WebGL context
        this.gl = canvas.getContext("webgl");
        this.gl.viewport(0, 0, canvas.width, canvas.height);
        this.gl.disable(this.gl.DEPTH_TEST);
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.enable(this.gl.CULL_FACE);
        // Tell the resource manager we're using WebGL
        ResourceManager_1.default.getInstance().useWebGL(true, this.gl);
        // Show the text canvas and get its context
        let textCanvas = document.getElementById("text-canvas");
        textCanvas.hidden = false;
        this.textCtx = textCanvas.getContext("2d");
        // Size the text canvas to be the same as the game canvas
        textCanvas.height = height;
        textCanvas.width = width;
        return this.gl;
    }
    render(visibleSet, tilemaps, uiLayers) {
        for (let node of visibleSet) {
            this.renderNode(node);
        }
        uiLayers.forEach(key => {
            if (!uiLayers.get(key).isHidden())
                uiLayers.get(key).getItems().forEach(node => this.renderNode(node));
        });
    }
    clear(color) {
        this.gl.clearColor(color.r, color.g, color.b, color.a);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        this.textCtx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
    }
    renderNode(node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        if (node.hasCustomShader) {
            // If the node has a custom shader, render using that
            this.renderCustom(node);
        }
        else if (node instanceof Graphic_1.default) {
            this.renderGraphic(node);
        }
        else if (node instanceof Sprite_1.default) {
            if (node instanceof AnimatedSprite_1.default) {
                this.renderAnimatedSprite(node);
            }
            else {
                this.renderSprite(node);
            }
        }
        else if (node instanceof UIElement_1.default) {
            this.renderUIElement(node);
        }
    }
    renderSprite(sprite) {
        let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
        let options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    }
    renderAnimatedSprite(sprite) {
        let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
        let options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    }
    renderGraphic(graphic) {
        if (graphic instanceof Point_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.POINT_SHADER);
            let options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
        else if (graphic instanceof Rect_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.RECT_SHADER);
            let options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
    }
    renderTilemap(tilemap) {
        throw new Error("Method not implemented.");
    }
    renderUIElement(uiElement) {
        if (uiElement instanceof Label_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.LABEL_SHADER);
            let options = this.addOptions(shader.getOptions(uiElement), uiElement);
            shader.render(this.gl, options);
            this.textCtx.setTransform(1, 0, 0, 1, (uiElement.position.x - this.origin.x) * this.zoom, (uiElement.position.y - this.origin.y) * this.zoom);
            this.textCtx.rotate(-uiElement.rotation);
            let globalAlpha = this.textCtx.globalAlpha;
            this.textCtx.globalAlpha = uiElement.alpha;
            // Render text
            this.textCtx.font = uiElement.getFontString();
            let offset = uiElement.calculateTextOffset(this.textCtx);
            this.textCtx.fillStyle = uiElement.calculateTextColor();
            this.textCtx.globalAlpha = uiElement.textColor.a;
            this.textCtx.fillText(uiElement.text, offset.x - uiElement.size.x / 2, offset.y - uiElement.size.y / 2);
            this.textCtx.globalAlpha = globalAlpha;
            this.textCtx.setTransform(1, 0, 0, 1, 0, 0);
        }
    }
    renderCustom(node) {
        let shader = RegistryManager_1.default.shaders.get(node.customShaderKey);
        let options = this.addOptions(shader.getOptions(node), node);
        shader.render(this.gl, options);
    }
    addOptions(options, node) {
        // Give the shader access to the world size
        options.worldSize = this.worldSize;
        // Adjust the origin position to the parallax
        let layer = node.getLayer();
        let parallax = new Vec2_1.default(1, 1);
        if (layer instanceof ParallaxLayer_1.default) {
            parallax = layer.parallax;
        }
        options.origin = this.origin.clone().mult(parallax);
        return options;
    }
}
exports.default = WebGLRenderer;

},{"../DataTypes/Vec2":18,"../Nodes/Graphic":35,"../Nodes/Graphics/Point":39,"../Nodes/Graphics/Rect":40,"../Nodes/Sprites/AnimatedSprite":41,"../Nodes/Sprites/Sprite":42,"../Nodes/UIElement":45,"../Nodes/UIElements/Label":47,"../Registry/Registries/ShaderRegistry":58,"../Registry/RegistryManager":59,"../ResourceManager/ResourceManager":77,"../Scene/Layers/ParallaxLayer":82,"./RenderingManager":69}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
/**
 * A wrapper class for WebGL shaders.
 * This class is a singleton, and there is only one for each shader type.
 * All objects that use this shader type will refer to and modify this same type.
 */
class ShaderType {
    constructor(programKey) {
        this.programKey = programKey;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /**
     * Extracts the options from the CanvasNode and gives them to the render function
     * @param node The node to get options from
     * @returns An object containing the options that should be passed to the render function
     */
    getOptions(node) { return {}; }
}
exports.default = ShaderType;

},{"../../ResourceManager/ResourceManager":77}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
/** */
class LabelShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "label";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const backgroundColor = options.backgroundColor.toWebGL();
        const borderColor = options.borderColor.toWebGL();
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_BackgroundColor = gl.getUniformLocation(program, "u_BackgroundColor");
        gl.uniform4fv(u_BackgroundColor, backgroundColor);
        const u_BorderColor = gl.getUniformLocation(program, "u_BorderColor");
        gl.uniform4fv(u_BorderColor, borderColor);
        const u_MaxSize = gl.getUniformLocation(program, "u_MaxSize");
        gl.uniform2f(u_MaxSize, -vertexData[0], vertexData[1]);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        const u_BorderWidth = gl.getUniformLocation(program, "u_BorderWidth");
        gl.uniform1f(u_BorderWidth, options.borderWidth / maxDimension);
        const u_BorderRadius = gl.getUniformLocation(program, "u_BorderRadius");
        gl.uniform1f(u_BorderRadius, options.borderRadius / maxDimension);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([
            -x, y,
            -x, -y,
            x, y,
            x, -y
        ]);
    }
    getOptions(rect) {
        let options = {
            position: rect.position,
            backgroundColor: rect.calculateBackgroundColor(),
            borderColor: rect.calculateBorderColor(),
            borderWidth: rect.borderWidth,
            borderRadius: rect.borderRadius,
            size: rect.size,
            rotation: rect.rotation
        };
        return options;
    }
}
exports.default = LabelShaderType;

},{"../../../DataTypes/Mat4x4":8,"../../../DataTypes/Vec2":18,"../../../ResourceManager/ResourceManager":77,"./QuadShaderType":74}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RenderingUtils_1 = require("../../../Utils/RenderingUtils");
const ShaderType_1 = require("../ShaderType");
class PointShaderType extends ShaderType_1.default {
    constructor(programKey) {
        super(programKey);
    }
    initBufferObject() {
        this.bufferObjectKey = "point";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        let position = RenderingUtils_1.default.toWebGLCoords(options.position, options.origin, options.worldSize);
        let color = RenderingUtils_1.default.toWebGLColor(options.color);
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = position;
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        const u_PointSize = gl.getUniformLocation(program, "u_PointSize");
        gl.uniform1f(u_PointSize, options.pointSize);
        gl.drawArrays(gl.POINTS, 0, 1);
    }
    getOptions(point) {
        let options = {
            position: point.position,
            color: point.color,
            pointSize: point.size,
        };
        return options;
    }
}
exports.default = PointShaderType;

},{"../../../Utils/RenderingUtils":97,"../ShaderType":71}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const ShaderType_1 = require("../ShaderType");
/** Represents any WebGL objects that have a quad mesh (i.e. a rectangular game object composed of only two triangles) */
class QuadShaderType extends ShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.scale = Mat4x4_1.default.IDENTITY;
        this.rotation = Mat4x4_1.default.IDENTITY;
        this.translation = Mat4x4_1.default.IDENTITY;
    }
}
exports.default = QuadShaderType;

},{"../../../DataTypes/Mat4x4":8,"../ShaderType":71}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
/** */
class RectShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "rect";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const color = options.color.toWebGL();
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /*
        So as it turns out, WebGL has an issue with non-square quads.
        It doesn't like when you don't have a 1-1 scale, and rotations are entirely messed up if this is not the case.
        To solve this, I used the scale of the LARGEST dimension of the quad to make a square, then adjusted the vertex coordinates inside of that.
        A diagram of the solution follows.

        There is a bounding square for the quad with dimensions hxh (in this case, since height is the largest dimension).
        The offset in the vertical direction is therefore 0.5, as it is normally.
        However, the offset in the horizontal direction is not so straightforward, but isn't conceptually hard.
        All we really have to do is a range change from [0, height/2] to [0, 0.5], where our value is t = width/2, and 0 <= t <= height/2.

        So now we have our rect, in a space scaled with respect to the largest dimension.
        Rotations work as you would expect, even for long rectangles.

                    0.5
            __ __ __ __ __ __ __
            |	|88888888888|	|
            |	|88888888888|	|
            |	|88888888888|	|
        -0.5|_ _|88888888888|_ _|0.5
            |	|88888888888|	|
            |	|88888888888|	|
            |	|88888888888|	|
            |___|88888888888|___|
                    -0.5

        The getVertices function below does as described, and converts the range
    */
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([
            -x, y,
            -x, -y,
            x, y,
            x, -y
        ]);
    }
    getOptions(rect) {
        let options = {
            position: rect.position,
            color: rect.color,
            size: rect.size,
            rotation: rect.rotation
        };
        return options;
    }
}
exports.default = RectShaderType;

},{"../../../DataTypes/Mat4x4":8,"../../../DataTypes/Vec2":18,"../../../ResourceManager/ResourceManager":77,"./QuadShaderType":74}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const AnimatedSprite_1 = require("../../../Nodes/Sprites/AnimatedSprite");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
/** A shader for sprites and animated sprites */
class SpriteShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "sprite";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        const texture = this.resourceManager.getTexture(options.imageKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y, options.scale);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 4 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        const a_TexCoord = gl.getAttribLocation(program, "a_TexCoord");
        gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, 4 * FSIZE, 2 * FSIZE);
        gl.enableVertexAttribArray(a_TexCoord);
        // Uniforms
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Set up our sampler with our assigned texture unit
        const u_Sampler = gl.getUniformLocation(program, "u_Sampler");
        gl.uniform1i(u_Sampler, texture);
        // Pass in texShift
        const u_texShift = gl.getUniformLocation(program, "u_texShift");
        gl.uniform2fv(u_texShift, options.texShift);
        // Pass in texScale
        const u_texScale = gl.getUniformLocation(program, "u_texScale");
        gl.uniform2fv(u_texScale, options.texScale);
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h, scale) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        // Scale the rendering space if needed
        x *= scale[0];
        y *= scale[1];
        return new Float32Array([
            -x, y, 0.0, 0.0,
            -x, -y, 0.0, 1.0,
            x, y, 1.0, 0.0,
            x, -y, 1.0, 1.0
        ]);
    }
    getOptions(sprite) {
        let texShift;
        let texScale;
        if (sprite instanceof AnimatedSprite_1.default) {
            let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
            let offset = sprite.getAnimationOffset(animationIndex);
            texShift = new Float32Array([offset.x / (sprite.cols * sprite.size.x), offset.y / (sprite.rows * sprite.size.y)]);
            texScale = new Float32Array([1 / (sprite.cols), 1 / (sprite.rows)]);
        }
        else {
            texShift = new Float32Array([0, 0]);
            texScale = new Float32Array([1, 1]);
        }
        let options = {
            position: sprite.position,
            rotation: sprite.rotation,
            size: sprite.size,
            scale: sprite.scale.toArray(),
            imageKey: sprite.imageId,
            texShift,
            texScale
        };
        return options;
    }
}
exports.default = SpriteShaderType;

},{"../../../DataTypes/Mat4x4":8,"../../../DataTypes/Vec2":18,"../../../Nodes/Sprites/AnimatedSprite":41,"../../../ResourceManager/ResourceManager":77,"./QuadShaderType":74}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const Queue_1 = require("../DataTypes/Queue");
const StringUtils_1 = require("../Utils/StringUtils");
const AudioManager_1 = require("../Sound/AudioManager");
const WebGLProgramType_1 = require("../DataTypes/Rendering/WebGLProgramType");
/**
 * The resource manager for the game engine.
 * The resource manager interfaces with the loadable assets of a game such as images, data files,
 * and sounds, which are all found in the dist folder.
 * This class controls loading and updates the @reference[Scene] with the loading progress, so that the scene does
 * not start before all necessary assets are loaded.
 */
class ResourceManager {
    constructor() {
        this.loading = false;
        this.justLoaded = false;
        this.loadonly_imagesLoaded = 0;
        this.loadonly_imagesToLoad = 0;
        this.loadonly_imageLoadingQueue = new Queue_1.default();
        this.images = new Map_1.default();
        this.loadonly_spritesheetsLoaded = 0;
        this.loadonly_spritesheetsToLoad = 0;
        this.loadonly_spritesheetLoadingQueue = new Queue_1.default();
        this.spritesheets = new Map_1.default();
        this.loadonly_tilemapsLoaded = 0;
        this.loadonly_tilemapsToLoad = 0;
        this.loadonly_tilemapLoadingQueue = new Queue_1.default();
        this.tilemaps = new Map_1.default();
        this.loadonly_audioLoaded = 0;
        this.loadonly_audioToLoad = 0;
        this.loadonly_audioLoadingQueue = new Queue_1.default();
        this.audioBuffers = new Map_1.default();
        this.loadonly_jsonLoaded = 0;
        this.loadonly_jsonToLoad = 0;
        this.loadonly_jsonLoadingQueue = new Queue_1.default();
        this.jsonObjects = new Map_1.default();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        this.loadonly_gl_ShaderProgramsToLoad = 0;
        this.loadonly_gl_ShaderLoadingQueue = new Queue_1.default();
        this.gl_ShaderPrograms = new Map_1.default();
        this.gl_Textures = new Map_1.default();
        this.gl_NextTextureID = 0;
        this.gl_Buffers = new Map_1.default();
        this.resourcesToUnload = new Array();
        this.resourcesToKeep = new Array();
    }
    ;
    /* ######################################## SINGLETON ########################################*/
    /**
     * Returns the current instance of this class or a new instance if none exist
     * @returns The resource manager
     */
    static getInstance() {
        if (!this.instance) {
            this.instance = new ResourceManager();
        }
        return this.instance;
    }
    /* ######################################## PUBLIC FUNCTION ########################################*/
    /**
     * Activates or deactivates the use of WebGL
     * @param flag True if WebGL should be used, false otherwise
     * @param gl The instance of the graphics context, if applicable
     */
    useWebGL(flag, gl) {
        this.gl_WebGLActive = flag;
        if (this.gl_WebGLActive) {
            this.gl = gl;
        }
    }
    /**
     * Loads an image from file
     * @param key The key to associate the loaded image with
     * @param path The path to the image to load
     */
    image(key, path) {
        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepImage(key) {
        this.keepResource(key, ResourceType.IMAGE);
    }
    /**
     * Retrieves a loaded image
     * @param key The key of the loaded image
     * @returns The image element associated with this key
     */
    getImage(key) {
        let image = this.images.get(key);
        if (image === undefined) {
            throw `There is no image associated with key "${key}"`;
        }
        return image;
    }
    /**
     * Loads a spritesheet from file
     * @param key The key to associate the loaded spritesheet with
     * @param path The path to the spritesheet to load
     */
    spritesheet(key, path) {
        this.loadonly_spritesheetLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepSpritesheet(key) {
        this.keepResource(key, ResourceType.SPRITESHEET);
    }
    /**
     * Retrieves a loaded spritesheet
     * @param key The key of the spritesheet to load
     * @returns The loaded Spritesheet
     */
    getSpritesheet(key) {
        return this.spritesheets.get(key);
    }
    /**
     * Loads an audio file
     * @param key The key to associate with the loaded audio file
     * @param path The path to the audio file to load
     */
    audio(key, path) {
        this.loadonly_audioLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepAudio(key) {
        this.keepResource(key, ResourceType.AUDIO);
    }
    /**
     * Retrieves a loaded audio file
     * @param key The key of the audio file to load
     * @returns The AudioBuffer created from the loaded audio fle
     */
    getAudio(key) {
        return this.audioBuffers.get(key);
    }
    /**
     * Load a tilemap from a json file. Automatically loads related images
     * @param key The key to associate with the loaded tilemap
     * @param path The path to the tilemap to load
     */
    tilemap(key, path) {
        this.loadonly_tilemapLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepTilemap(key) {
        this.keepResource(key, ResourceType.TILEMAP);
    }
    /**
     * Retreives a loaded tilemap
     * @param key The key of the loaded tilemap
     * @returns The tilemap data associated with the key
     */
    getTilemap(key) {
        return this.tilemaps.get(key);
    }
    /**
     * Loads an object from a json file.
     * @param key The key to associate with the loaded object
     * @param path The path to the json file to load
     */
    object(key, path) {
        this.loadonly_jsonLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepObject(key) {
        this.keepResource(key, ResourceType.JSON);
    }
    /**
     * Retreives a loaded object
     * @param key The key of the loaded object
     * @returns The object data associated with the key
     */
    getObject(key) {
        return this.jsonObjects.get(key);
    }
    /* ######################################## LOAD FUNCTION ########################################*/
    /**
     * Loads all resources currently in the queue
     * @param callback The function to cal when the resources are finished loading
     */
    loadResourcesFromQueue(callback) {
        this.loadonly_typesToLoad = 5;
        this.loading = true;
        // Load everything in the queues. Tilemaps have to come before images because they will add new images to the queue
        this.loadTilemapsFromQueue(() => {
            console.log("Loaded Tilemaps");
            this.loadSpritesheetsFromQueue(() => {
                console.log("Loaded Spritesheets");
                this.loadImagesFromQueue(() => {
                    console.log("Loaded Images");
                    this.loadAudioFromQueue(() => {
                        console.log("Loaded Audio");
                        this.loadObjectsFromQueue(() => {
                            console.log("Loaded Objects");
                            if (this.gl_WebGLActive) {
                                this.gl_LoadShadersFromQueue(() => {
                                    console.log("Loaded Shaders");
                                    this.finishLoading(callback);
                                });
                            }
                            else {
                                this.finishLoading(callback);
                            }
                        });
                    });
                });
            });
        });
    }
    finishLoading(callback) {
        // Done loading
        this.loading = false;
        this.justLoaded = true;
        callback();
    }
    /* ######################################## UNLOAD FUNCTION ########################################*/
    keepResource(key, type) {
        console.log("Keep resource...");
        for (let i = 0; i < this.resourcesToUnload.length; i++) {
            let resource = this.resourcesToUnload[i];
            if (resource.key === key && resource.resourceType === type) {
                console.log("Found resource " + key + " of type " + type + ". Keeping.");
                let resourceToMove = this.resourcesToUnload.splice(i, 1);
                this.resourcesToKeep.push(...resourceToMove);
                return;
            }
        }
    }
    /**
     * Deletes references to all resources in the resource manager
     */
    unloadAllResources() {
        this.loading = false;
        this.justLoaded = false;
        for (let resource of this.resourcesToUnload) {
            // Unload the resource
            this.unloadResource(resource);
        }
    }
    unloadResource(resource) {
        // Delete the resource itself
        switch (resource.resourceType) {
            case ResourceType.IMAGE:
                this.images.delete(resource.key);
                if (this.gl_WebGLActive) {
                    this.gl_Textures.delete(resource.key);
                }
                break;
            case ResourceType.TILEMAP:
                this.tilemaps.delete(resource.key);
                break;
            case ResourceType.SPRITESHEET:
                this.spritesheets.delete(resource.key);
                break;
            case ResourceType.AUDIO:
                this.audioBuffers.delete(resource.key);
                break;
            case ResourceType.JSON:
                this.jsonObjects.delete(resource.key);
                break;
            /*case ResourceType.SHADER:
                this.gl_ShaderPrograms.get(resource.key).delete(this.gl);
                this.gl_ShaderPrograms.delete(resource.key);
                break;*/
        }
        // Delete any dependencies
        for (let dependency of resource.dependencies) {
            this.unloadResource(dependency);
        }
    }
    /* ######################################## WORK FUNCTIONS ########################################*/
    /**
     * Loads all tilemaps currently in the tilemap loading queue
     * @param onFinishLoading The function to call when loading is complete
     */
    loadTilemapsFromQueue(onFinishLoading) {
        this.loadonly_tilemapsToLoad = this.loadonly_tilemapLoadingQueue.getSize();
        this.loadonly_tilemapsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_tilemapsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_tilemapLoadingQueue.hasItems()) {
            let tilemap = this.loadonly_tilemapLoadingQueue.dequeue();
            this.loadTilemap(tilemap.key, tilemap.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular tilemap
     * @param key The key of the tilemap
     * @param pathToTilemapJSON The path to the tilemap JSON file
     * @param callbackIfLast The function to call if this is the last tilemap to load
     */
    loadTilemap(key, pathToTilemapJSON, callbackIfLast) {
        this.loadTextFile(pathToTilemapJSON, (fileText) => {
            let tilemapObject = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            this.tilemaps.add(key, tilemapObject);
            let resource = new ResourceReference(key, ResourceType.TILEMAP);
            // Grab the tileset images we need to load and add them to the imageloading queue
            for (let tileset of tilemapObject.tilesets) {
                if (tileset.image) {
                    let key = tileset.image;
                    let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                    this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path, isDependency: true });
                    // Add this image as a dependency to the tilemap
                    resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                }
                else if (tileset.tiles) {
                    for (let tile of tileset.tiles) {
                        let key = tile.image;
                        let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path, isDependency: true });
                        // Add this image as a dependency to the tilemap
                        resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                    }
                }
            }
            // Add the resource reference to the list of resource to unload
            this.resourcesToUnload.push(resource);
            // Finish loading
            this.finishLoadingTilemap(callbackIfLast);
        });
    }
    /**
     * Finish loading a tilemap. Calls the callback function if this is the last tilemap being loaded
     * @param callback The function to call if this is the last tilemap to load
     */
    finishLoadingTilemap(callback) {
        this.loadonly_tilemapsLoaded += 1;
        if (this.loadonly_tilemapsLoaded === this.loadonly_tilemapsToLoad) {
            // We're done loading tilemaps
            callback();
        }
    }
    /**
     * Loads all spritesheets currently in the spritesheet loading queue
     * @param onFinishLoading The function to call when the spritesheets are done loading
     */
    loadSpritesheetsFromQueue(onFinishLoading) {
        this.loadonly_spritesheetsToLoad = this.loadonly_spritesheetLoadingQueue.getSize();
        this.loadonly_spritesheetsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_spritesheetsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_spritesheetLoadingQueue.hasItems()) {
            let spritesheet = this.loadonly_spritesheetLoadingQueue.dequeue();
            this.loadSpritesheet(spritesheet.key, spritesheet.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular spritesheet
     * @param key The key of the spritesheet to load
     * @param pathToSpritesheetJSON The path to the spritesheet JSON file
     * @param callbackIfLast The function to call if this is the last spritesheet
     */
    loadSpritesheet(key, pathToSpritesheetJSON, callbackIfLast) {
        this.loadTextFile(pathToSpritesheetJSON, (fileText) => {
            let spritesheet = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            this.spritesheets.add(key, spritesheet);
            let resource = new ResourceReference(key, ResourceType.SPRITESHEET);
            // Grab the image we need to load and add it to the imageloading queue
            let path = StringUtils_1.default.getPathFromFilePath(pathToSpritesheetJSON) + spritesheet.spriteSheetImage;
            this.loadonly_imageLoadingQueue.enqueue({ key: spritesheet.name, path: path, isDependency: true });
            resource.addDependency(new ResourceReference(spritesheet.name, ResourceType.IMAGE));
            this.resourcesToUnload.push(resource);
            // Finish loading
            this.finishLoadingSpritesheet(callbackIfLast);
        });
    }
    /**
     * Finish loading a spritesheet. Calls the callback function if this is the last spritesheet being loaded
     * @param callback The function to call if this is the last spritesheet to load
     */
    finishLoadingSpritesheet(callback) {
        this.loadonly_spritesheetsLoaded += 1;
        if (this.loadonly_spritesheetsLoaded === this.loadonly_spritesheetsToLoad) {
            // We're done loading spritesheets
            callback();
        }
    }
    /**
     * Loads all images currently in the image loading queue
     * @param onFinishLoading The function to call when there are no more images to load
     */
    loadImagesFromQueue(onFinishLoading) {
        this.loadonly_imagesToLoad = this.loadonly_imageLoadingQueue.getSize();
        this.loadonly_imagesLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_imagesToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_imageLoadingQueue.hasItems()) {
            let image = this.loadonly_imageLoadingQueue.dequeue();
            this.loadImage(image.key, image.path, image.isDependency, onFinishLoading);
        }
    }
    /**
     * Loads a singular image
     * @param key The key of the image to load
     * @param path The path to the image to load
     * @param callbackIfLast The function to call if this is the last image
     */
    loadImage(key, path, isDependency, callbackIfLast) {
        var image = new Image();
        image.onload = () => {
            // Add to loaded images
            this.images.add(key, image);
            // If not a dependency, push it to the unload list. Otherwise it's managed by something else
            if (!isDependency) {
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.IMAGE));
            }
            // If WebGL is active, create a texture
            if (this.gl_WebGLActive) {
                this.createWebGLTexture(key, image);
            }
            // Finish image load
            this.finishLoadingImage(callbackIfLast);
        };
        image.src = path;
    }
    /**
     * Finish loading an image. If this is the last image, it calls the callback function
     * @param callback The function to call if this is the last image
     */
    finishLoadingImage(callback) {
        this.loadonly_imagesLoaded += 1;
        if (this.loadonly_imagesLoaded === this.loadonly_imagesToLoad) {
            // We're done loading images
            callback();
        }
    }
    /**
     * Loads all audio currently in the tilemap loading queue
     * @param onFinishLoading The function to call when tilemaps are done loading
     */
    loadAudioFromQueue(onFinishLoading) {
        this.loadonly_audioToLoad = this.loadonly_audioLoadingQueue.getSize();
        this.loadonly_audioLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_audioToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_audioLoadingQueue.hasItems()) {
            let audio = this.loadonly_audioLoadingQueue.dequeue();
            this.loadAudio(audio.key, audio.path, onFinishLoading);
        }
    }
    /**
     * Load a singular audio file
     * @param key The key to the audio file to load
     * @param path The path to the audio file to load
     * @param callbackIfLast The function to call if this is the last audio file to load
     */
    loadAudio(key, path, callbackIfLast) {
        let audioCtx = AudioManager_1.default.getInstance().getAudioContext();
        let request = new XMLHttpRequest();
        request.open('GET', path, true);
        request.responseType = 'arraybuffer';
        request.onload = () => {
            audioCtx.decodeAudioData(request.response, (buffer) => {
                // Add to list of audio buffers
                this.audioBuffers.add(key, buffer);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.AUDIO));
                // Finish loading sound
                this.finishLoadingAudio(callbackIfLast);
            }, (error) => {
                throw "Error loading sound";
            });
        };
        request.send();
    }
    /**
     * Finish loading an audio file. Calls the callback functon if this is the last audio sample being loaded.
     * @param callback The function to call if this is the last audio file to load
     */
    finishLoadingAudio(callback) {
        this.loadonly_audioLoaded += 1;
        if (this.loadonly_audioLoaded === this.loadonly_audioToLoad) {
            // We're done loading audio
            callback();
        }
    }
    /**
     * Loads all objects currently in the object loading queue
     * @param onFinishLoading The function to call when there are no more objects to load
     */
    loadObjectsFromQueue(onFinishLoading) {
        this.loadonly_jsonToLoad = this.loadonly_jsonLoadingQueue.getSize();
        this.loadonly_jsonLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_jsonToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_jsonLoadingQueue.hasItems()) {
            let obj = this.loadonly_jsonLoadingQueue.dequeue();
            this.loadObject(obj.key, obj.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular object
     * @param key The key of the object to load
     * @param path The path to the object to load
     * @param callbackIfLast The function to call if this is the last object
     */
    loadObject(key, path, callbackIfLast) {
        this.loadTextFile(path, (fileText) => {
            let obj = JSON.parse(fileText);
            this.jsonObjects.add(key, obj);
            this.resourcesToUnload.push(new ResourceReference(key, ResourceType.JSON));
            this.finishLoadingObject(callbackIfLast);
        });
    }
    /**
     * Finish loading an object. If this is the last object, it calls the callback function
     * @param callback The function to call if this is the last object
     */
    finishLoadingObject(callback) {
        this.loadonly_jsonLoaded += 1;
        if (this.loadonly_jsonLoaded === this.loadonly_jsonToLoad) {
            // We're done loading objects
            callback();
        }
    }
    /* ########## WEBGL SPECIFIC FUNCTIONS ########## */
    getTexture(key) {
        return this.gl_Textures.get(key);
    }
    getShaderProgram(key) {
        return this.gl_ShaderPrograms.get(key).program;
    }
    getBuffer(key) {
        return this.gl_Buffers.get(key);
    }
    createWebGLTexture(imageKey, image) {
        // Get the texture ID
        const textureID = this.getTextureID(this.gl_NextTextureID);
        // Create the texture
        const texture = this.gl.createTexture();
        // Set up the texture
        // Enable texture0
        this.gl.activeTexture(textureID);
        // Bind our texture to texture 0
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        // Set the texture parameters
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        // Set the texture image
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
        // Add the texture to our map with the same key as the image
        this.gl_Textures.add(imageKey, this.gl_NextTextureID);
        // Increment the key
        this.gl_NextTextureID += 1;
    }
    getTextureID(id) {
        // Start with 9 cases - this can be expanded if needed, but for the best performance,
        // Textures should be stitched into an atlas
        switch (id) {
            case 0: return this.gl.TEXTURE0;
            case 1: return this.gl.TEXTURE1;
            case 2: return this.gl.TEXTURE2;
            case 3: return this.gl.TEXTURE3;
            case 4: return this.gl.TEXTURE4;
            case 5: return this.gl.TEXTURE5;
            case 6: return this.gl.TEXTURE6;
            case 7: return this.gl.TEXTURE7;
            case 8: return this.gl.TEXTURE8;
            default: return this.gl.TEXTURE9;
        }
    }
    createBuffer(key) {
        if (this.gl_WebGLActive) {
            let buffer = this.gl.createBuffer();
            this.gl_Buffers.add(key, buffer);
        }
    }
    /**
     * Enqueues loading of a new shader program
     * @param key The key of the shader program
     * @param vShaderFilepath
     * @param fShaderFilepath
     */
    shader(key, vShaderFilepath, fShaderFilepath) {
        let splitPath = vShaderFilepath.split(".");
        let end = splitPath[splitPath.length - 1];
        if (end !== "vshader") {
            throw `${vShaderFilepath} is not a valid vertex shader - must end in ".vshader`;
        }
        splitPath = fShaderFilepath.split(".");
        end = splitPath[splitPath.length - 1];
        if (end !== "fshader") {
            throw `${fShaderFilepath} is not a valid vertex shader - must end in ".fshader`;
        }
        let paths = new KeyPath_Shader();
        paths.key = key;
        paths.vpath = vShaderFilepath;
        paths.fpath = fShaderFilepath;
        this.loadonly_gl_ShaderLoadingQueue.enqueue(paths);
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepShader(key) {
        this.keepResource(key, ResourceType.IMAGE);
    }
    gl_LoadShadersFromQueue(onFinishLoading) {
        this.loadonly_gl_ShaderProgramsToLoad = this.loadonly_gl_ShaderLoadingQueue.getSize();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        // If webGL isn'active or there are no items to load, we're finished
        if (!this.gl_WebGLActive || this.loadonly_gl_ShaderProgramsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_gl_ShaderLoadingQueue.hasItems()) {
            let shader = this.loadonly_gl_ShaderLoadingQueue.dequeue();
            this.gl_LoadShader(shader.key, shader.vpath, shader.fpath, onFinishLoading);
        }
    }
    gl_LoadShader(key, vpath, fpath, callbackIfLast) {
        this.loadTextFile(vpath, (vFileText) => {
            const vShader = vFileText;
            this.loadTextFile(fpath, (fFileText) => {
                const fShader = fFileText;
                // Extract the program and shaders
                const [shaderProgram, vertexShader, fragmentShader] = this.createShaderProgram(vShader, fShader);
                // Create a wrapper type
                const programWrapper = new WebGLProgramType_1.default();
                programWrapper.program = shaderProgram;
                programWrapper.vertexShader = vertexShader;
                programWrapper.fragmentShader = fragmentShader;
                // Add to our map
                this.gl_ShaderPrograms.add(key, programWrapper);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.SHADER));
                // Finish loading
                this.gl_FinishLoadingShader(callbackIfLast);
            });
        });
    }
    gl_FinishLoadingShader(callback) {
        this.loadonly_gl_ShaderProgramsLoaded += 1;
        if (this.loadonly_gl_ShaderProgramsLoaded === this.loadonly_gl_ShaderProgramsToLoad) {
            // We're done loading shaders
            callback();
        }
    }
    createShaderProgram(vShaderSource, fShaderSource) {
        const vertexShader = this.loadVertexShader(vShaderSource);
        const fragmentShader = this.loadFragmentShader(fShaderSource);
        if (vertexShader === null || fragmentShader === null) {
            // We had a problem intializing - error
            return null;
        }
        // Create a shader program
        const program = this.gl.createProgram();
        if (!program) {
            // Error creating
            console.warn("Failed to create program");
            return null;
        }
        // Attach our vertex and fragment shader
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        // Link
        this.gl.linkProgram(program);
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            // Error linking
            const error = this.gl.getProgramInfoLog(program);
            console.warn("Failed to link program: " + error);
            // Clean up
            this.gl.deleteProgram(program);
            this.gl.deleteShader(vertexShader);
            this.gl.deleteShader(fragmentShader);
            return null;
        }
        // We successfully create a program
        return [program, vertexShader, fragmentShader];
    }
    loadVertexShader(shaderSource) {
        // Create a new vertex shader
        return this.loadShader(this.gl.VERTEX_SHADER, shaderSource);
    }
    loadFragmentShader(shaderSource) {
        // Create a new fragment shader
        return this.loadShader(this.gl.FRAGMENT_SHADER, shaderSource);
    }
    loadShader(type, shaderSource) {
        const shader = this.gl.createShader(type);
        // If we couldn't create the shader, error
        if (shader === null) {
            console.warn("Unable to create shader");
            return null;
        }
        // Add the source to the shader and compile
        this.gl.shaderSource(shader, shaderSource);
        this.gl.compileShader(shader);
        // Make sure there were no errors during this process
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            // Not compiled - error
            const error = this.gl.getShaderInfoLog(shader);
            console.warn("Failed to compile shader: " + error);
            // Clean up
            this.gl.deleteShader(shader);
            return null;
        }
        // Sucess, so return the shader
        return shader;
    }
    /* ########## GENERAL LOADING FUNCTIONS ########## */
    loadTextFile(textFilePath, callback) {
        let xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', textFilePath, true);
        xobj.onreadystatechange = function () {
            if ((xobj.readyState == 4) && (xobj.status == 200)) {
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }
    /* ########## LOADING BAR INFO ########## */
    getLoadPercent() {
        return (this.loadonly_tilemapsLoaded / this.loadonly_tilemapsToLoad
            + this.loadonly_spritesheetsLoaded / this.loadonly_spritesheetsToLoad
            + this.loadonly_imagesLoaded / this.loadonly_imagesToLoad
            + this.loadonly_audioLoaded / this.loadonly_audioToLoad)
            / this.loadonly_typesToLoad;
    }
    update(deltaT) {
        if (this.loading) {
            if (this.onLoadProgress) {
                this.onLoadProgress(this.getLoadPercent());
            }
        }
        else if (this.justLoaded) {
            this.justLoaded = false;
            if (this.onLoadComplete) {
                this.onLoadComplete();
            }
        }
    }
}
exports.default = ResourceManager;
/**
 * A class representing a reference to a resource.
 * This is used for the exemption list to assure assets and their dependencies don't get
 * destroyed if they are still needed.
 */
class ResourceReference {
    constructor(key, resourceType) {
        this.key = key;
        this.resourceType = resourceType;
        this.dependencies = new Array();
    }
    addDependency(resource) {
        this.dependencies.push(resource);
    }
}
var ResourceType;
(function (ResourceType) {
    ResourceType["IMAGE"] = "IMAGE";
    ResourceType["TILEMAP"] = "TILEMAP";
    ResourceType["SPRITESHEET"] = "SPRITESHEET";
    ResourceType["AUDIO"] = "AUDIO";
    ResourceType["JSON"] = "JSON";
    ResourceType["SHADER"] = "SHADER";
})(ResourceType || (ResourceType = {}));
/**
 * A pair representing a key and the path of the resource to load
 */
class KeyPathPair {
    constructor() {
        this.isDependency = false;
    }
}
class KeyPath_Shader {
}

},{"../DataTypes/Map":7,"../DataTypes/Queue":11,"../DataTypes/Rendering/WebGLProgramType":12,"../Sound/AudioManager":90,"../Utils/StringUtils":98}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = require("../../Nodes/Sprites/Sprite");
const AnimatedSprite_1 = require("../../Nodes/Sprites/AnimatedSprite");
const GraphicTypes_1 = require("../../Nodes/Graphics/GraphicTypes");
const UIElementTypes_1 = require("../../Nodes/UIElements/UIElementTypes");
const Point_1 = require("../../Nodes/Graphics/Point");
const Vec2_1 = require("../../DataTypes/Vec2");
const Button_1 = require("../../Nodes/UIElements/Button");
const Label_1 = require("../../Nodes/UIElements/Label");
const Slider_1 = require("../../Nodes/UIElements/Slider");
const TextInput_1 = require("../../Nodes/UIElements/TextInput");
const Rect_1 = require("../../Nodes/Graphics/Rect");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Line_1 = require("../../Nodes/Graphics/Line");
const Particle_1 = require("../../Nodes/Graphics/Particle");
// @ignorePage
/**
 * A factory that abstracts adding @reference[CanvasNode]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
class CanvasNodeFactory {
    constructor() {
        /**
         * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
         * @param type The type of UIElement to add
         * @param layerName The layer to add the UIElement to
         * @param options Any additional arguments to feed to the constructor
         * @returns A new UIElement
         */
        this.addUIElement = (type, layerName, options) => {
            // Get the layer
            let layer = this.scene.getLayer(layerName);
            let instance;
            switch (type) {
                case UIElementTypes_1.UIElementType.BUTTON:
                    instance = this.buildButton(options);
                    break;
                case UIElementTypes_1.UIElementType.LABEL:
                    instance = this.buildLabel(options);
                    break;
                case UIElementTypes_1.UIElementType.SLIDER:
                    instance = this.buildSlider(options);
                    break;
                case UIElementTypes_1.UIElementType.TEXT_INPUT:
                    instance = this.buildTextInput(options);
                    break;
                default:
                    throw `UIElementType '${type}' does not exist, or is registered incorrectly.`;
            }
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            this.scene.getSceneGraph().addNode(instance);
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a sprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new Sprite
         */
        this.addSprite = (key, layerName) => {
            let layer = this.scene.getLayer(layerName);
            let instance = new Sprite_1.default(key);
            // Add instance to scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds an AnimatedSprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new AnimatedSprite
         */
        this.addAnimatedSprite = (key, layerName) => {
            let layer = this.scene.getLayer(layerName);
            let spritesheet = this.resourceManager.getSpritesheet(key);
            let instance = new AnimatedSprite_1.default(spritesheet);
            // Add instance fo scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a new graphic element to the current Scene
         * @param type The type of graphic to add
         * @param layerName The layer on which to add the graphic
         * @param options Any additional arguments to send to the graphic constructor
         * @returns A new Graphic
         */
        this.addGraphic = (type, layerName, options) => {
            // Get the layer
            let layer = this.scene.getLayer(layerName);
            let instance;
            switch (type) {
                case GraphicTypes_1.GraphicType.POINT:
                    instance = this.buildPoint(options);
                    break;
                case GraphicTypes_1.GraphicType.LINE:
                    instance = this.buildLine(options);
                    break;
                case GraphicTypes_1.GraphicType.RECT:
                    instance = this.buildRect(options);
                    break;
                case GraphicTypes_1.GraphicType.PARTICLE:
                    instance = this.buildParticle(options);
                    break;
                default:
                    throw `GraphicType '${type}' does not exist, or is registered incorrectly.`;
            }
            // Add instance to scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
    }
    init(scene) {
        this.scene = scene;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /* ---------- BUILDERS ---------- */
    buildButton(options) {
        this.checkIfPropExists("Button", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Button", options, "text", "string");
        return new Button_1.default(options.position, options.text);
    }
    buildLabel(options) {
        this.checkIfPropExists("Label", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Label", options, "text", "string");
        return new Label_1.default(options.position, options.text);
    }
    buildSlider(options) {
        this.checkIfPropExists("Slider", options, "position", Vec2_1.default, "Vec2");
        let initValue = 0;
        if (options.value !== undefined) {
            initValue = options.value;
        }
        return new Slider_1.default(options.position, initValue);
    }
    buildTextInput(options) {
        this.checkIfPropExists("TextInput", options, "position", Vec2_1.default, "Vec2");
        return new TextInput_1.default(options.position);
    }
    buildPoint(options) {
        this.checkIfPropExists("Point", options, "position", Vec2_1.default, "Vec2");
        return new Point_1.default(options.position);
    }
    buildParticle(options) {
        this.checkIfPropExists("Particle", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Particle", options, "size", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Particle", options, "mass", "number", "number");
        //Changed for testing
        return new Particle_1.default(options.position, options.size, options.mass);
    }
    buildLine(options) {
        this.checkIfPropExists("Line", options, "start", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Line", options, "end", Vec2_1.default, "Vec2");
        return new Line_1.default(options.start, options.end);
    }
    buildRect(options) {
        this.checkIfPropExists("Rect", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Rect", options, "size", Vec2_1.default, "Vec2");
        return new Rect_1.default(options.position, options.size);
    }
    /* ---------- ERROR HANDLING ---------- */
    checkIfPropExists(objectName, options, prop, type, typeName) {
        if (!options || options[prop] === undefined) {
            // Check that the options object has the property
            throw `${objectName} object requires argument ${prop} of type ${typeName}, but none was provided.`;
        }
        else {
            // Check that the property has the correct type
            if ((typeof type) === "string") {
                if (!(typeof options[prop] === type)) {
                    throw `${objectName} object requires argument ${prop} of type ${type}, but provided ${prop} was not of type ${type}.`;
                }
            }
            else if (type instanceof Function) {
                // If type is a constructor, check against that
                if (!(options[prop] instanceof type)) {
                    throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
                }
            }
            else {
                throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
            }
        }
    }
}
exports.default = CanvasNodeFactory;

},{"../../DataTypes/Vec2":18,"../../Nodes/Graphics/GraphicTypes":36,"../../Nodes/Graphics/Line":37,"../../Nodes/Graphics/Particle":38,"../../Nodes/Graphics/Point":39,"../../Nodes/Graphics/Rect":40,"../../Nodes/Sprites/AnimatedSprite":41,"../../Nodes/Sprites/Sprite":42,"../../Nodes/UIElements/Button":46,"../../Nodes/UIElements/Label":47,"../../Nodes/UIElements/Slider":48,"../../Nodes/UIElements/TextInput":49,"../../Nodes/UIElements/UIElementTypes":50,"../../ResourceManager/ResourceManager":77}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNodeFactory_1 = require("./CanvasNodeFactory");
const TilemapFactory_1 = require("./TilemapFactory");
/**
 * The manager of all factories used for adding @reference[GameNode]s to the @reference[Scene].
 */
class FactoryManager {
    constructor(scene, tilemaps) {
        // Constructors are called here to allow assignment of their functions to functions in this class
        this.canvasNodeFactory = new CanvasNodeFactory_1.default();
        this.tilemapFactory = new TilemapFactory_1.default();
        this.canvasNodeFactory.init(scene);
        this.tilemapFactory.init(scene, tilemaps);
    }
    // Expose all of the factories through the factory manager
    /**
     * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
     * @param type The type of UIElement to add
     * @param layerName The layer to add the UIElement to
     * @param options Any additional arguments to feed to the constructor
     * @returns A new UIElement
     */
    uiElement(type, layerName, options) {
        return this.canvasNodeFactory.addUIElement(type, layerName, options);
    }
    /**
     * Adds a sprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new Sprite
     */
    sprite(key, layerName) {
        return this.canvasNodeFactory.addSprite(key, layerName);
    }
    /**
     * Adds an AnimatedSprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new AnimatedSprite
     */
    animatedSprite(key, layerName) {
        return this.canvasNodeFactory.addAnimatedSprite(key, layerName);
    }
    /**
     * Adds a new graphic element to the current Scene
     * @param type The type of graphic to add
     * @param layerName The layer on which to add the graphic
     * @param options Any additional arguments to send to the graphic constructor
     * @returns A new Graphic
     */
    graphic(type, layerName, options) {
        return this.canvasNodeFactory.addGraphic(type, layerName, options);
    }
    /**
     * Adds a tilemap to the scene
     * @param key The key of the loaded tilemap to load
     * @param constr The constructor of the desired tilemap
     * @param args Additional arguments to send to the tilemap constructor
     * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
     */
    tilemap(key, scale) {
        return this.tilemapFactory.add(key, scale);
    }
}
exports.default = FactoryManager;

},{"./CanvasNodeFactory":78,"./TilemapFactory":80}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const OrthogonalTilemap_1 = require("../../Nodes/Tilemaps/OrthogonalTilemap");
const Tileset_1 = require("../../DataTypes/Tilesets/Tileset");
const Vec2_1 = require("../../DataTypes/Vec2");
const PositionGraph_1 = require("../../DataTypes/Graphs/PositionGraph");
const Navmesh_1 = require("../../Pathfinding/Navmesh");
// @ignorePage
/**
 * A factory that abstracts adding @reference[Tilemap]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
class TilemapFactory {
    constructor() {
        // TODO - This is specifically catered to Tiled tilemaps right now. In the future,
        // it would be good to have a "parseTilemap" function that would convert the tilemap
        // data into a standard format. This could allow for support from other programs
        // or the development of an internal level builder tool
        /**
         * Adds a tilemap to the scene
         * @param key The key of the loaded tilemap to load
         * @param constr The constructor of the desired tilemap
         * @param args Additional arguments to send to the tilemap constructor
         * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
         */
        this.add = (key, scale = new Vec2_1.default(1, 1)) => {
            // Get Tilemap Data
            let tilemapData = this.resourceManager.getTilemap(key);
            console.log(tilemapData);
            // Set the constructor for this tilemap to either be orthographic or isometric
            let constr;
            if (tilemapData.orientation === "orthographic") {
                constr = OrthogonalTilemap_1.default;
            }
            else {
                // No isometric tilemap support right now, so Orthographic tilemap
                constr = OrthogonalTilemap_1.default;
            }
            // Initialize the return value array
            let sceneLayers = new Array();
            // Create all of the tilesets for this tilemap
            let tilesets = new Array();
            let collectionTiles = new Array();
            for (let tileset of tilemapData.tilesets) {
                if (tileset.image) {
                    // If this is a standard tileset and not a collection, create a tileset for it.
                    // TODO - We are ignoring collection tilesets for now. This is likely not a great idea in practice,
                    // as theoretically someone could want to use one for a standard tilemap. We are assuming for now
                    // that we only want to use them for object layers
                    tilesets.push(new Tileset_1.default(tileset));
                }
                else {
                    tileset.tiles.forEach(tile => tile.id += tileset.firstgid);
                    collectionTiles.push(...tileset.tiles);
                }
            }
            // Loop over the layers of the tilemap and create tiledlayers or object layers
            for (let layer of tilemapData.layers) {
                let sceneLayer;
                let isParallaxLayer = false;
                let depth = 0;
                if (layer.properties) {
                    for (let prop of layer.properties) {
                        if (prop.name === "Parallax") {
                            isParallaxLayer = prop.value;
                        }
                        else if (prop.name === "Depth") {
                            depth = prop.value;
                        }
                    }
                }
                if (isParallaxLayer) {
                    sceneLayer = this.scene.addParallaxLayer(layer.name, new Vec2_1.default(1, 1), depth);
                }
                else {
                    sceneLayer = this.scene.addLayer(layer.name, depth);
                }
                if (layer.type === "tilelayer") {
                    // Create a new tilemap object for the layer
                    let tilemap = new constr(tilemapData, layer, tilesets, scale);
                    tilemap.id = this.scene.generateId();
                    tilemap.setScene(this.scene);
                    // Add tilemap to scene
                    this.tilemaps.push(tilemap);
                    sceneLayer.addNode(tilemap);
                    // Register tilemap with physics if it's collidable
                    if (tilemap.isCollidable) {
                        tilemap.addPhysics();
                        if (layer.properties) {
                            for (let item of layer.properties) {
                                if (item.name === "Group") {
                                    tilemap.setGroup(item.value);
                                }
                            }
                        }
                    }
                }
                else {
                    let isNavmeshPoints = false;
                    let navmeshName;
                    let edges;
                    if (layer.properties) {
                        for (let prop of layer.properties) {
                            if (prop.name === "NavmeshPoints") {
                                isNavmeshPoints = true;
                            }
                            else if (prop.name === "name") {
                                navmeshName = prop.value;
                            }
                            else if (prop.name === "edges") {
                                edges = prop.value;
                            }
                        }
                    }
                    if (isNavmeshPoints) {
                        let g = new PositionGraph_1.default();
                        for (let obj of layer.objects) {
                            g.addPositionedNode(new Vec2_1.default(obj.x, obj.y));
                        }
                        for (let edge of edges) {
                            g.addEdge(edge.from, edge.to);
                        }
                        this.scene.getNavigationManager().addNavigableEntity(navmeshName, new Navmesh_1.default(g));
                        continue;
                    }
                    // Layer is an object layer, so add each object as a sprite to a new layer
                    for (let obj of layer.objects) {
                        // Check if obj is collidable
                        let hasPhysics = false;
                        let isCollidable = false;
                        let isTrigger = false;
                        let onEnter = null;
                        let onExit = null;
                        let triggerGroup = null;
                        let group = "";
                        if (obj.properties) {
                            for (let prop of obj.properties) {
                                if (prop.name === "HasPhysics") {
                                    hasPhysics = prop.value;
                                }
                                else if (prop.name === "Collidable") {
                                    isCollidable = prop.value;
                                }
                                else if (prop.name === "Group") {
                                    group = prop.value;
                                }
                                else if (prop.name === "IsTrigger") {
                                    isTrigger = prop.value;
                                }
                                else if (prop.name === "TriggerGroup") {
                                    triggerGroup = prop.value;
                                }
                                else if (prop.name === "TriggerOnEnter") {
                                    onEnter = prop.value;
                                }
                                else if (prop.name === "TriggerOnExit") {
                                    onExit = prop.value;
                                }
                            }
                        }
                        let sprite;
                        // Check if obj is a tile from a tileset
                        for (let tileset of tilesets) {
                            if (tileset.hasTile(obj.gid)) {
                                // The object is a tile from this set
                                let imageKey = tileset.getImageKey();
                                let offset = tileset.getImageOffsetForTile(obj.gid);
                                sprite = this.scene.add.sprite(imageKey, layer.name);
                                let size = tileset.getTileSize().clone();
                                sprite.position.set((obj.x + size.x / 2) * scale.x, (obj.y - size.y / 2) * scale.y);
                                sprite.setImageOffset(offset);
                                sprite.size.copy(size);
                                sprite.scale.set(scale.x, scale.y);
                            }
                        }
                        // Not in a tileset, must correspond to a collection
                        if (!sprite) {
                            for (let tile of collectionTiles) {
                                if (obj.gid === tile.id) {
                                    let imageKey = tile.image;
                                    sprite = this.scene.add.sprite(imageKey, layer.name);
                                    sprite.position.set((obj.x + tile.imagewidth / 2) * scale.x, (obj.y - tile.imageheight / 2) * scale.y);
                                    sprite.scale.set(scale.x, scale.y);
                                }
                            }
                        }
                        // Now we have sprite. Associate it with our physics object if there is one
                        if (hasPhysics) {
                            // Make the sprite a static physics object
                            sprite.addPhysics(sprite.boundary.clone(), Vec2_1.default.ZERO, isCollidable, true);
                            sprite.setGroup(group);
                            if (isTrigger && triggerGroup !== null) {
                                sprite.setTrigger(triggerGroup, onEnter, onExit);
                            }
                        }
                    }
                }
                // Update the return value
                sceneLayers.push(sceneLayer);
            }
            return sceneLayers;
        };
    }
    init(scene, tilemaps) {
        this.scene = scene;
        this.tilemaps = tilemaps;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
}
exports.default = TilemapFactory;

},{"../../DataTypes/Graphs/PositionGraph":5,"../../DataTypes/Tilesets/Tileset":17,"../../DataTypes/Vec2":18,"../../Nodes/Tilemaps/OrthogonalTilemap":44,"../../Pathfinding/Navmesh":53,"../../ResourceManager/ResourceManager":77}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("../Utils/MathUtils");
/**
 * A layer in the scene. Layers are used for sorting @reference[GameNode]s by depth.
 */
class Layer {
    /**
     * Creates a new layer. To do this in a game, use the addLayer() method in @refrence[Scene]
     * @param scene The scene to add the layer to
     * @param name The name of the layer
     */
    constructor(scene, name) {
        this.scene = scene;
        this.name = name;
        this.paused = false;
        this.hidden = false;
        this.alpha = 1;
        this.items = new Array();
        this.ySort = false;
        this.depth = 0;
    }
    /**
     * Retreives the name of the layer
     * @returns The name of the layer
     */
    getName() {
        return this.name;
    }
    /**
     * Pauses/Unpauses the layer. Affects all elements in this layer
     * @param pauseValue True if the layer should be paused, false if not
     */
    setPaused(pauseValue) {
        this.paused = pauseValue;
    }
    /**
     * Returns whether or not the layer is paused
     */
    isPaused() {
        return this.paused;
    }
    /**
     * Sets the opacity of the layer
     * @param alpha The new opacity value in the range [0, 1]
     */
    setAlpha(alpha) {
        this.alpha = MathUtils_1.default.clamp(alpha, 0, 1);
    }
    /**
     * Gets the opacity of the layer
     * @returns The opacity
     */
    getAlpha() {
        return this.alpha;
    }
    /**
     * Sets the layer's hidden value. If hidden, a layer will not be rendered, but will still update
     * @param hidden The hidden value of the layer
     */
    setHidden(hidden) {
        this.hidden = hidden;
    }
    /**
     * Returns the hideen value of the lyaer
     * @returns True if the scene is hidden, false otherwise
     */
    isHidden() {
        return this.hidden;
    }
    /** Pauses this scene and hides it */
    disable() {
        this.paused = true;
        this.hidden = true;
    }
    /** Unpauses this layer and makes it visible */
    enable() {
        this.paused = false;
        this.hidden = false;
    }
    /**
     * Sets whether or not the scene will ySort automatically.
     * ySorting means that CanvasNodes on this layer will have their depth sorted depending on their y-value.
     * This means that if an object is "higher" in the scene, it will sort behind objects that are "lower".
     * This is useful for 3/4 view games, or similar situations, where you sometimes want to be in front of objects,
     * and other times want to be behind the same objects.
     * @param ySort True if ySorting should be active, false if not
     */
    setYSort(ySort) {
        this.ySort = ySort;
    }
    /**
     * Gets the ySort status of the scene
     * @returns True if ySorting is occurring, false otherwise
     */
    getYSort() {
        return this.ySort;
    }
    /**
     * Sets the depth of the layer compared to other layers. A larger number means the layer will be closer to the screen.
     * @param depth The depth of the layer.
     */
    setDepth(depth) {
        this.depth = depth;
    }
    /**
     * Retrieves the depth of the layer.
     * @returns The depth
     */
    getDepth() {
        return this.depth;
    }
    /**
     * Adds a node to this layer
     * @param node The node to add to this layer.
     */
    addNode(node) {
        this.items.push(node);
        node.setLayer(this);
    }
    /**
     * Removes a node from this layer
     * @param node The node to remove
     * @returns true if the node was removed, false otherwise
     */
    removeNode(node) {
        // Find and remove the node
        let index = this.items.indexOf(node);
        if (index !== -1) {
            this.items.splice(index, 1);
            node.setLayer(undefined);
        }
    }
    /**
     * Retreives all GameNodes from this layer
     * @returns an Array that contains all of the GameNodes in this layer.
     */
    getItems() {
        return this.items;
    }
}
exports.default = Layer;

},{"../Utils/MathUtils":96}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Layer_1 = require("../Layer");
/**
 * An extension of a Layer that has a parallax value.
 */
class ParallaxLayer extends Layer_1.default {
    /**
     * Creates a new ParallaxLayer.
     * Use addParallaxLayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this ParallaxLayer to
     * @param name The name of the ParallaxLayer
     * @param parallax The parallax level
     */
    constructor(scene, name, parallax) {
        super(scene, name);
        this.parallax = parallax;
    }
}
exports.default = ParallaxLayer;

},{"../Layer":81}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const ParallaxLayer_1 = require("./ParallaxLayer");
/**
 * A Layer strictly to be used for managing UIElements.
 * This is intended to be a Layer that always stays in the same place,
 * and thus renders things like a HUD or an inventory without taking into consideration the \reference[Viewport] scroll.
 */
class UILayer extends ParallaxLayer_1.default {
    /**
     * Creates a new UILayer.
     * Use addUILayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this UILayer to
     * @param name The name of the UILayer
     */
    constructor(scene, name) {
        super(scene, name, Vec2_1.default.ZERO);
    }
}
exports.default = UILayer;

},{"../../DataTypes/Vec2":18,"./ParallaxLayer":82}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Layer_1 = require("./Layer");
const Vec2_1 = require("../DataTypes/Vec2");
const BasicPhysicsManager_1 = require("../Physics/BasicPhysicsManager");
const SceneGraphArray_1 = require("../SceneGraph/SceneGraphArray");
const FactoryManager_1 = require("./Factories/FactoryManager");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const NavigationManager_1 = require("../Pathfinding/NavigationManager");
const AIManager_1 = require("../AI/AIManager");
const Map_1 = require("../DataTypes/Map");
const ParallaxLayer_1 = require("./Layers/ParallaxLayer");
const UILayer_1 = require("./Layers/UILayer");
const CanvasNode_1 = require("../Nodes/CanvasNode");
const SceneOptions_1 = require("./SceneOptions");
const Debug_1 = require("../Debug/Debug");
const TimerManager_1 = require("../Timing/TimerManager");
const TweenManager_1 = require("../Rendering/Animations/TweenManager");
const ParticleSystemManager_1 = require("../Rendering/Animations/ParticleSystemManager");
/**
 * Scenes are the main container in the game engine.
 * Your main scene is the current level or menu of the game, and will contain all of the GameNodes needed.
 * Scenes provide an easy way to load assets, add assets to the game world, and unload assets,
 * and have lifecycle methods exposed for these functions.
 */
class Scene {
    /**
     * Creates a new Scene. To add a new Scene in your game, use changeToScene() in @reference[SceneManager]
     * @param viewport The viewport of the game
     * @param sceneManager The SceneManager that owns this Scene
     * @param renderingManager The RenderingManager that will handle this Scene's rendering
     * @param game The instance of the Game
     * @param options The options for Scene initialization
     */
    constructor(viewport, sceneManager, renderingManager, options) {
        this.sceneOptions = SceneOptions_1.default.parse(options === undefined ? {} : options);
        this.worldSize = new Vec2_1.default(500, 500);
        this.viewport = viewport;
        this.viewport.setBounds(0, 0, 2560, 1280);
        this.running = false;
        this.sceneManager = sceneManager;
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.tilemaps = new Array();
        this.sceneGraph = new SceneGraphArray_1.default(this.viewport, this);
        this.layers = new Map_1.default();
        this.uiLayers = new Map_1.default();
        this.parallaxLayers = new Map_1.default();
        this.physicsManager = new BasicPhysicsManager_1.default(this.sceneOptions.physics);
        this.navManager = new NavigationManager_1.default();
        this.aiManager = new AIManager_1.default();
        this.renderingManager = renderingManager;
        this.add = new FactoryManager_1.default(this, this.tilemaps);
        this.load = ResourceManager_1.default.getInstance();
        this.resourceManager = this.load;
        // Get the timer manager and clear any existing timers
        TimerManager_1.default.getInstance().clearTimers();
    }
    /** A lifecycle method that gets called immediately after a new scene is created, before anything else. */
    initScene(init) { }
    /** A lifecycle method that gets called when a new scene is created. Load all files you wish to access in the scene here. */
    loadScene() { }
    /** A lifecycle method called strictly after loadScene(). Create any game objects you wish to use in the scene here. */
    startScene() { }
    /**
     * A lifecycle method called every frame of the game. This is where you can dynamically do things like add in new enemies
     * @param delta The time this frame represents
     */
    updateScene(deltaT) { }
    /** A lifecycle method that gets called on scene destruction. Specify which files you no longer need for garbage collection. */
    unloadScene() { }
    update(deltaT) {
        this.updateScene(deltaT);
        // Do time updates
        TimerManager_1.default.getInstance().update(deltaT);
        // Do all AI updates
        this.aiManager.update(deltaT);
        // Update all physics objects
        this.physicsManager.update(deltaT);
        // Update all canvas objects
        this.sceneGraph.update(deltaT);
        // Update all tilemaps
        this.tilemaps.forEach(tilemap => {
            if (!tilemap.getLayer().isPaused()) {
                tilemap.update(deltaT);
            }
        });
        // Update all tweens
        TweenManager_1.default.getInstance().update(deltaT);
        // Update all particle systems
        ParticleSystemManager_1.default.getInstance().update(deltaT);
        // Update viewport
        this.viewport.update(deltaT);
    }
    /**
     * Collects renderable sets and coordinates with the RenderingManager to draw the Scene
     */
    render() {
        // Get the visible set of nodes
        let visibleSet = this.sceneGraph.getVisibleSet();
        // Add parallax layer items to the visible set (we're rendering them all for now)
        this.parallaxLayers.forEach(key => {
            let pLayer = this.parallaxLayers.get(key);
            for (let node of pLayer.getItems()) {
                if (node instanceof CanvasNode_1.default) {
                    visibleSet.push(node);
                }
            }
        });
        // Send the visible set, tilemaps, and uiLayers to the renderer
        this.renderingManager.render(visibleSet, this.tilemaps, this.uiLayers);
        let nodes = this.sceneGraph.getAllNodes();
        this.tilemaps.forEach(tilemap => tilemap.visible ? nodes.push(tilemap) : 0);
        Debug_1.default.setNodes(nodes);
    }
    /**
     * Sets the scene as running or not
     * @param running True if the Scene should be running, false if not
     */
    setRunning(running) {
        this.running = running;
    }
    /**
     * Returns whether or not the Scene is running
     * @returns True if the scene is running, false otherwise
     */
    isRunning() {
        return this.running;
    }
    /**
     * Removes a node from this Scene
     * @param node The node to remove
     */
    remove(node) {
        // Remove from the scene graph
        if (node instanceof CanvasNode_1.default) {
            this.sceneGraph.removeNode(node);
        }
    }
    /** Destroys this scene and all nodes in it */
    destroy() {
        for (let node of this.sceneGraph.getAllNodes()) {
            node.destroy();
        }
        for (let tilemap of this.tilemaps) {
            tilemap.destroy();
        }
        this.receiver.destroy();
        delete this.sceneGraph;
        delete this.physicsManager;
        delete this.navManager;
        delete this.aiManager;
        delete this.receiver;
    }
    /**
     * Adds a new layer to the scene and returns it
     * @param name The name of the new layer
     * @param depth The depth of the layer
     * @returns The newly created Layer
     */
    addLayer(name, depth) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new Layer_1.default(this, name);
        this.layers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    }
    /**
     * Adds a new parallax layer to this scene and returns it
     * @param name The name of the parallax layer
     * @param parallax The parallax level
     * @param depth The depth of the layer
     * @returns The newly created ParallaxLayer
     */
    addParallaxLayer(name, parallax, depth) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new ParallaxLayer_1.default(this, name, parallax);
        this.parallaxLayers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    }
    /**
     * Adds a new UILayer to the scene
     * @param name The name of the new UIlayer
     * @returns The newly created UILayer
     */
    addUILayer(name) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new UILayer_1.default(this, name);
        this.uiLayers.add(name, layer);
        return layer;
    }
    /**
     * Gets a layer from the scene by name if it exists.
     * This can be a Layer or any of its subclasses
     * @param name The name of the layer
     * @returns The Layer found with that name
     */
    getLayer(name) {
        if (this.layers.has(name)) {
            return this.layers.get(name);
        }
        else if (this.parallaxLayers.has(name)) {
            return this.parallaxLayers.get(name);
        }
        else if (this.uiLayers.has(name)) {
            return this.uiLayers.get(name);
        }
        else {
            throw `Requested layer ${name} does not exist.`;
        }
    }
    /**
     * Returns true if this layer is a ParallaxLayer
     * @param name The name of the layer
     * @returns True if this layer is a ParallaxLayer
     */
    isParallaxLayer(name) {
        return this.parallaxLayers.has(name);
    }
    /**
     * Returns true if this layer is a UILayer
     * @param name The name of the layer
     * @returns True if this layer is ParallaxLayer
     */
    isUILayer(name) {
        return this.uiLayers.has(name);
    }
    /**
     * Returns the translation of this node with respect to camera space (due to the viewport moving).
     * This value is affected by the parallax level of the @reference[Layer] the node is on.
     * @param node The node to check the viewport with respect to
     * @returns A Vec2 containing the translation of viewport with respect to this node.
     */
    getViewTranslation(node) {
        let layer = node.getLayer();
        if (layer instanceof ParallaxLayer_1.default || layer instanceof UILayer_1.default) {
            return this.viewport.getOrigin().mult(layer.parallax);
        }
        else {
            return this.viewport.getOrigin();
        }
    }
    /**
     * Returns the scale level of the view
     * @returns The zoom level of the viewport
    */
    getViewScale() {
        return this.viewport.getZoomLevel();
    }
    /**
     * Returns the Viewport associated with this scene
     * @returns The current Viewport
     */
    getViewport() {
        return this.viewport;
    }
    /**
     * Gets the world size of this Scene
     * @returns The world size in a Vec2
     */
    getWorldSize() {
        return this.worldSize;
    }
    /**
     * Gets the SceneGraph associated with this Scene
     * @returns The SceneGraph
     */
    getSceneGraph() {
        return this.sceneGraph;
    }
    /**
     * Gets the PhysicsManager associated with this Scene
     * @returns The PhysicsManager
     */
    getPhysicsManager() {
        return this.physicsManager;
    }
    /**
     * Gets the NavigationManager associated with this Scene
     * @returns The NavigationManager
     */
    getNavigationManager() {
        return this.navManager;
    }
    /**
     * Gets the AIManager associated with this Scene
     * @returns The AIManager
     */
    getAIManager() {
        return this.aiManager;
    }
    /**
     * Generates an ID for a GameNode
     * @returns The new ID
     */
    generateId() {
        return this.sceneManager.generateId();
    }
    /**
     * Retrieves a Tilemap in this Scene
     * @param name The name of the Tilemap
     * @returns The Tilemap, if one this name exists, otherwise null
     */
    getTilemap(name) {
        for (let tilemap of this.tilemaps) {
            if (tilemap.name === name) {
                return tilemap;
            }
        }
        return null;
    }
}
exports.default = Scene;

},{"../AI/AIManager":1,"../DataTypes/Map":7,"../DataTypes/Vec2":18,"../Debug/Debug":19,"../Events/Emitter":21,"../Events/Receiver":25,"../Nodes/CanvasNode":33,"../Pathfinding/NavigationManager":51,"../Physics/BasicPhysicsManager":54,"../Rendering/Animations/ParticleSystemManager":62,"../Rendering/Animations/TweenManager":64,"../ResourceManager/ResourceManager":77,"../SceneGraph/SceneGraphArray":88,"../Timing/TimerManager":92,"./Factories/FactoryManager":79,"./Layer":81,"./Layers/ParallaxLayer":82,"./Layers/UILayer":83,"./SceneOptions":86}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
/**
 * The SceneManager acts as an interface to create Scenes, and handles the lifecycle methods of Scenes.
 * It gives Scenes access to information they need from the @reference[Game] class while keeping a layer of separation.
 */
class SceneManager {
    /**
     * Creates a new SceneManager
     * @param viewport The Viewport of the game
     * @param game The Game instance
     * @param renderingManager The RenderingManager of the game
     */
    constructor(viewport, renderingManager) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.viewport = viewport;
        this.renderingManager = renderingManager;
        this.idCounter = 0;
        this.pendingScene = null;
    }
    /**
     * Add a scene as the main scene.
     * Use this method if you've created a subclass of Scene, and you want to add it as the main Scene.
     * @param constr The constructor of the scene to add
     * @param init An object to pass to the init function of the new scene
     */
    changeToScene(constr, init, options) {
        console.log("Creating the new scene - change is pending until next update");
        this.pendingScene = new constr(this.viewport, this, this.renderingManager, options);
        this.pendingSceneInit = init;
    }
    doSceneChange() {
        console.log("Performing scene change");
        this.viewport.setCenter(this.viewport.getHalfSize().x, this.viewport.getHalfSize().y);
        if (this.currentScene) {
            console.log("Unloading old scene");
            this.currentScene.unloadScene();
            console.log("Destroying old scene");
            this.currentScene.destroy();
        }
        console.log("Unloading old resources...");
        this.resourceManager.unloadAllResources();
        // Make the pending scene the current one
        this.currentScene = this.pendingScene;
        // Make the pending scene null
        this.pendingScene = null;
        // Init the scene
        this.currentScene.initScene(this.pendingSceneInit);
        // Enqueue all scene asset loads
        this.currentScene.loadScene();
        // Load all assets
        console.log("Starting Scene Load");
        this.resourceManager.loadResourcesFromQueue(() => {
            console.log("Starting Scene");
            this.currentScene.startScene();
            this.currentScene.setRunning(true);
        });
        this.renderingManager.setScene(this.currentScene);
    }
    /**
     * Generates a unique ID
     * @returns A new ID
     */
    generateId() {
        return this.idCounter++;
    }
    /**
     * Renders the current Scene
     */
    render() {
        if (this.currentScene) {
            this.currentScene.render();
        }
    }
    /**
     * Updates the current Scene
     * @param deltaT The timestep of the Scene
     */
    update(deltaT) {
        if (this.pendingScene !== null) {
            this.doSceneChange();
        }
        if (this.currentScene && this.currentScene.isRunning()) {
            this.currentScene.update(deltaT);
        }
    }
}
exports.default = SceneManager;

},{"../ResourceManager/ResourceManager":77}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignorePage
/**
 * The options to give a @reference[Scene] for initialization
 */
class SceneOptions {
    static parse(options) {
        let sOpt = new SceneOptions();
        if (options.physics === undefined) {
            sOpt.physics = { groups: undefined, collisions: undefined };
        }
        else {
            sOpt.physics = options.physics;
        }
        return sOpt;
    }
}
exports.default = SceneOptions;

},{}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
/**
 * An abstract interface of a SceneGraph.
 * Exposes methods for use by other code, but leaves the implementation up to the subclasses.
 * The SceneGraph manages the positions of all GameNodes, and can easily prune a visible set for rendering.
 */
class SceneGraph {
    /**
     * Creates a new SceneGraph
     * @param viewport The viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    constructor(viewport, scene) {
        this.viewport = viewport;
        this.scene = scene;
        this.nodeMap = new Array();
        this.idCounter = 0;
    }
    /**
     * Add a node to the SceneGraph
     * @param node The CanvasNode to add to the SceneGraph
     * @returns The SceneGraph ID of this newly added CanvasNode
     */
    addNode(node) {
        this.nodeMap[node.id] = node;
        this.addNodeSpecific(node, this.idCounter);
        this.idCounter += 1;
        return this.idCounter - 1;
    }
    ;
    /**
     * Removes a node from the SceneGraph
     * @param node The node to remove
     */
    removeNode(node) {
        // Find and remove node in O(n)
        this.nodeMap[node.id] = undefined;
        this.removeNodeSpecific(node, node.id);
    }
    ;
    /**
     * Get a specific node using its id
     * @param id The id of the CanvasNode to retrieve
     * @returns The node with this ID
     */
    getNode(id) {
        return this.nodeMap[id];
    }
    /**
     * Returns the nodes at specific coordinates
     * @param vecOrX The x-coordinate of the position, or the coordinates in a Vec2
     * @param y The y-coordinate of the position
     * @returns An array of nodes found at the position provided
     */
    getNodesAt(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            return this.getNodesAtCoords(vecOrX.x, vecOrX.y);
        }
        else {
            return this.getNodesAtCoords(vecOrX, y);
        }
    }
    /**
     * Returns all nodes in the SceneGraph
     * @returns An Array containing all nodes in the SceneGraph
     */
    getAllNodes() {
        let arr = new Array();
        for (let i = 0; i < this.nodeMap.length; i++) {
            if (this.nodeMap[i] !== undefined) {
                arr.push(this.nodeMap[i]);
            }
        }
        return arr;
    }
}
exports.default = SceneGraph;

},{"../DataTypes/Vec2":18}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const SceneGraph_1 = require("./SceneGraph");
const Stats_1 = require("../Debug/Stats");
/**
 * An implementation of a SceneGraph that simply stored CanvasNodes in an array.
 */
class SceneGraphArray extends SceneGraph_1.default {
    /**
     * Creates a new SceneGraphArray
     * @param viewport The Viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    constructor(viewport, scene) {
        super(viewport, scene);
        this.nodeList = new Array();
    }
    // @override
    addNodeSpecific(node, id) {
        this.nodeList.push(node);
    }
    // @override
    removeNodeSpecific(node, id) {
        let index = this.nodeList.indexOf(node);
        if (index > -1) {
            this.nodeList.splice(index, 1);
        }
    }
    // @override
    getNodesAtCoords(x, y) {
        let results = [];
        for (let node of this.nodeList) {
            if (node.contains(x, y)) {
                results.push(node);
            }
        }
        return results;
    }
    // @override
    getNodesInRegion(boundary) {
        let t0 = performance.now();
        let results = [];
        for (let node of this.nodeList) {
            if (boundary.overlaps(node.boundary)) {
                results.push(node);
            }
        }
        let t1 = performance.now();
        Stats_1.default.log("sgquery", (t1 - t0));
        return results;
    }
    update(deltaT) {
        let t0 = performance.now();
        for (let node of this.nodeList) {
            if (!node.getLayer().isPaused()) {
                node.update(deltaT);
            }
        }
        let t1 = performance.now();
        Stats_1.default.log("sgupdate", (t1 - t0));
    }
    render(ctx) { }
    // @override
    getVisibleSet() {
        let visibleSet = new Array();
        for (let node of this.nodeList) {
            if (!node.getLayer().isHidden() && node.visible && this.viewport.includes(node)) {
                visibleSet.push(node);
            }
        }
        return visibleSet;
    }
}
exports.default = SceneGraphArray;

},{"../Debug/Stats":20,"./SceneGraph":87}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const MathUtils_1 = require("../Utils/MathUtils");
const Queue_1 = require("../DataTypes/Queue");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const Input_1 = require("../Input/Input");
const ParallaxLayer_1 = require("../Scene/Layers/ParallaxLayer");
const UILayer_1 = require("../Scene/Layers/UILayer");
/**
 * The viewport of the game. Corresponds to the visible window displayed in the browser.
 * The viewport keeps track of its position in the game world, and can act as a camera to follow objects.
 */
class Viewport {
    constructor(canvasSize, zoomLevel) {
        /** The amount that is zoomed in or out. */
        this.ZOOM_FACTOR = 1.2;
        this.view = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
        this.boundary = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
        this.lastPositions = new Queue_1.default();
        this.smoothingFactor = 10;
        this.scrollZoomEnabled = false;
        this.canvasSize = Vec2_1.default.ZERO;
        this.focus = Vec2_1.default.ZERO;
        // Set the size of the canvas
        this.setCanvasSize(canvasSize);
        // Set the size of the viewport
        this.setSize(canvasSize);
        this.setZoomLevel(zoomLevel);
        // Set the center (and make the viewport stay there)
        this.setCenter(this.view.halfSize.clone());
        this.setFocus(this.view.halfSize.clone());
    }
    /** Enables the viewport to zoom in and out */
    enableZoom() {
        this.scrollZoomEnabled = true;
    }
    /**
     * Returns the position of the viewport
     * @returns The center of the viewport as a Vec2
     */
    getCenter() {
        return this.view.center;
    }
    /**
     * Returns a new Vec2 with the origin of the viewport
     * @returns The top left cornder of the Vieport as a Vec2
     */
    getOrigin() {
        return new Vec2_1.default(this.view.left, this.view.top);
    }
    /**
     * Returns the region visible to this viewport
     * @returns The AABB containing the region visible to the viewport
     */
    getView() {
        return this.view;
    }
    /**
     * Set the position of the viewport
     * @param vecOrX The new position or the x-coordinate of the new position
     * @param y The y-coordinate of the new position
     */
    setCenter(vecOrX, y = null) {
        let pos;
        if (vecOrX instanceof Vec2_1.default) {
            pos = vecOrX;
        }
        else {
            pos = new Vec2_1.default(vecOrX, y);
        }
        this.view.center = pos;
    }
    /**
     * Returns the size of the viewport as a Vec2
     * @returns The half-size of the viewport as a Vec2
     */
    getHalfSize() {
        return this.view.getHalfSize();
    }
    /**
     * Sets the size of the viewport
     * @param vecOrX The new width of the viewport or the new size as a Vec2
     * @param y The new height of the viewport
     */
    setSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.view.setHalfSize(vecOrX.scaled(1 / 2));
        }
        else {
            this.view.setHalfSize(new Vec2_1.default(vecOrX / 2, y / 2));
        }
    }
    /**
     * Sets the half-size of the viewport
     * @param vecOrX The new half-width of the viewport or the new half-size as a Vec2
     * @param y The new height of the viewport
     */
    setHalfSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.view.setHalfSize(vecOrX.clone());
        }
        else {
            this.view.setHalfSize(new Vec2_1.default(vecOrX, y));
        }
    }
    /**
     * Updates the viewport with the size of the current Canvas
     * @param vecOrX The width of the canvas, or the canvas size as a Vec2
     * @param y The height of the canvas
     */
    setCanvasSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.canvasSize = vecOrX.clone();
        }
        else {
            this.canvasSize = new Vec2_1.default(vecOrX, y);
        }
    }
    /**
     * Sets the zoom level of the viewport
     * @param zoom The zoom level
     */
    setZoomLevel(zoom) {
        this.view.halfSize.copy(this.canvasSize.scaled(1 / zoom / 2));
    }
    /**
     * Gets the zoom level of the viewport
     * @returns The zoom level
     */
    getZoomLevel() {
        return this.canvasSize.x / this.view.hw / 2;
    }
    /**
     * Sets the smoothing factor for the viewport movement.
     * @param smoothingFactor The smoothing factor for the viewport
     */
    setSmoothingFactor(smoothingFactor) {
        if (smoothingFactor < 1)
            smoothingFactor = 1;
        this.smoothingFactor = smoothingFactor;
    }
    /**
     * Tells the viewport to focus on a point. Overidden by "following".
     * @param focus The point the  viewport should focus on
     */
    setFocus(focus) {
        this.focus.copy(focus);
    }
    /**
     * Returns true if the CanvasNode is inside of the viewport
     * @param node The node to check
     * @returns True if the node is currently visible in the viewport, false if not
     */
    includes(node) {
        let parallax = node.getLayer() instanceof ParallaxLayer_1.default || node.getLayer() instanceof UILayer_1.default ? node.getLayer().parallax : new Vec2_1.default(1, 1);
        let center = this.view.center.clone();
        this.view.center.mult(parallax);
        let overlaps = this.view.overlaps(node.boundary);
        this.view.center = center;
        return overlaps;
    }
    // TODO: Put some error handling on this for trying to make the bounds too small for the viewport
    // TODO: This should probably be done automatically, or should consider the aspect ratio or something
    /**
     * Sets the bounds of the viewport
     * @param lowerX The left edge of the viewport
     * @param lowerY The top edge of the viewport
     * @param upperX The right edge of the viewport
     * @param upperY The bottom edge of the viewport
     */
    setBounds(lowerX, lowerY, upperX, upperY) {
        let hwidth = (upperX - lowerX) / 2;
        let hheight = (upperY - lowerY) / 2;
        let x = lowerX + hwidth;
        let y = lowerY + hheight;
        this.boundary.center.set(x, y);
        this.boundary.halfSize.set(hwidth, hheight);
    }
    /**
     * Make the viewport follow the specified GameNode
     * @param node The GameNode to follow
     */
    follow(node) {
        this.following = node;
    }
    updateView() {
        if (this.lastPositions.getSize() > this.smoothingFactor) {
            this.lastPositions.dequeue();
        }
        // Get the average of the last 10 positions
        let pos = Vec2_1.default.ZERO;
        this.lastPositions.forEach(position => pos.add(position));
        pos.scale(1 / this.lastPositions.getSize());
        // Set this position either to the object or to its bounds
        pos.x = MathUtils_1.default.clamp(pos.x, this.boundary.left + this.view.hw, this.boundary.right - this.view.hw);
        pos.y = MathUtils_1.default.clamp(pos.y, this.boundary.top + this.view.hh, this.boundary.bottom - this.view.hh);
        // Assure there are no lines in the tilemap
        pos.x = Math.floor(pos.x);
        pos.y = Math.floor(pos.y);
        this.view.center.copy(pos);
    }
    update(deltaT) {
        // If zoom is enabled
        if (this.scrollZoomEnabled) {
            if (Input_1.default.didJustScroll()) {
                let currentSize = this.view.getHalfSize().clone();
                if (Input_1.default.getScrollDirection() < 0) {
                    // Zoom in
                    currentSize.scale(1 / this.ZOOM_FACTOR);
                }
                else {
                    // Zoom out
                    currentSize.scale(this.ZOOM_FACTOR);
                }
                if (currentSize.x > this.boundary.hw) {
                    let factor = this.boundary.hw / currentSize.x;
                    currentSize.x = this.boundary.hw;
                    currentSize.y *= factor;
                }
                if (currentSize.y > this.boundary.hh) {
                    let factor = this.boundary.hh / currentSize.y;
                    currentSize.y = this.boundary.hh;
                    currentSize.x *= factor;
                }
                this.view.setHalfSize(currentSize);
            }
        }
        // If viewport is following an object
        if (this.following) {
            // Update our list of previous positions
            this.lastPositions.enqueue(this.following.position.clone());
        }
        else {
            this.lastPositions.enqueue(this.focus);
        }
        this.updateView();
    }
}
exports.default = Viewport;

},{"../DataTypes/Queue":11,"../DataTypes/Shapes/AABB":13,"../DataTypes/Vec2":18,"../Input/Input":26,"../Scene/Layers/ParallaxLayer":82,"../Scene/Layers/UILayer":83,"../Utils/MathUtils":96}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_AUDIO_CHANNELS = exports.AudioChannelType = void 0;
const Map_1 = require("../DataTypes/Map");
const Receiver_1 = require("../Events/Receiver");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Manages any sounds or music needed for the game.
 * Through the EventQueue, exposes interface to play sounds so GameNodes can activate sounds without
 * needing direct references to the audio system
 */
class AudioManager {
    constructor() {
        this.initAudio();
        this.receiver = new Receiver_1.default();
        this.receiver.subscribe([
            GameEventType_1.GameEventType.PLAY_SOUND,
            GameEventType_1.GameEventType.STOP_SOUND,
            GameEventType_1.GameEventType.PLAY_MUSIC,
            GameEventType_1.GameEventType.PLAY_SFX,
            GameEventType_1.GameEventType.MUTE_CHANNEL,
            GameEventType_1.GameEventType.UNMUTE_CHANNEL
        ]);
        this.currentSounds = new Map_1.default();
        this.gainNodes = new Array(exports.MAX_AUDIO_CHANNELS);
        this.initGainNodes();
    }
    /**
     * Get the instance of the AudioManager class or create a new one if none exists
     * @returns The AudioManager
     */
    static getInstance() {
        if (!this.instance) {
            this.instance = new AudioManager();
        }
        return this.instance;
    }
    /**
     * Initializes the webAudio context
     */
    initAudio() {
        try {
            window.AudioContext = window.AudioContext; // || window.webkitAudioContext; 
            this.audioCtx = new AudioContext();
            console.log('Web Audio API successfully loaded');
        }
        catch (e) {
            console.warn('Web Audio API is not supported in this browser');
        }
    }
    initGainNodes() {
        for (let i = 0; i < exports.MAX_AUDIO_CHANNELS; i++) {
            this.gainNodes[i] = this.audioCtx.createGain();
        }
    }
    /**
     * Returns the current audio context
     * @returns The AudioContext
     */
    getAudioContext() {
        return this.audioCtx;
    }
    /*
        According to the MDN, create a new sound for every call:

        An AudioBufferSourceNode can only be played once; after each call to start(), you have to create a new node
        if you want to play the same sound again. Fortunately, these nodes are very inexpensive to create, and the
        actual AudioBuffers can be reused for multiple plays of the sound. Indeed, you can use these nodes in a
        "fire and forget" manner: create the node, call start() to begin playing the sound, and don't even bother to
        hold a reference to it. It will automatically be garbage-collected at an appropriate time, which won't be
        until sometime after the sound has finished playing.
    */
    /**
     * Creates a new sound from the key of a loaded audio file
     * @param key The key of the loaded audio file to create a new sound for
     * @returns The newly created AudioBuffer
     */
    createSound(key, holdReference, channel, options) {
        // Get audio buffer
        let buffer = ResourceManager_1.default.getInstance().getAudio(key);
        // Create a sound source
        var source = this.audioCtx.createBufferSource();
        // Tell the source which sound to play
        source.buffer = buffer;
        // Add any additional nodes
        const nodes = [source];
        // Do any additional nodes here?
        // Of course, there aren't any supported yet...
        // Add the gain node for this channel
        nodes.push(this.gainNodes[channel]);
        // Connect any nodes along the path
        for (let i = 1; i < nodes.length; i++) {
            nodes[i - 1].connect(nodes[i]);
        }
        // Connect the source to the context's destination
        nodes[nodes.length - 1].connect(this.audioCtx.destination);
        return source;
    }
    /**
     * Play the sound specified by the key
     * @param key The key of the sound to play
     * @param loop A boolean for whether or not to loop the sound
     * @param holdReference A boolean for whether or not we want to hold on to a reference of the audio node. This is good for playing music on a loop that will eventually need to be stopped.
     */
    playSound(key, loop, holdReference, channel, options) {
        let sound = this.createSound(key, holdReference, channel, options);
        if (loop) {
            sound.loop = true;
        }
        // Add a reference of the new sound to a map. This will allow us to stop a looping or long sound at a later time
        if (holdReference) {
            this.currentSounds.add(key, sound);
        }
        sound.start();
    }
    /**
     * Stop the sound specified by the key
     */
    stopSound(key) {
        let sound = this.currentSounds.get(key);
        if (sound) {
            sound.stop();
            this.currentSounds.delete(key);
        }
    }
    muteChannel(channel) {
        this.gainNodes[channel].gain.setValueAtTime(0, this.audioCtx.currentTime);
    }
    unmuteChannel(channel) {
        this.gainNodes[channel].gain.setValueAtTime(1, this.audioCtx.currentTime);
    }
    /**
     * Sets the volume of a channel using the GainNode for that channel. For more
     * information on GainNodes, see https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * @param channel The audio channel to set the volume for
     * @param volume The volume of the channel. 0 is muted. Values below zero will be set to zero.
     */
    static setVolume(channel, volume) {
        if (volume < 0) {
            volume = 0;
        }
        const am = AudioManager.getInstance();
        am.gainNodes[channel].gain.setValueAtTime(volume, am.audioCtx.currentTime);
    }
    /**
     * Returns the GainNode for this channel.
     * Learn more about GainNodes here https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * DON'T USE THIS UNLESS YOU KNOW WHAT YOU'RE DOING
     * @param channel The channel
     * @returns The GainNode for the specified channel
     */
    getChannelGainNode(channel) {
        return this.gainNodes[channel];
    }
    update(deltaT) {
        // Play each audio clip requested
        // TODO - Add logic to merge sounds if there are multiple of the same key
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            if (event.type === GameEventType_1.GameEventType.PLAY_SOUND || event.type === GameEventType_1.GameEventType.PLAY_MUSIC || event.type === GameEventType_1.GameEventType.PLAY_SFX) {
                let soundKey = event.data.get("key");
                let loop = event.data.get("loop");
                let holdReference = event.data.get("holdReference");
                let channel = AudioChannelType.DEFAULT;
                if (event.type === GameEventType_1.GameEventType.PLAY_MUSIC) {
                    channel = AudioChannelType.MUSIC;
                }
                else if (GameEventType_1.GameEventType.PLAY_SFX) {
                    channel = AudioChannelType.SFX;
                }
                else if (event.data.has("channel")) {
                    channel = event.data.get("channel");
                }
                this.playSound(soundKey, loop, holdReference, channel, event.data);
            }
            if (event.type === GameEventType_1.GameEventType.STOP_SOUND) {
                let soundKey = event.data.get("key");
                this.stopSound(soundKey);
            }
            if (event.type === GameEventType_1.GameEventType.MUTE_CHANNEL) {
                this.muteChannel(event.data.get("channel"));
            }
            if (event.type === GameEventType_1.GameEventType.UNMUTE_CHANNEL) {
                this.unmuteChannel(event.data.get("channel"));
            }
        }
    }
}
exports.default = AudioManager;
var AudioChannelType;
(function (AudioChannelType) {
    AudioChannelType[AudioChannelType["DEFAULT"] = 0] = "DEFAULT";
    AudioChannelType[AudioChannelType["SFX"] = 1] = "SFX";
    AudioChannelType[AudioChannelType["MUSIC"] = 2] = "MUSIC";
    AudioChannelType[AudioChannelType["CUSTOM_1"] = 3] = "CUSTOM_1";
    AudioChannelType[AudioChannelType["CUSTOM_2"] = 4] = "CUSTOM_2";
    AudioChannelType[AudioChannelType["CUSTOM_3"] = 5] = "CUSTOM_3";
    AudioChannelType[AudioChannelType["CUSTOM_4"] = 6] = "CUSTOM_4";
    AudioChannelType[AudioChannelType["CUSTOM_5"] = 7] = "CUSTOM_5";
    AudioChannelType[AudioChannelType["CUSTOM_6"] = 8] = "CUSTOM_6";
    AudioChannelType[AudioChannelType["CUSTOM_7"] = 9] = "CUSTOM_7";
    AudioChannelType[AudioChannelType["CUSTOM_8"] = 10] = "CUSTOM_8";
    AudioChannelType[AudioChannelType["CUSTOM_9"] = 11] = "CUSTOM_9";
})(AudioChannelType = exports.AudioChannelType || (exports.AudioChannelType = {}));
exports.MAX_AUDIO_CHANNELS = 12;

},{"../DataTypes/Map":7,"../Events/GameEventType":24,"../Events/Receiver":25,"../ResourceManager/ResourceManager":77}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimerState = void 0;
const MathUtils_1 = require("../Utils/MathUtils");
const TimerManager_1 = require("./TimerManager");
/** */
class Timer {
    constructor(time, onEnd, loop = false) {
        // Register this timer
        TimerManager_1.default.getInstance().addTimer(this);
        this.totalTime = time;
        this.timeLeft = 0;
        this.onEnd = onEnd;
        this.loop = loop;
        this.state = TimerState.STOPPED;
        this.numRuns = 0;
    }
    isStopped() {
        return this.state === TimerState.STOPPED;
    }
    isPaused() {
        return this.state === TimerState.PAUSED;
    }
    /**
     * Returns whether or not this timer has been run before
     * @returns true if it has been run at least once (after the latest reset), and false otherwise
     */
    hasRun() {
        return this.numRuns > 0;
    }
    start(time) {
        if (time !== undefined) {
            this.totalTime = time;
        }
        this.state = TimerState.ACTIVE;
        this.timeLeft = this.totalTime;
    }
    /** Resets this timer. Sets the progress back to zero, and sets the number of runs back to zero */
    reset() {
        this.timeLeft = this.totalTime;
        this.numRuns = 0;
    }
    pause() {
        this.state = TimerState.PAUSED;
    }
    update(deltaT) {
        if (this.state === TimerState.ACTIVE) {
            this.timeLeft -= deltaT * 1000;
            if (this.timeLeft <= 0) {
                this.timeLeft = MathUtils_1.default.clampLow0(this.timeLeft);
                this.end();
            }
        }
    }
    end() {
        // Update the state
        this.state = TimerState.STOPPED;
        this.numRuns += 1;
        // Call the end function if there is one
        if (this.onEnd) {
            this.onEnd();
        }
        // Loop if we want to
        if (this.loop) {
            this.state = TimerState.ACTIVE;
            this.timeLeft = this.totalTime;
        }
    }
    toString() {
        return "Timer: " + this.state + " - Time Left: " + this.timeLeft + "ms of " + this.totalTime + "ms";
    }
}
exports.default = Timer;
var TimerState;
(function (TimerState) {
    TimerState["ACTIVE"] = "ACTIVE";
    TimerState["PAUSED"] = "PAUSED";
    TimerState["STOPPED"] = "STOPPED";
})(TimerState = exports.TimerState || (exports.TimerState = {}));

},{"../Utils/MathUtils":96,"./TimerManager":92}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TimerManager {
    constructor() {
        this.timers = new Array();
    }
    static getInstance() {
        if (!this.instance) {
            this.instance = new TimerManager();
        }
        return this.instance;
    }
    addTimer(timer) {
        this.timers.push(timer);
    }
    clearTimers() {
        this.timers = new Array();
    }
    update(deltaT) {
        this.timers.forEach(timer => timer.update(deltaT));
    }
}
exports.default = TimerManager;

},{}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("./MathUtils");
// TODO: This should be moved to the datatypes folder
/**
 * A Color util class that keeps track of colors like a vector, but can be converted into a string format
 */
class Color {
    /**
     * Creates a new color
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    constructor(r = 0, g = 0, b = 0, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Transparent color
     * @returns rgba(0, 0, 0, 0)
     */
    static get TRANSPARENT() {
        return new Color(0, 0, 0, 0);
    }
    /**
     * Red color
     * @returns rgb(255, 0, 0)
     */
    static get RED() {
        return new Color(255, 0, 0, 1);
    }
    /**
     * Green color
     * @returns rgb(0, 255, 0)
     */
    static get GREEN() {
        return new Color(0, 255, 0, 1);
    }
    /**
     * Blue color
     * @returns rgb(0, 0, 255)
     */
    static get BLUE() {
        return new Color(0, 0, 255, 1);
    }
    /**
     * Yellow color
     * @returns rgb(255, 255, 0)
     */
    static get YELLOW() {
        return new Color(255, 255, 0, 1);
    }
    /**
     * Magenta color
     * @returns rgb(255, 0, 255)
     */
    static get MAGENTA() {
        return new Color(255, 0, 255, 1);
    }
    /**
     * Cyan color
     * @returns rgb(0, 255, 255)
     */
    static get CYAN() {
        return new Color(0, 255, 255, 1);
    }
    /**
     * White color
     * @returns rgb(255, 255, 255)
     */
    static get WHITE() {
        return new Color(255, 255, 255, 1);
    }
    /**
     * Black color
     * @returns rgb(0, 0, 0)
     */
    static get BLACK() {
        return new Color(0, 0, 0, 1);
    }
    /**
     * Orange color
     * @returns rgb(255, 100, 0)
     */
    static get ORANGE() {
        return new Color(255, 100, 0, 1);
    }
    /**
     * Sets the color to the values provided
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    set(r, g, b, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Returns a new color slightly lighter than the current color
     * @returns A new lighter Color
     */
    lighten() {
        return new Color(MathUtils_1.default.clamp(this.r + 40, 0, 255), MathUtils_1.default.clamp(this.g + 40, 0, 255), MathUtils_1.default.clamp(this.b + 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
    }
    /**
     * Returns a new color slightly darker than the current color
     * @returns A new darker Color
     */
    darken() {
        return new Color(MathUtils_1.default.clamp(this.r - 40, 0, 255), MathUtils_1.default.clamp(this.g - 40, 0, 255), MathUtils_1.default.clamp(this.b - 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
    }
    /**
     * Returns this color as an array
     * @returns [r, g, b, a]
     */
    toArray() {
        return [this.r, this.g, this.b, this.a];
    }
    /**
     * Returns the color as a string of the form #RRGGBB
     * @returns #RRGGBB
     */
    toString() {
        return "#" + MathUtils_1.default.toHex(this.r, 2) + MathUtils_1.default.toHex(this.g, 2) + MathUtils_1.default.toHex(this.b, 2);
    }
    /**
     * Returns the color as a string of the form rgb(r, g, b)
     * @returns rgb(r, g, b)
     */
    toStringRGB() {
        return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
    }
    /**
     * Returns the color as a string of the form rgba(r, g, b, a)
     * @returns rgba(r, g, b, a)
     */
    toStringRGBA() {
        if (this.a === 0) {
            return this.toStringRGB();
        }
        return "rgba(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ", " + this.a.toString() + ")";
    }
    /**
     * Turns this color into a float32Array and changes color range to [0.0, 1.0]
     * @returns a Float32Array containing the color
     */
    toWebGL() {
        return new Float32Array([
            this.r / 255,
            this.g / 255,
            this.b / 255,
            this.a
        ]);
    }
    static fromStringHex(str) {
        let i = 0;
        if (str.charAt(0) == "#")
            i += 1;
        let r = MathUtils_1.default.fromHex(str.substring(i, i + 2));
        let g = MathUtils_1.default.fromHex(str.substring(i + 2, i + 4));
        let b = MathUtils_1.default.fromHex(str.substring(i + 4, i + 6));
        return new Color(r, g, b);
    }
}
exports.default = Color;

},{"./MathUtils":96}],94:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
exports.EaseFunctionType = void 0;
class EaseFunctions {
    static easeInOutSine(x) {
        return -(Math.cos(Math.PI * x) - 1) / 2;
    }
    static easeOutInSine(x) {
        return x < 0.5 ? -Math.cos(Math.PI * (x + 0.5)) / 2 : -Math.cos(Math.PI * (x - 0.5)) / 2 + 1;
    }
    static easeOutSine(x) {
        return Math.sin((x * Math.PI) / 2);
    }
    static easeInSine(x) {
        return 1 - Math.cos((x * Math.PI) / 2);
    }
    static easeInOutQuint(x) {
        return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;
    }
    static easeInOutQuad(x) {
        return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
    }
    static easeOutInQuad(x) {
        return x < 0.5 ? this.easeOutIn_OutPow(x, 2) : this.easeOutIn_InPow(x, 2);
    }
    static easeOutIn_OutPow(x, pow) {
        return 0.5 - Math.pow(-2 * x + 1, pow) / 2;
    }
    static easeOutIn_InPow(x, pow) {
        return 0.5 + Math.pow(2 * x - 1, pow) / 2;
    }
}
exports.default = EaseFunctions;
var EaseFunctionType;
(function (EaseFunctionType) {
    // SINE
    EaseFunctionType["IN_OUT_SINE"] = "easeInOutSine";
    EaseFunctionType["OUT_IN_SINE"] = "easeOutInSine";
    EaseFunctionType["IN_SINE"] = "easeInSine";
    EaseFunctionType["OUT_SINE"] = "easeOutSine";
    // QUAD
    EaseFunctionType["IN_OUT_QUAD"] = "easeInOutQuad";
    EaseFunctionType["OUT_IN_QUAD"] = "easeOutInQuad";
    // QUINT
    EaseFunctionType["IN_OUT_QUINT"] = "easeInOutQuint";
})(EaseFunctionType = exports.EaseFunctionType || (exports.EaseFunctionType = {}));

},{}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A class to provides some utility functions for graphs */
class GraphUtils {
    /**
     * An implementation of Djikstra's shortest path algorithm based on the one described in The Algorithm Design Manual.
     * @param g The graph
     * @param start The number to start the shortest path from
     * @returns An array containing the parent of each node of the Graph in the shortest path.
     */
    static djikstra(g, start) {
        let i; // Counter
        let p; // Pointer to edgenode
        let inTree = new Array(g.numVertices);
        let distance = new Array(g.numVertices);
        let parent = new Array(g.numVertices);
        let v; // Current vertex to process
        let w; // Candidate for next vertex
        let weight; // Edge weight
        let dist; // Best current distance from start
        for (i = 0; i < g.numVertices; i++) {
            inTree[i] = false;
            distance[i] = Infinity;
            parent[i] = -1;
        }
        distance[start] = 0;
        v = start;
        while (!inTree[v]) {
            inTree[v] = true;
            p = g.edges[v];
            while (p !== null) {
                w = p.y;
                weight = p.weight;
                if (distance[w] > distance[v] + weight) {
                    distance[w] = distance[v] + weight;
                    parent[w] = v;
                }
                p = p.next;
            }
            v = 0;
            dist = Infinity;
            for (i = 0; i <= g.numVertices; i++) {
                if (!inTree[i] && dist > distance[i]) {
                    dist = distance;
                    v = i;
                }
            }
        }
        return parent;
    }
}
exports.default = GraphUtils;

},{}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A class containing some utility functions for math operations */
class MathUtils {
    /**
     * Returns the sign of the value provided
     * @param x The value to extract the sign from
     * @returns -1 if the number is less than 0, 1 otherwise
     */
    static sign(x) {
        return x < 0 ? -1 : 1;
    }
    /**
     * Returns whether or not x is between a and b
     * @param a The min bound
     * @param b The max bound
     * @param x The value to check
     * @param exclusive Whether or not a and b are exclusive bounds
     * @returns True if x is between a and b, false otherwise
     */
    static between(a, b, x, exclusive) {
        if (exclusive) {
            return (a < x) && (x < b);
        }
        else {
            return (a <= x) && (x <= b);
        }
    }
    /**
     * Clamps the value x to the range [min, max], rounding up or down if needed
     * @param x The value to be clamped
     * @param min The min of the range
     * @param max The max of the range
     * @returns x, if it is between min and max, or min/max if it exceeds their bounds
     */
    static clamp(x, min, max) {
        if (x < min)
            return min;
        if (x > max)
            return max;
        return x;
    }
    /**
     * Clamps the value x to the range between 0 and 1
     * @param x The value to be clamped
     * @returns x, if it is between 0 and 1, or 0/1 if it exceeds their bounds
     */
    static clamp01(x) {
        return MathUtils.clamp(x, 0, 1);
    }
    /**
     * Clamps the lower end of the value of x to the range to min
     * @param x The value to be clamped
     * @param min The minimum allowed value of x
     * @returns x, if it is greater than min, otherwise min
     */
    static clampLow(x, min) {
        return x < min ? min : x;
    }
    /**
     * Clamps the lower end of the value of x to zero
     * @param x The value to be clamped
     * @returns x, if it is greater than 0, otherwise 0
     */
    static clampLow0(x) {
        return MathUtils.clampLow(x, 0);
    }
    static clampMagnitude(v, m) {
        if (v.magSq() > m * m) {
            return v.scaleTo(m);
        }
        else {
            return v;
        }
    }
    static changeRange(x, min, max, newMin, newMax) {
        return this.lerp(newMin, newMax, this.invLerp(min, max, x));
    }
    /**
     * Linear Interpolation
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param t The time we are interpolating to
     * @returns The value between a and b at time t
     */
    static lerp(a, b, t) {
        return a + t * (b - a);
    }
    /**
     * Inverse Linear Interpolation. Finds the time at which a value between a and b would occur
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param value The current value
     * @returns The time at which the current value occurs between a and b
     */
    static invLerp(a, b, value) {
        return (value - a) / (b - a);
    }
    /**
     * Cuts off decimal points of a number after a specified place
     * @param num The number to floor
     * @param place The last decimal place of the new number
     * @returns The floored number
     */
    static floorToPlace(num, place) {
        if (place === 0) {
            return Math.floor(num);
        }
        let factor = 10;
        while (place > 1) {
            factor != 10;
            place--;
        }
        return Math.floor(num * factor) / factor;
    }
    /**
     * Returns a number from a hex string
     * @param str the string containing the hex number
     * @returns the number in decimal represented by the hex string
     */
    static fromHex(str) {
        return parseInt(str, 16);
    }
    /**
     * Returns the number as a hexadecimal
     * @param num The number to convert to hex
     * @param minLength The length of the returned hex string (adds zero padding if needed)
     * @returns The hex representation of the number as a string
     */
    static toHex(num, minLength = null) {
        let factor = 1;
        while (factor * 16 < num) {
            factor *= 16;
        }
        let hexStr = "";
        while (factor >= 1) {
            let digit = Math.floor(num / factor);
            hexStr += MathUtils.toHexDigit(digit);
            num -= digit * factor;
            factor /= 16;
        }
        if (minLength !== null) {
            while (hexStr.length < minLength) {
                hexStr = "0" + hexStr;
            }
        }
        return hexStr;
    }
    /**
     * Converts a digit to hexadecimal. In this case, a digit is between 0 and 15 inclusive
     * @param num The digit to convert to hexadecimal
     * @returns The hex representation of the digit as a string
     */
    static toHexDigit(num) {
        if (num < 10) {
            return "" + num;
        }
        else {
            return String.fromCharCode(65 + num - 10);
        }
    }
}
exports.default = MathUtils;

},{}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("./MathUtils");
class RenderingUtils {
    static toWebGLCoords(point, origin, worldSize) {
        return new Float32Array([
            MathUtils_1.default.changeRange(point.x, origin.x, origin.x + worldSize.x, -1, 1),
            MathUtils_1.default.changeRange(point.y, origin.y, origin.y + worldSize.y, 1, -1)
        ]);
    }
    static toWebGLScale(size, worldSize) {
        return new Float32Array([
            2 * size.x / worldSize.x,
            2 * size.y / worldSize.y,
        ]);
    }
    static toWebGLColor(color) {
        return new Float32Array([
            MathUtils_1.default.changeRange(color.r, 0, 255, 0, 1),
            MathUtils_1.default.changeRange(color.g, 0, 255, 0, 1),
            MathUtils_1.default.changeRange(color.b, 0, 255, 0, 1),
            color.a
        ]);
    }
}
exports.default = RenderingUtils;

},{"./MathUtils":96}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** Some utility functions for dealing with strings */
class StringUtils {
    /**
     * Extracts the path from a filepath that includes the file
     * @param filePath the filepath to extract the path from
     * @returns The path portion of the filepath provided
     */
    static getPathFromFilePath(filePath) {
        let splitPath = filePath.split("/");
        splitPath.pop();
        splitPath.push("");
        return splitPath.join("/");
    }
}
exports.default = StringUtils;

},{}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnemyStates = void 0;
const Stack_1 = require("../../Wolfie2D/DataTypes/Stack");
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const Emitter_1 = require("../../Wolfie2D/Events/Emitter");
const NavigationPath_1 = require("../../Wolfie2D/Pathfinding/NavigationPath");
const Color_1 = require("../../Wolfie2D/Utils/Color");
const PointAttack_1 = require("../GameSystems/Attack/PointAttack");
const SliceAnimation_1 = require("../GameSystems/AttackAnimation/SliceAnimation");
class EnemyAI {
    constructor() {
        this.routeIndex = 0;
        this.emitter = new Emitter_1.default();
        /** The default movement speed of this AI */
        this.speed = 20;
        // Path to player
        this.path = [];
    }
    initializeAI(owner, options) {
        this.owner = owner;
        this.maxHealth = options.health;
        this.health = options.health;
        this.BasePos = options.BasePos;
        this.SpawnPos = options.SpawnPos;
        this.aliveWalls = options.aliveWalls;
        this.aliveTurrets = options.aliveTurrets;
        this.floor = options.floor;
        this.currentPath = this.getNextPath();
        this.atk = new PointAttack_1.default(10, 300, new SliceAnimation_1.SliceAnimation(Color_1.default.BLACK), {}, options.battleManager);
    }
    activate(options) { }
    damage(damage) {
        this.health -= damage;
        // If health goes below 0, disable AI and fire enemyDied event
        if (this.health <= 0) {
            this.owner.setAIActive(false, {});
            this.owner.isCollidable = false;
            this.owner.visible = false;
            this.emitter.fireEvent("enemyDied", { owner: this.owner });
        }
    }
    moveOnePath(deltaT) {
        if (this.currentPath.isDone()) {
            this.currentPath = this.getNextPath();
        }
        else {
            if (this.atkIfPathBlocked()) {
                return;
            }
            else {
                this.owner.moveOnPath(this.speed * deltaT, this.currentPath);
            }
        }
    }
    getNextPath() {
        let stack = new Stack_1.default();
        this.findPath();
        stack.push(this.path[this.routeIndex]);
        let path = new NavigationPath_1.default(stack);
        this.routeIndex = this.routeIndex + 1;
        return path;
    }
    atkIfPathBlocked() {
        const rotation = Vec2_1.default.UP.angleToCCW(this.currentPath.getMoveDirection(this.owner));
        const tilePosition = this.floor.getColRowAt(this.owner.position);
        console.log(rotation);
        if ((rotation >= -0.5 && rotation < 0.7) || rotation > 5.5) {
            tilePosition.add(new Vec2_1.default(0, -1));
        }
        else if (rotation > 0.9 && rotation < 2.3) {
            tilePosition.add(new Vec2_1.default(-1, 0));
        }
        else if (rotation > 2.4 && rotation < 3.8) {
            tilePosition.add(new Vec2_1.default(0, 1));
        }
        else if (rotation > 4 && rotation < 5.4) {
            tilePosition.add(new Vec2_1.default(1, 0));
        }
        else {
            console.log("Moving in impossible ways");
            return false;
        }
        if (this.aliveTurrets.some((e) => this.floor.getColRowAt(e.position).equals(tilePosition))) {
            this.atk.attack(this, this.aliveTurrets.find((e) => this.floor.getColRowAt(e.position).equals(tilePosition)).ai);
        }
        else if (this.aliveWalls.some((e) => this.floor.getColRowAt(e.position).equals(tilePosition))) {
            this.atk.attack(this, this.aliveWalls.find((e) => this.floor.getColRowAt(e.position).equals(tilePosition)).ai);
        }
        else {
            return false;
        }
    }
    findPath() {
        const turnpoint = new Vec2_1.default(this.SpawnPos.x, this.BasePos.y);
        this.path.push(turnpoint.clone());
        this.path.push(this.BasePos.clone());
        return;
    }
    update(deltaT) {
        if (!this.path.length) {
            this.findPath();
        }
        else {
            this.moveOnePath(deltaT);
        }
    }
    addEffect(effect) {
        for (let i = 0; i < this.effects.length; i++) {
            const curr = this.effects[i];
            if (curr.type === effect.type && curr.isActive() && curr.equal(effect)) {
                curr.refreshEffect();
                return;
            }
        }
        this.effects.push(effect);
        effect.applyEffect();
    }
    destroy() {
        throw new Error("Method not implemented.");
    }
    handleEvent(event) {
        throw new Error("Method not implemented.");
    }
}
exports.default = EnemyAI;
var EnemyStates;
(function (EnemyStates) {
    EnemyStates["DEFAULT"] = "default";
})(EnemyStates = exports.EnemyStates || (exports.EnemyStates = {}));

},{"../../Wolfie2D/DataTypes/Stack":16,"../../Wolfie2D/DataTypes/Vec2":18,"../../Wolfie2D/Events/Emitter":21,"../../Wolfie2D/Pathfinding/NavigationPath":52,"../../Wolfie2D/Utils/Color":93,"../GameSystems/Attack/PointAttack":102,"../GameSystems/AttackAnimation/SliceAnimation":105}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const Emitter_1 = require("../../Wolfie2D/Events/Emitter");
const Color_1 = require("../../Wolfie2D/Utils/Color");
const PointAttack_1 = require("../GameSystems/Attack/PointAttack");
const BulletAnimation_1 = require("../GameSystems/AttackAnimation/BulletAnimation");
class TurretAI {
    constructor() {
        this.range = 300;
        this.emitter = new Emitter_1.default();
    }
    damage(damage) {
        this.health -= damage;
        if (this.health <= 0) {
            this.owner.setAIActive(false, {});
            this.owner.isCollidable = false;
            this.owner.visible = false;
            this.emitter.fireEvent("turretDied", { owner: this.owner });
        }
    }
    initializeAI(owner, options) {
        this.owner = owner;
        this.health = 20;
        this.owner.animation.playIfNotAlready('IDLE', true);
        this.atk = new PointAttack_1.default(10, 1000, new BulletAnimation_1.BulletAnimation(Color_1.default.YELLOW), {}, options.battleManager);
    }
    destroy() {
        throw new Error("Method not implemented.");
    }
    activate(options) {
        throw new Error("Method not implemented.");
    }
    handleEvent(event) {
    }
    update(deltaT) {
        this.target = this.owner.getScene().findEnemyInRange(this.owner.position, this.range);
        if (this.target) {
            const lookDir = this.owner.position.dirTo(this.target.owner.position);
            this.atk.attack(this, this.target);
            this.owner.rotation = Vec2_1.default.UP.angleToCCW(lookDir);
        }
    }
    upgrade() {
        throw new Error("Method not implemented.");
    }
    addEffect(effect) {
        for (let i = 0; i < this.effects.length; i++) {
            const curr = this.effects[i];
            if (curr.type === effect.type && curr.isActive() && curr.equal(effect)) {
                curr.refreshEffect();
                return;
            }
        }
        this.effects.push(effect);
        effect.applyEffect();
    }
    removeEffect(id) {
        this.effects = this.effects.filter((e) => e.id !== id);
    }
}
exports.default = TurretAI;

},{"../../Wolfie2D/DataTypes/Vec2":18,"../../Wolfie2D/Events/Emitter":21,"../../Wolfie2D/Utils/Color":93,"../GameSystems/Attack/PointAttack":102,"../GameSystems/AttackAnimation/BulletAnimation":104}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NEIGHBOR = void 0;
const Emitter_1 = require("../../Wolfie2D/Events/Emitter");
const constants_1 = require("../constants");
var NEIGHBOR;
(function (NEIGHBOR) {
    NEIGHBOR[NEIGHBOR["LEFT"] = 0] = "LEFT";
    NEIGHBOR[NEIGHBOR["RIGHT"] = 1] = "RIGHT";
    NEIGHBOR[NEIGHBOR["TOP"] = 2] = "TOP";
    NEIGHBOR[NEIGHBOR["BOT"] = 3] = "BOT";
})(NEIGHBOR = exports.NEIGHBOR || (exports.NEIGHBOR = {}));
class WallAI {
    constructor() {
        this.neighboringWall = new Array(4);
        this.emitter = new Emitter_1.default();
    }
    damage(damage) {
        this.health -= damage;
        if (this.health <= 0) {
            this.owner.setAIActive(false, {});
            this.owner.isCollidable = false;
            this.owner.visible = false;
            this.emitter.fireEvent("wallDied", { owner: this.owner });
        }
    }
    initializeAI(owner, options) {
        this.owner = owner;
        this.health = 100;
        this.type = constants_1.WALL_TYPE.DIRT;
        this.neighboringWall[NEIGHBOR.LEFT] = options.leftTile;
        this.neighboringWall[NEIGHBOR.RIGHT] = options.rightTile;
        this.neighboringWall[NEIGHBOR.TOP] = options.topTile;
        this.neighboringWall[NEIGHBOR.BOT] = options.botTile;
        this.neighborNum = this.neighboringWall.filter((e) => !!e).length;
        this.updateShape();
    }
    addNeighbor(w, dir) {
        this.neighboringWall[dir] = w;
        this.neighborNum++;
        this.updateShape();
    }
    delNeighbor(dir) {
        this.neighboringWall[dir] = null;
        this.neighborNum--;
        this.updateShape();
    }
    updateShape() {
        const newShape = WallAI.getWallShape(this.neighboringWall[NEIGHBOR.LEFT], this.neighboringWall[NEIGHBOR.RIGHT], this.neighboringWall[NEIGHBOR.BOT], this.neighboringWall[NEIGHBOR.TOP], this.neighborNum);
        this.shape = newShape;
        this.owner.animation.play(`${this.type}_${newShape}`, true);
    }
    upgrade() {
        switch (this.type) {
            case constants_1.WALL_TYPE.DIRT:
                this.type = constants_1.WALL_TYPE.WOOD;
                this.health = 2 * 100;
                break;
            case constants_1.WALL_TYPE.WOOD:
                this.type = constants_1.WALL_TYPE.STONE;
                this.health = 3 * 100;
                break;
            case constants_1.WALL_TYPE.STONE:
                this.type = constants_1.WALL_TYPE.FIBER;
                this.health = 4 * 100;
                break;
            case constants_1.WALL_TYPE.FIBER:
        }
        this.owner.animation.play(`${this.type}_${this.shape}`, true);
    }
    destroy() {
        throw new Error("Method not implemented.");
    }
    activate(options) {
        throw new Error("Method not implemented.");
    }
    handleEvent(event) {
        throw new Error("Method not implemented.");
    }
    update(deltaT) {
    }
    addEffect(effect) {
        throw new Error("Method not implemented.");
    }
    removeEffect(id) {
        this.effects = this.effects.filter((e) => e.id !== id);
    }
    static getWallShape(left, right, bot, top, num) {
        if (num === 4) {
            return 'CROSSROAD';
        }
        if (num === 3) {
            if (!left)
                return 'RTRI';
            if (!right)
                return 'LTRI';
            if (!top)
                return 'BTRI';
            if (!bot)
                return 'TTRI';
        }
        if (num === 2) {
            if (!left && !right)
                return 'VERTICAL';
            if (!top && !bot)
                return 'HORIZONTAL';
            if (!left && !top)
                return 'RBTURN';
            if (!left && !bot)
                return 'RTTURN';
            if (!right && !top)
                return 'LBTURN';
            if (!right && !bot)
                return 'LTTURN';
        }
        if (num === 1) {
            if (left || right)
                return 'HORIZONTAL';
            if (top || bot)
                return 'VERTICAL';
        }
        return 'HORIZONTAL';
    }
}
exports.default = WallAI;

},{"../../Wolfie2D/Events/Emitter":21,"../constants":114}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Timer_1 = require("../../../Wolfie2D/Timing/Timer");
const BulletAnimation_1 = require("../AttackAnimation/BulletAnimation");
const SliceAnimation_1 = require("../AttackAnimation/SliceAnimation");
class PointAttack {
    constructor(damage, cooldown, atkAnimation, effects, battleManager) {
        this.effects = effects;
        this.damage = damage;
        this.cooldownTimer = new Timer_1.default(cooldown);
        this.atkAnimation = atkAnimation;
        this.battleManager = battleManager;
    }
    attack(from, to) {
        if (!this.cooldownTimer.isStopped()) {
            return false;
        }
        this.assets = this.atkAnimation.createRequiredAssets(from.owner.getScene());
        console.log(this.assets);
        if (this.atkAnimation instanceof BulletAnimation_1.BulletAnimation) {
            this.atkAnimation.doAnimation(from.owner.position, to.owner.position, this.assets[0]);
        }
        else if (this.atkAnimation instanceof SliceAnimation_1.SliceAnimation) {
            this.atkAnimation.doAnimation(from.owner.position, from.owner.position.dirTo(to.owner.position), this.assets[0], from.owner.rotation);
        }
        this.battleManager.handlePointAtk(to, this.damage, this.effects);
        this.cooldownTimer.start();
    }
}
exports.default = PointAttack;

},{"../../../Wolfie2D/Timing/Timer":91,"../AttackAnimation/BulletAnimation":104,"../AttackAnimation/SliceAnimation":105}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class AtkAnimation {
}
exports.default = AtkAnimation;

},{}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BulletAnimation = void 0;
const Vec2_1 = require("../../../Wolfie2D/DataTypes/Vec2");
const GameNode_1 = require("../../../Wolfie2D/Nodes/GameNode");
const GraphicTypes_1 = require("../../../Wolfie2D/Nodes/Graphics/GraphicTypes");
const EaseFunctions_1 = require("../../../Wolfie2D/Utils/EaseFunctions");
const constants_1 = require("../../constants");
const AtkAnimation_1 = require("./AtkAnimation");
class BulletAnimation extends AtkAnimation_1.default {
    constructor(color) {
        super();
        this.color = color;
    }
    doAnimation(from, to, line) {
        line.start = from;
        line.end = to;
        line.tweens.play("fade");
    }
    createRequiredAssets(scene) {
        let line = scene.add.graphic(GraphicTypes_1.GraphicType.LINE, "primary", { start: new Vec2_1.default(-1, 1), end: new Vec2_1.default(-1, -1) });
        line.color = this.color;
        line.tweens.add("fade", {
            startDelay: 0,
            duration: 300,
            effects: [
                {
                    property: GameNode_1.TweenableProperties.alpha,
                    start: 1,
                    end: 0,
                    ease: EaseFunctions_1.EaseFunctionType.OUT_SINE
                }
            ],
            onEnd: constants_1.XENO_EVENTS.UNLOAD_ASSET
        });
        return [line];
    }
    clone() {
        return new BulletAnimation(this.color);
    }
}
exports.BulletAnimation = BulletAnimation;

},{"../../../Wolfie2D/DataTypes/Vec2":18,"../../../Wolfie2D/Nodes/GameNode":34,"../../../Wolfie2D/Nodes/Graphics/GraphicTypes":36,"../../../Wolfie2D/Utils/EaseFunctions":94,"../../constants":114,"./AtkAnimation":103}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SliceAnimation = void 0;
const Vec2_1 = require("../../../Wolfie2D/DataTypes/Vec2");
const AtkAnimation_1 = require("./AtkAnimation");
class SliceAnimation extends AtkAnimation_1.default {
    constructor(color) {
        super();
        this.color = color;
    }
    doAnimation(from, direction, sliceSprite, rotation) {
        // sliceSprite.rotation = rotation;
        sliceSprite.position = from.clone().add(new Vec2_1.default(16, 16));
        sliceSprite.animation.play("SLICE");
        sliceSprite.animation.queue("NORMAL", true);
    }
    createRequiredAssets(scene) {
        let slice = scene.add.animatedSprite("slice", "primary");
        slice.animation.play("NORMAL", true);
        console.log(slice);
        return [slice];
    }
    clone() {
        return new SliceAnimation(this.color);
    }
}
exports.SliceAnimation = SliceAnimation;

},{"../../../Wolfie2D/DataTypes/Vec2":18,"./AtkAnimation":103}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const AcidEffect_1 = require("./Effect/AcidEffect");
const FireEffec_1 = require("./Effect/FireEffec");
const SlowEffect_1 = require("./Effect/SlowEffect");
class BattleManager {
    handlePointAtk(to, dmg, effects) {
        to.damage(dmg);
        BattleManager.addEffects(effects, to);
    }
    handleAOEAtk(from, r, dmg, effects, atkerType) {
        const r2 = r * r;
        switch (atkerType) {
            case constants_1.XENO_ATKER_TYPE.ENEMY:
                this.turrets
                    .filter((t) => from.distanceSqTo(t.position) <= r2)
                    .forEach((t) => {
                    const target = t.ai;
                    target.damage(dmg);
                    BattleManager.addEffects(effects, target);
                });
                this.walls
                    .filter((w) => from.distanceSqTo(w.position) <= r2)
                    .forEach((w) => {
                    const target = w.ai;
                    target.damage(dmg);
                    BattleManager.addEffects(effects, target);
                });
                break;
            case constants_1.XENO_ATKER_TYPE.FRIEND:
                this.enemies
                    .filter((e) => from.distanceSqTo(e.position) <= r2)
                    .forEach((e) => {
                    const target = e.ai;
                    target.damage(dmg);
                    BattleManager.addEffects(effects, target);
                });
        }
    }
    static addEffects(data, target) {
        if (data.fire) {
            target.addEffect(new FireEffec_1.FireEffect(data.fire.duration, data.fire.ticks, target));
        }
        if (data.slow) {
            target.addEffect(new SlowEffect_1.SlowEffect(data.slow.duration, data.slow.percent, target));
        }
        if (data.acid) {
            target.addEffect(new AcidEffect_1.AcidEffect(data.acid.duration, data.acid.reduction, target));
        }
    }
}
exports.default = BattleManager;

},{"../constants":114,"./Effect/AcidEffect":107,"./Effect/FireEffec":109,"./Effect/SlowEffect":110}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AcidEffect = void 0;
const Timer_1 = require("../../../Wolfie2D/Timing/Timer");
const constants_1 = require("../../constants");
const Effect_1 = require("./Effect");
class AcidEffect extends Effect_1.Effect {
    constructor(duration, reduction, target) {
        super();
        this.type = constants_1.XENO_EFFECT_TYPE.ACID_EFFECT;
        this.target = target;
        this.reduction = reduction;
        this.durationTimer = new Timer_1.default(duration, this.endEffect);
    }
    applyEffect() {
        this.target.armor -= this.reduction;
        this.durationTimer.start();
    }
    endEffect() {
        this.target.armor += this.reduction;
    }
    refreshEffect() {
        this.durationTimer.reset();
    }
    isActive() {
        return !this.durationTimer.isStopped();
    }
    equal(e) {
        return this.duration === e.duration && this.reduction === e.reduction;
    }
}
exports.AcidEffect = AcidEffect;

},{"../../../Wolfie2D/Timing/Timer":91,"../../constants":114,"./Effect":108}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Effect = void 0;
const Emitter_1 = require("../../../Wolfie2D/Events/Emitter");
class Effect {
    constructor() {
        this.id = Math.floor(Date.now() + Math.random());
        this.emitter = new Emitter_1.default();
    }
}
exports.Effect = Effect;

},{"../../../Wolfie2D/Events/Emitter":21}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FireEffect = void 0;
const Timer_1 = require("../../../Wolfie2D/Timing/Timer");
const constants_1 = require("../../constants");
const Effect_1 = require("./Effect");
class FireEffect extends Effect_1.Effect {
    constructor(duration, ticks, target) {
        super();
        this.type = constants_1.XENO_EFFECT_TYPE.FIRE_EFFECT;
        this.target = target;
        this.durationTimer = new Timer_1.default(duration, this.endEffect);
        this.dotTimer = new Timer_1.default(duration / ticks, this.dot, true);
    }
    applyEffect() {
        this.dotTimer.start();
        this.durationTimer.start();
    }
    dot() {
        this.target.damage(this.damage);
    }
    endEffect() {
        this.dotTimer.pause();
    }
    refreshEffect() {
        this.durationTimer.reset();
    }
    isActive() {
        return !this.durationTimer.isStopped();
    }
    equal(e) {
        return e.duration === this.duration && e.damage === this.damage && e.ticks === this.ticks;
    }
}
exports.FireEffect = FireEffect;

},{"../../../Wolfie2D/Timing/Timer":91,"../../constants":114,"./Effect":108}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlowEffect = void 0;
const Timer_1 = require("../../../Wolfie2D/Timing/Timer");
const constants_1 = require("../../constants");
const Effect_1 = require("./Effect");
class SlowEffect extends Effect_1.Effect {
    constructor(duration, percent, target) {
        super();
        this.type = constants_1.XENO_EFFECT_TYPE.SLOW_EFFECT;
        this.target = target;
        this.durationTimer = new Timer_1.default(duration, this.dotTimer.pause);
    }
    applyEffect() {
        this.target.speed *= this.percent;
        this.durationTimer.start();
    }
    endEffect() {
        this.target.speed /= this.percent;
        this.durationTimer.pause();
        delete this.durationTimer;
    }
    refreshEffect() {
        this.durationTimer.reset();
    }
    isActive() {
        return !this.durationTimer.isStopped();
    }
    equal(e) {
        if (e.type === this.type) {
            return this.duration === e.duration && this.percent === e.percent;
        }
    }
}
exports.SlowEffect = SlowEffect;

},{"../../../Wolfie2D/Timing/Timer":91,"../../constants":114,"./Effect":108}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
const Scene_1 = require("../../Wolfie2D/Scene/Scene");
const Color_1 = require("../../Wolfie2D/Utils/Color");
const constants_1 = require("../constants");
const xeno_level_1 = require("./xeno_level");
const PADDING = 100;
const PassiveGrey = new Color_1.default(196, 196, 196);
const ActiveGrey = new Color_1.default(229, 229, 229);
class MainMenu extends Scene_1.default {
    loadScene() {
        this.load.image("background", "xeno_assets/images/background.png");
        this.load.image("leftclick", "xeno_assets/images/light/mouse_left_key_light.png");
        this.load.image("ESC", "xeno_assets/images/light/esc_key_light.png");
        this.load.image("semicolon", "xeno_assets/images/light/semicolon_key_light.png");
        this.load.image("quote", "xeno_assets/images/light/quote_ley_light.png");
    }
    startScene() {
        const center = this.viewport.getCenter();
        // The main menu
        this.main = this.addUILayer("main");
        this.control = this.addUILayer("control");
        this.help = this.addUILayer("help");
        this.chapter = this.addUILayer("chapter");
        this.control.setHidden(true);
        this.help.setHidden(true);
        this.chapter.setHidden(true);
        this.receiver.subscribe('main');
        this.receiver.subscribe('control');
        this.receiver.subscribe('help');
        this.receiver.subscribe('chapter');
        this.receiver.subscribe('chapter1_1');
        this.receiver.subscribe('chapter1_1');
        this.receiver.subscribe('chapter2_1');
        this.receiver.subscribe('chapter2_2');
        this.receiver.subscribe('chapter3_1');
        this.receiver.subscribe('chapter3_2');
        const mainBackground = this.add.sprite("background", "main");
        mainBackground.position.copy(center);
        const controlBackground = this.add.sprite("background", "control");
        controlBackground.position.copy(center);
        const helpBackground = this.add.sprite("background", "help");
        helpBackground.position.copy(center);
        const chapterBackground = this.add.sprite("background", "chapter");
        chapterBackground.position.copy(center);
        const titlePosition = { x: constants_1.CANVAS_SIZE.x / 4, y: 2 * PADDING };
        /* ------------------------------- MAIN LAYER ------------------------------ */
        const mainTitleLine = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "main", { position: new Vec2_1.default(titlePosition.x, titlePosition.y), text: "XENO" });
        mainTitleLine.textColor = Color_1.default.BLACK;
        mainTitleLine.fontSize = 78;
        const chapterBtn = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "main", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.75, 4 * PADDING), text: 'CHAPTER' });
        chapterBtn.borderColor = chapterBtn.backgroundColor = PassiveGrey;
        chapterBtn.size.set(200, 50);
        chapterBtn.onClickEventId = "chapter";
        const controlBtn = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "main", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.75, 5 * PADDING), text: 'CONTROL' });
        controlBtn.borderColor = controlBtn.backgroundColor = PassiveGrey;
        controlBtn.size.set(200, 50);
        controlBtn.onClickEventId = "control";
        const helpBtn = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "main", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.75, 6 * PADDING), text: 'HELP' });
        helpBtn.borderColor = helpBtn.backgroundColor = PassiveGrey;
        helpBtn.size.set(200, 50);
        helpBtn.onClickEventId = "help";
        /* ------------------------------ CHAPTER LAYER ----------------------------- */
        const chapterTitleLine = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "chapter", { position: new Vec2_1.default(titlePosition.x, titlePosition.y), text: "CHAPTERS" });
        chapterTitleLine.textColor = Color_1.default.BLACK;
        chapterTitleLine.fontSize = 78;
        const chapter1_1Btn = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "chapter", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.25, 4 * PADDING), text: '1-1' });
        chapter1_1Btn.borderColor = chapter1_1Btn.backgroundColor = PassiveGrey;
        chapter1_1Btn.size.set(100, 100);
        chapter1_1Btn.onClickEventId = "chapter1_1";
        const chapter1_2Btn = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "chapter", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.25, 6 * PADDING), text: '1-2' });
        chapter1_2Btn.borderColor = chapter1_2Btn.backgroundColor = PassiveGrey;
        chapter1_2Btn.size.set(100, 100);
        chapter1_2Btn.onClickEventId = "chapter1_2";
        const chapter2_1Btn = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "chapter", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.5, 4 * PADDING), text: '2-1' });
        chapter2_1Btn.borderColor = chapter2_1Btn.backgroundColor = PassiveGrey;
        chapter2_1Btn.size.set(100, 100);
        chapter2_1Btn.onClickEventId = "chapter2_1";
        const chapter2_2Btn = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "chapter", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.5, 6 * PADDING), text: '2-2' });
        chapter2_2Btn.borderColor = chapter2_2Btn.backgroundColor = PassiveGrey;
        chapter2_2Btn.size.set(100, 100);
        chapter2_2Btn.onClickEventId = "chapter2_2";
        const chapter3_1Btn = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "chapter", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.75, 4 * PADDING), text: '3-1' });
        chapter3_1Btn.borderColor = chapter3_1Btn.backgroundColor = PassiveGrey;
        chapter3_1Btn.size.set(100, 100);
        chapter3_1Btn.onClickEventId = "chapter3_1";
        const chapter3_2Btn = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "chapter", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.75, 6 * PADDING), text: '3-2' });
        chapter3_2Btn.borderColor = chapter3_2Btn.backgroundColor = PassiveGrey;
        chapter3_2Btn.size.set(100, 100);
        chapter3_2Btn.onClickEventId = "chapter3_2";
        const chapterBackBtn = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "chapter", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.9, 8 * PADDING), text: 'BACK' });
        chapterBackBtn.borderColor = chapterBackBtn.backgroundColor = ActiveGrey;
        chapterBackBtn.size.set(200, 50);
        chapterBackBtn.onClickEventId = "main";
        /* ------------------------------ CONTROL LAYER ----------------------------- */
        const controlTitleLine = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "control", { position: new Vec2_1.default(titlePosition.x, titlePosition.y), text: "COTNROL" });
        controlTitleLine.textColor = Color_1.default.BLACK;
        controlTitleLine.fontSize = 78;
        const leftclick = this.add.sprite("leftclick", "control");
        leftclick.position = new Vec2_1.default(titlePosition.x, 4 * PADDING);
        const leftclickLine1 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "control", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.55, 4 * PADDING), text: 'Leftclick to interact with the in game UI.' });
        leftclickLine1.backgroundColor = leftclickLine1.borderColor = Color_1.default.TRANSPARENT;
        leftclickLine1.fontSize = 40;
        leftclickLine1.textColor = Color_1.default.BLACK;
        const leftclickLine2 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "control", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.6, 4.5 * PADDING), text: 'Click on existing turrets/walls/traps to upgrade them.' });
        leftclickLine2.backgroundColor = leftclickLine2.borderColor = Color_1.default.TRANSPARENT;
        leftclickLine2.fontSize = 40;
        leftclickLine2.textColor = Color_1.default.BLACK;
        const ESC = this.add.sprite("ESC", "control");
        ESC.position = new Vec2_1.default(titlePosition.x, 6 * PADDING);
        const ESCLine = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "control", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.6, 6 * PADDING), text: 'Pause the game while in game and acess the pause menu' });
        ESCLine.backgroundColor = ESCLine.borderColor = Color_1.default.TRANSPARENT;
        ESCLine.fontSize = 40;
        ESCLine.textColor = Color_1.default.BLACK;
        const controlBackBtn = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "control", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.9, 8 * PADDING), text: 'BACK' });
        controlBackBtn.borderColor = controlBackBtn.backgroundColor = ActiveGrey;
        controlBackBtn.size.set(200, 50);
        controlBackBtn.onClickEventId = "main";
        /* ------------------------------- HELP LAYER ------------------------------- */
        const helpTitleLine = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", { position: new Vec2_1.default(titlePosition.x, titlePosition.y), text: "HELP" });
        helpTitleLine.textColor = Color_1.default.BLACK;
        helpTitleLine.fontSize = 78;
        const helpDeveLine = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", { position: new Vec2_1.default(center.x, 3 * PADDING), text: "Xeno is developed by Chencheng Yang, Hongcheng Li, and XXX" });
        const helpStoryLine1 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", { position: new Vec2_1.default(center.x, 4 * PADDING), text: "Your are part of the intergalactic explorers, \"Xeno\"" });
        const helpStoryLine2 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", { position: new Vec2_1.default(center.x, 4.5 * PADDING), text: "Utilize your resource to build up a fortress and defend against the vicious UMAs" });
        const helpStoryLine3 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", { position: new Vec2_1.default(center.x, 5 * PADDING), text: "Don't let your guard down or you will be eaten alive " });
        const semicolon = this.add.sprite("semicolon", "help");
        semicolon.position = new Vec2_1.default(titlePosition.x, 6 * PADDING);
        const semicolonLine = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.6, 6 * PADDING), text: 'Infinite Money' });
        semicolonLine.backgroundColor = semicolonLine.borderColor = Color_1.default.TRANSPARENT;
        semicolonLine.fontSize = 40;
        semicolonLine.textColor = Color_1.default.BLACK;
        const quote = this.add.sprite("quote", "help");
        quote.position = new Vec2_1.default(titlePosition.x, 7 * PADDING);
        const quoteLine = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "help", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.6, 7 * PADDING), text: 'Infinite Health' });
        quoteLine.backgroundColor = quoteLine.borderColor = Color_1.default.TRANSPARENT;
        quoteLine.fontSize = 40;
        quoteLine.textColor = Color_1.default.BLACK;
        const helpBackBtn = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "help", { position: new Vec2_1.default(constants_1.CANVAS_SIZE.x * 0.9, 8 * PADDING), text: 'BACK' });
        helpBackBtn.borderColor = helpBackBtn.backgroundColor = ActiveGrey;
        helpBackBtn.size.set(200, 50);
        helpBackBtn.onClickEventId = "main";
    }
    updateScene() {
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            console.log(event);
            switch (event.type) {
                case "main":
                    this.switchScene('main');
                    break;
                case "chapter":
                    this.switchScene('chapter');
                    break;
                case "control":
                    this.switchScene('control');
                    break;
                case "help":
                    this.switchScene('help');
                    break;
                case "chapter1_1":
                    this.sceneManager.changeToScene(xeno_level_1.default);
            }
        }
    }
    switchScene(name) {
        const names = ['main', 'control', 'help', 'chapter'];
        names.forEach((e) => {
            if (e === name) {
                this.getLayer(e).setHidden(false);
            }
            else {
                this.getLayer(e).setHidden(true);
            }
        });
    }
}
exports.default = MainMenu;

},{"../../Wolfie2D/DataTypes/Vec2":18,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":50,"../../Wolfie2D/Scene/Scene":84,"../../Wolfie2D/Utils/Color":93,"../constants":114,"./xeno_level":113}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const Input_1 = require("../../Wolfie2D/Input/Input");
const UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
const Scene_1 = require("../../Wolfie2D/Scene/Scene");
const Color_1 = require("../../Wolfie2D/Utils/Color");
const MainMenu_1 = require("./MainMenu");
const COLOR_SALMON = new Color_1.default(250, 128, 114);
class SplashScreen extends Scene_1.default {
    loadScene() {
        this.load.image("logo", "xeno_assets/images/logo.png");
    }
    unloadScene() {
        this.resourceManager.unloadAllResources();
    }
    startScene() {
        this.splashScreen = this.addUILayer("splashScreen");
        // Add logo
        const center = this.viewport.getCenter();
        const logo = this.add.sprite("logo", "splashScreen");
        const startText = "Press Leftclick To Start";
        const startLine = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "splashScreen", { position: new Vec2_1.default(center.x, center.y + 400), text: startText });
        // Salmon 
        startLine.textColor = COLOR_SALMON;
        startLine.fontSize = 64;
        logo.position.copy(center);
    }
    updateScene(deltaT) {
        if (Input_1.default.isMouseJustPressed(0)) {
            this.sceneManager.changeToScene(MainMenu_1.default, {});
        }
    }
}
exports.default = SplashScreen;

},{"../../Wolfie2D/DataTypes/Vec2":18,"../../Wolfie2D/Input/Input":26,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":50,"../../Wolfie2D/Scene/Scene":84,"../../Wolfie2D/Utils/Color":93,"./MainMenu":111}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AABB_1 = require("../../Wolfie2D/DataTypes/Shapes/AABB");
const Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
const Input_1 = require("../../Wolfie2D/Input/Input");
const UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
const Scene_1 = require("../../Wolfie2D/Scene/Scene");
const Color_1 = require("../../Wolfie2D/Utils/Color");
const EnemyAI_1 = require("../AI/EnemyAI");
const TurretAI_1 = require("../AI/TurretAI");
const WallAI_1 = require("../AI/WallAI");
const constants_1 = require("../constants");
const BattleManager_1 = require("../GameSystems/BattleManager");
let idCounter = 0;
class xeno_level extends Scene_1.default {
    constructor() {
        super(...arguments);
        this.placingMode = "WALL";
        this.deadWalls = new Array();
        this.deadTraps = new Array();
        this.deadTurrets = new Array();
        this.deadEnemies = new Array();
        this.aliveWalls = new Array();
        this.aliveTraps = new Array();
        this.aliveTurrets = new Array();
        this.aliveEnemies = new Array();
        this.battleManager = new BattleManager_1.default();
    }
    loadScene() {
        this.load.tilemap("level", "xeno_assets/map/test_map.json");
        this.load.spritesheet("base", "xeno_assets/spritesheets/generator.json");
        this.load.spritesheet("walls", "xeno_assets/spritesheets/walls.json");
        this.load.spritesheet("traps", "xeno_assets/spritesheets/traps.json");
        this.load.spritesheet("turret", "xeno_assets/spritesheets/turret_simple.json");
        this.load.spritesheet("UMA", "xeno_assets/spritesheets/uma.json");
        this.load.spritesheet("slice", "hw4_assets/spritesheets/slice.json");
        this.load.image("Drawing", "xeno_assets/images/drawing.png");
    }
    startScene() {
        const Slot1 = new Vec2_1.default(1455, 210);
        const Slot2 = new Vec2_1.default(1555, 210);
        const Slot3 = new Vec2_1.default(1455, 340);
        const Slot4 = new Vec2_1.default(1555, 340);
        const Slot5 = new Vec2_1.default(1455, 460);
        const Slot6 = new Vec2_1.default(1555, 460);
        const Slot7 = new Vec2_1.default(1455, 590);
        const Slot8 = new Vec2_1.default(1555, 590);
        const Slot9 = new Vec2_1.default(1455, 710);
        const Slot10 = new Vec2_1.default(1555, 710);
        const SlotMoney = new Vec2_1.default(1500, 40);
        const SlotStatus = new Vec2_1.default(1460, 120);
        const center = this.viewport.getCenter();
        let tilemapLayers = this.add.tilemap("level", new Vec2_1.default(1, 1));
        this.UI = this.addUILayer("UI");
        const Drawing = this.add.sprite("Drawing", "UI");
        Drawing.position.copy(center);
        const MoneyLabel = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "UI", { position: SlotMoney, text: "00000" });
        const StatusLabel = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "UI", { position: SlotStatus, text: "Status" });
        this.errorLabel = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "UI", { position: new Vec2_1.default(700, 200), text: '' });
        this.errorLabel.textColor = Color_1.default.RED;
        this.floor = tilemapLayers[1].getItems()[0];
        let tilemapSize = this.floor.size.scaled(1);
        this.viewport.setBounds(0, 0, tilemapSize.x, tilemapSize.y);
        this.addLayer("primary", 10);
        this.placebase(new Vec2_1.default(672, 352));
        this.viewport.setZoomLevel(1);
        this.receiver.subscribe([
            'turretDied',
            'enemyDied',
            'wallDied',
            'gameOver',
            constants_1.XENO_EVENTS.UNLOAD_ASSET,
            constants_1.XENO_EVENTS.ERROR
        ]);
    }
    handleEvent(event) {
        switch (event.type) {
            case constants_1.XENO_EVENTS.UNLOAD_ASSET:
                const asset = this.sceneGraph.getNode(event.data.get("node"));
                asset.destroy();
                break;
            case constants_1.XENO_EVENTS.ERROR:
                console.log("ERROR");
                this.errorLabel.text = event.data.get('message');
                break;
            case constants_1.XENO_EVENTS.TURRET_DIED:
                const deadTurret = event.data.get('owner');
                this.aliveTurrets = this.aliveTurrets.filter((e) => e.id != deadTurret.id);
                this.deadTurrets.push(deadTurret);
                break;
            case constants_1.XENO_EVENTS.WALL_DIED:
                const deadWall = event.data.get('owner');
                this.updateNeighbors(deadWall);
                this.aliveWalls = this.aliveWalls.filter((e) => e.id != deadWall.id);
                this.deadWalls.push(deadWall);
                break;
            case constants_1.XENO_EVENTS.ENEMY_DIED:
                const deadEnemy = event.data.get('owner');
                this.aliveEnemies = this.aliveEnemies.filter((e) => e.id != deadEnemy.id);
                this.deadEnemies.push(deadEnemy);
                break;
            case constants_1.XENO_EVENTS.GAME_OVER:
        }
    }
    updateScene(deltaT) {
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            this.handleEvent(event);
        }
        if (Input_1.default.isKeyJustPressed('1')) {
            this.placingMode = 'WALL';
        }
        if (Input_1.default.isKeyJustPressed('2')) {
            this.placingMode = 'TURRET';
        }
        if (Input_1.default.isKeyJustPressed('3')) {
            this.placingMode = 'ENEMY';
        }
        if (Input_1.default.isKeyJustPressed('4')) {
            this.placingMode = 'TRAP';
        }
        if (Input_1.default.isMouseJustPressed(0) && Input_1.default.getGlobalMousePressPosition().clone().x < 1388) {
            if (this.isAnyOverlap(Input_1.default.getGlobalMousePosition().clone().add(new Vec2_1.default(16, 16)))) {
                this.emitter.fireEvent(constants_1.XENO_EVENTS.ERROR, { message: 'SPACE OCCUPIED' });
                return;
            }
            this.emitter.fireEvent(constants_1.XENO_EVENTS.ERROR, { message: '' });
            switch (this.placingMode) {
                case "WALL":
                    this.placeWall(Input_1.default.getGlobalMousePressPosition().clone());
                    break;
                case "TRAP":
                    break;
                case "TURRET":
                    this.placeTurret(Input_1.default.getGlobalMousePressPosition().clone());
                    break;
                case "ENEMY":
                    this.placeEnemey(Input_1.default.getGlobalMousePressPosition().clone());
            }
        }
        else if (Input_1.default.isMouseJustPressed(0)) {
            const clickPos = Input_1.default.getGlobalMousePressPosition().clone();
            console.log(clickPos);
            if (clickPos.x < 1500 && clickPos.x > 1410) {
                if (clickPos.y < 270 && clickPos.y > 170) {
                    console.log("1,1 SLOT1");
                }
                else if (clickPos.y < 400 && clickPos.y > 300) {
                    console.log("1,2 SLOT3");
                }
                else if (clickPos.y < 520 && clickPos.y > 420) {
                    console.log("1,3 SLOT5");
                }
                else if (clickPos.y < 650 && clickPos.y > 540) {
                    console.log("1,4 SLOT7");
                }
                else if (clickPos.y < 780 && clickPos.y > 680) {
                    console.log("1,5 SLOT9");
                }
                else if (clickPos.y < 880 && clickPos.y > 820) {
                    console.log("1,6 Pause");
                }
            }
            else if (clickPos.x < 1600 && clickPos.x > 1510) {
                if (clickPos.y < 270 && clickPos.y > 170) {
                    console.log("2,1 SLOT2");
                }
                else if (clickPos.y < 400 && clickPos.y > 300) {
                    console.log("2,2 SLOT4");
                }
                else if (clickPos.y < 520 && clickPos.y > 420) {
                    console.log("2,3 SLOT6");
                }
                else if (clickPos.y < 650 && clickPos.y > 540) {
                    console.log("2,4 SLOT8");
                }
                else if (clickPos.y < 780 && clickPos.y > 680) {
                    console.log("2,5 SLOT10");
                }
                else if (clickPos.y < 880 && clickPos.y > 820) {
                    console.log("2,6 Speed Up");
                }
            }
        }
    }
    isAnyOverlap(position) {
        const tilePosition = this.floor.getColRowAt(position);
        console.log(this.aliveWalls.some((e) => this.floor.getColRowAt(e.position).equals(tilePosition)));
        return this.aliveTurrets.some((e) => this.floor.getColRowAt(e.position).equals(tilePosition)) ||
            this.aliveWalls.some((e) => this.floor.getColRowAt(e.position).equals(tilePosition)) ||
            this.aliveTraps.some((e) => this.floor.getColRowAt(e.position).equals(tilePosition)) ||
            this.aliveEnemies.some((e) => this.floor.getColRowAt(e.position).equals(tilePosition));
    }
    placeTrap(position, type) {
        let trap = this.deadTraps.pop();
        if (!trap) {
            trap = this.add.animatedSprite('traps', 'primary');
            trap.setCollisionShape(new AABB_1.default(Vec2_1.default.ZERO, trap.sizeWithZoom));
        }
        trap.animation.playIfNotAlready('BRONZE_FROST', true);
        trap.position = this.floor.getColRowAt(position.add(new Vec2_1.default(16, 16))).mult(new Vec2_1.default(32, 32));
        trap.visible = true;
        this.aliveTraps.push(trap);
    }
    placebase(position) {
        let base;
        base = this.add.animatedSprite('base', 'primary');
        base.addAI(WallAI_1.default, {});
        base.setCollisionShape(new AABB_1.default(Vec2_1.default.ZERO, base.sizeWithZoom));
        const currColRow = this.floor.getColRowAt(position);
        base.ai.initializeAI(base, {
            leftTile: null,
            rightTile: null,
            botTile: null,
            topTile: null
        });
        base.ai.health = 1 << 30;
        base.position = currColRow.clone().mult(new Vec2_1.default(32, 32));
        base.visible = true;
        base.addPhysics();
        this.aliveWalls.push(base);
        base.animation.play("IDLE", true);
    }
    placeWall(position) {
        let wall = this.deadWalls.pop();
        console.log(this.aliveWalls);
        if (!wall) {
            wall = this.add.animatedSprite('walls', 'primary');
            wall.addAI(WallAI_1.default, {});
            wall.setCollisionShape(new AABB_1.default(Vec2_1.default.ZERO, wall.sizeWithZoom));
        }
        let leftTile = null, rightTile = null, topTile = null, botTile = null;
        position.add(new Vec2_1.default(16, 16));
        const currColRow = this.floor.getColRowAt(position);
        const leftTileColRow = currColRow.clone().add(new Vec2_1.default(-1, 0));
        const rightTileColRow = currColRow.clone().add(new Vec2_1.default(1, 0));
        const botTileColRow = currColRow.clone().add(new Vec2_1.default(0, 1));
        const topTileColRow = currColRow.clone().add(new Vec2_1.default(0, -1));
        this.aliveWalls.forEach((w) => {
            if (this.floor.getColRowAt(w.position).equals(leftTileColRow)) {
                leftTile = w;
                leftTile.ai.addNeighbor(wall, WallAI_1.NEIGHBOR.RIGHT);
                console.log(`LEFT TILE FOUND: ${leftTile}`);
            }
            if (this.floor.getColRowAt(w.position).equals(rightTileColRow)) {
                rightTile = w;
                rightTile.ai.addNeighbor(wall, WallAI_1.NEIGHBOR.LEFT);
                console.log(`RIGHT TILE FOUND: ${rightTile}`);
            }
            if (this.floor.getColRowAt(w.position).equals(botTileColRow)) {
                botTile = w;
                botTile.ai.addNeighbor(wall, WallAI_1.NEIGHBOR.TOP);
                console.log(`BOT TILE FOUND: ${botTile}`);
            }
            if (this.floor.getColRowAt(w.position).equals(topTileColRow)) {
                topTile = w;
                topTile.ai.addNeighbor(wall, WallAI_1.NEIGHBOR.BOT);
                console.log(`TOP TILE FOUND: ${topTile}`);
            }
        });
        wall.ai.initializeAI(wall, {
            leftTile: leftTile,
            rightTile: rightTile,
            botTile: botTile,
            topTile: topTile
        });
        wall.position = currColRow.clone().mult(new Vec2_1.default(32, 32));
        wall.visible = true;
        wall.addPhysics();
        this.aliveWalls.push(wall);
    }
    placeTurret(position) {
        let turret = this.deadTurrets.pop();
        const currColRow = this.floor.getColRowAt(position.add(new Vec2_1.default(16, 16)));
        if (!turret) {
            turret = this.add.animatedSprite("turret", "primary");
            turret.addAI(TurretAI_1.default, { battleManager: this.battleManager });
        }
        turret.position = currColRow.clone().mult(new Vec2_1.default(32, 32));
        turret.visible = true;
        turret.addPhysics();
        this.aliveTurrets.push(turret);
    }
    placeEnemey(position) {
        let enemy = this.deadEnemies.pop();
        const currColRow = this.floor.getColRowAt(position.add(new Vec2_1.default(16, 16)));
        if (!enemy) {
            enemy = this.add.animatedSprite("UMA", "primary");
            enemy.addAI(EnemyAI_1.default, { health: 30, BasePos: new Vec2_1.default(672, 352), SpawnPos: currColRow.clone().mult(new Vec2_1.default(32, 32)), aliveWalls: this.aliveWalls, aliveTurrets: this.aliveTurrets, floor: this.floor, battleManager: this.battleManager });
        }
        enemy.ai.health = 30;
        enemy.setAIActive(true, {});
        enemy.animation.playIfNotAlready("IDLE", true);
        enemy.position = currColRow.clone().mult(new Vec2_1.default(32, 32));
        enemy.visible = true;
        enemy.addPhysics();
        this.aliveEnemies.push(enemy);
    }
    updateNeighbors(wall) {
        const wallAI = wall.ai;
        wallAI.neighboringWall.forEach((w, i) => {
            if (w) {
                let dir = 0;
                switch (i) {
                    case WallAI_1.NEIGHBOR.LEFT:
                    case WallAI_1.NEIGHBOR.BOT:
                        dir = i + 1;
                        break;
                    case WallAI_1.NEIGHBOR.TOP:
                    case WallAI_1.NEIGHBOR.RIGHT:
                        dir = i - 1;
                        break;
                }
                w.ai.delNeighbor(dir);
            }
        });
    }
    findEnemyInRange(from, range) {
        if (!this.aliveEnemies.length)
            return undefined;
        for (let i = 0; i < this.aliveEnemies.length; i++) {
            if (from.distanceTo(this.aliveEnemies[i].position) < range) {
                return this.aliveEnemies[i].ai;
            }
        }
    }
}
exports.default = xeno_level;

},{"../../Wolfie2D/DataTypes/Shapes/AABB":13,"../../Wolfie2D/DataTypes/Vec2":18,"../../Wolfie2D/Input/Input":26,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":50,"../../Wolfie2D/Scene/Scene":84,"../../Wolfie2D/Utils/Color":93,"../AI/EnemyAI":99,"../AI/TurretAI":100,"../AI/WallAI":101,"../GameSystems/BattleManager":106,"../constants":114}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XENO_ATKER_TYPE = exports.XENO_EFFECT_TYPE = exports.XENO_EVENTS = exports.TRAP_TYPE = exports.WALL_TYPE = exports.CANVAS_SIZE = void 0;
exports.CANVAS_SIZE = {
    x: 1600,
    y: 900
};
var WALL_TYPE;
(function (WALL_TYPE) {
    WALL_TYPE["DIRT"] = "DIRT";
    WALL_TYPE["WOOD"] = "WOOD";
    WALL_TYPE["STONE"] = "STONE";
    WALL_TYPE["FIBER"] = "FIBER";
})(WALL_TYPE = exports.WALL_TYPE || (exports.WALL_TYPE = {}));
var TRAP_TYPE;
(function (TRAP_TYPE) {
    TRAP_TYPE["ACID"] = "ACID";
    TRAP_TYPE["NET"] = "NET";
    TRAP_TYPE["FROST"] = "FROST";
    TRAP_TYPE["FLAME"] = "FLAME";
})(TRAP_TYPE = exports.TRAP_TYPE || (exports.TRAP_TYPE = {}));
var XENO_EVENTS;
(function (XENO_EVENTS) {
    XENO_EVENTS["ERROR"] = "ERROR";
    XENO_EVENTS["UNLOAD_ASSET"] = "UNLOAD_ASSET";
    XENO_EVENTS["WALL_DIED"] = "WALL_DIED";
    XENO_EVENTS["ENEMY_DIED"] = "ENEMY_DIED";
    XENO_EVENTS["TURRET_DIED"] = "TURRET_DIED";
    XENO_EVENTS["GAME_OVER"] = "GAME_OVER";
    XENO_EVENTS["UPGRADE"] = "UPGRADE";
})(XENO_EVENTS = exports.XENO_EVENTS || (exports.XENO_EVENTS = {}));
var XENO_EFFECT_TYPE;
(function (XENO_EFFECT_TYPE) {
    XENO_EFFECT_TYPE["FIRE_EFFECT"] = "FIRE_EFFECT";
    XENO_EFFECT_TYPE["SLOW_EFFECT"] = "SLOW_EFFECT";
    XENO_EFFECT_TYPE["ACID_EFFECT"] = "ACID_EFFECT";
})(XENO_EFFECT_TYPE = exports.XENO_EFFECT_TYPE || (exports.XENO_EFFECT_TYPE = {}));
var XENO_ATKER_TYPE;
(function (XENO_ATKER_TYPE) {
    XENO_ATKER_TYPE["FRIEND"] = "FRINED";
    XENO_ATKER_TYPE["ENEMY"] = "ENEMY";
})(XENO_ATKER_TYPE = exports.XENO_ATKER_TYPE || (exports.XENO_ATKER_TYPE = {}));

},{}],115:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Game_1 = require("./Wolfie2D/Loop/Game");
const SplashScreen_1 = require("./hw4/Scenes/SplashScreen");
const constants_1 = require("./hw4/constants");
// The main function is your entrypoint into Wolfie2D. Specify your first scene and any options here.
(function main() {
    // Run any tests
    runTests();
    // Set up options for our game
    let options = {
        canvasSize: { x: constants_1.CANVAS_SIZE.x, y: constants_1.CANVAS_SIZE.y },
        clearColor: { r: 0.1, g: 0.1, b: 0.1 },
        inputs: [
            { name: "forward", keys: ["w"] },
            { name: "backward", keys: ["s"] },
            { name: "left", keys: ["a"] },
            { name: "right", keys: ["d"] },
            { name: "pickup", keys: ["e"] },
            { name: "drop", keys: ["q"] },
            { name: "slot1", keys: ["1"] },
            { name: "slot2", keys: ["2"] },
        ],
        useWebGL: false,
        showDebug: false // Whether to show debug messages. You can change this to true if you want
    };
    // Create a game with the options specified
    const game = new Game_1.default(options);
    // Start our game
    game.start(SplashScreen_1.default, {});
})();
function runTests() {
}
;

},{"./Wolfie2D/Loop/Game":30,"./hw4/Scenes/SplashScreen":112,"./hw4/constants":114}]},{},[115])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvV29sZmllMkQvQUkvQUlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9GdW5jdGlvbnMvTnVsbEZ1bmMudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0dyYXBocy9FZGdlTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvR3JhcGhzL0dyYXBoLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9HcmFwaHMvUG9zaXRpb25HcmFwaC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9SZWdpb24udHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL01hcC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvTWF0NHg0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9QaHlzaWNzL0FyZWFDb2xsaXNpb24udHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1BoeXNpY3MvSGl0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9RdWV1ZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvUmVuZGVyaW5nL1dlYkdMUHJvZ3JhbVR5cGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1NoYXBlcy9BQUJCLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQ2lyY2xlLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvU2hhcGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1N0YWNrLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlc2V0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyLnRzIiwic3JjL1dvbGZpZTJEL0RlYnVnL0RlYnVnLnRzIiwic3JjL1dvbGZpZTJEL0RlYnVnL1N0YXRzLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9FbWl0dGVyLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9FdmVudFF1ZXVlLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnQudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFR5cGUudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL1JlY2VpdmVyLnRzIiwic3JjL1dvbGZpZTJEL0lucHV0L0lucHV0LnRzIiwic3JjL1dvbGZpZTJEL0lucHV0L0lucHV0SGFuZGxlci50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0Vudmlyb25tZW50SW5pdGlhbGl6ZXIudHMiLCJzcmMvV29sZmllMkQvTG9vcC9GaXhlZFVwZGF0ZUdhbWVMb29wLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvR2FtZS50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0dhbWVMb29wLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvR2FtZU9wdGlvbnMudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvQ2FudmFzTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlcy50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9MaW5lLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1BhcnRpY2xlLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1BvaW50LnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1JlY3QudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvbi50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVGV4dElucHV0LnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXMudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2aWdhdGlvbk1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2aWdhdGlvblBhdGgudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2bWVzaC50cyIsInNyYy9Xb2xmaWUyRC9QaHlzaWNzL0Jhc2ljUGh5c2ljc01hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUGh5c2ljcy9QaHlzaWNzTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9QbGF5YmFjay9SZWNvcmRlci50cyIsInNyYy9Xb2xmaWUyRC9SZWdpc3RyeS9SZWdpc3RyaWVzL1JlZ2lzdHJ5LnRzIiwic3JjL1dvbGZpZTJEL1JlZ2lzdHJ5L1JlZ2lzdHJpZXMvU2hhZGVyUmVnaXN0cnkudHMiLCJzcmMvV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL0FuaW1hdGlvbk1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0FuaW1hdGlvbnMvQW5pbWF0aW9uVHlwZXMudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0FuaW1hdGlvbnMvUGFydGljbGVTeXN0ZW1NYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL1R3ZWVuQ29udHJvbGxlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQW5pbWF0aW9ucy9Ud2Vlbk1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9DYW52YXNSZW5kZXJpbmcvR3JhcGhpY1JlbmRlcmVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9DYW52YXNSZW5kZXJpbmcvVGlsZW1hcFJlbmRlcmVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9DYW52YXNSZW5kZXJpbmcvVUlFbGVtZW50UmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1JlbmRlcmluZ01hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL0xhYmVsU2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvUG9pbnRTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9RdWFkU2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvUmVjdFNoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1Nwcml0ZVNoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9GYWN0b3JpZXMvQ2FudmFzTm9kZUZhY3RvcnkudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvRmFjdG9yaWVzL0ZhY3RvcnlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0ZhY3Rvcmllcy9UaWxlbWFwRmFjdG9yeS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9MYXllci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9MYXllcnMvUGFyYWxsYXhMYXllci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9MYXllcnMvVUlMYXllci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9TY2VuZS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9TY2VuZU1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvU2NlbmVPcHRpb25zLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lR3JhcGgvU2NlbmVHcmFwaC50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZUdyYXBoL1NjZW5lR3JhcGhBcnJheS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZUdyYXBoL1ZpZXdwb3J0LnRzIiwic3JjL1dvbGZpZTJEL1NvdW5kL0F1ZGlvTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9UaW1pbmcvVGltZXIudHMiLCJzcmMvV29sZmllMkQvVGltaW5nL1RpbWVyTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9Db2xvci50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9FYXNlRnVuY3Rpb25zLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL0dyYXBoVXRpbHMudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvTWF0aFV0aWxzLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL1JlbmRlcmluZ1V0aWxzLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL1N0cmluZ1V0aWxzLnRzIiwic3JjL2h3NC9BSS9FbmVteUFJLnRzIiwic3JjL2h3NC9BSS9UdXJyZXRBSS50cyIsInNyYy9odzQvQUkvV2FsbEFJLnRzIiwic3JjL2h3NC9HYW1lU3lzdGVtcy9BdHRhY2svUG9pbnRBdHRhY2sudHMiLCJzcmMvaHc0L0dhbWVTeXN0ZW1zL0F0dGFja0FuaW1hdGlvbi9BdGtBbmltYXRpb24udHMiLCJzcmMvaHc0L0dhbWVTeXN0ZW1zL0F0dGFja0FuaW1hdGlvbi9CdWxsZXRBbmltYXRpb24udHMiLCJzcmMvaHc0L0dhbWVTeXN0ZW1zL0F0dGFja0FuaW1hdGlvbi9TbGljZUFuaW1hdGlvbi50cyIsInNyYy9odzQvR2FtZVN5c3RlbXMvQmF0dGxlTWFuYWdlci50cyIsInNyYy9odzQvR2FtZVN5c3RlbXMvRWZmZWN0L0FjaWRFZmZlY3QudHMiLCJzcmMvaHc0L0dhbWVTeXN0ZW1zL0VmZmVjdC9FZmZlY3QudHMiLCJzcmMvaHc0L0dhbWVTeXN0ZW1zL0VmZmVjdC9GaXJlRWZmZWMudHMiLCJzcmMvaHc0L0dhbWVTeXN0ZW1zL0VmZmVjdC9TbG93RWZmZWN0LnRzIiwic3JjL2h3NC9TY2VuZXMvTWFpbk1lbnUudHMiLCJzcmMvaHc0L1NjZW5lcy9TcGxhc2hTY3JlZW4udHMiLCJzcmMvaHc0L1NjZW5lcy94ZW5vX2xldmVsLnRzIiwic3JjL2h3NC9jb25zdGFudHMudHMiLCJzcmMvbWFpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDSUEsMENBQW1DO0FBRW5DOzs7R0FHRztBQUNILE1BQXFCLFNBQVM7SUFNN0I7UUFDQyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7UUFDMUIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFRDs7O09BR0c7SUFDSCxhQUFhLENBQUMsS0FBWTtRQUN6QixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBRUQsV0FBVyxDQUFDLEtBQVk7UUFDdkIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFdkMsSUFBRyxLQUFLLEtBQUssQ0FBQyxDQUFDLEVBQUM7WUFDZixJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDN0I7SUFDRixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFVBQVUsQ0FBQyxJQUFZLEVBQUUs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QUMsS0FBVztRQUM5QixJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDMUIsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFM0MsSUFBRyxFQUFFLElBQUksQ0FBQyxFQUFDO1lBQ1AsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFFRCxJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDMUIsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFM0MsSUFBRyxFQUFFLElBQUksQ0FBQyxFQUFDO1lBQ1AsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsV0FBVyxDQUFDLEtBQVc7UUFDbkIsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQzFCLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsS0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRTNDLElBQUksRUFBRSxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUMxQixJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUUzQyxrRUFBa0U7UUFDbEUsSUFBRyxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxL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R0FBRyxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQzFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksRUFDaEUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRCxVQUFVLENBQUMsSUFBVSxFQUFFLE1BQVksRUFBRSxJQUFZO1FBQzdDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDakQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUNwQyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN0QixJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwRixJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxV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Q0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLG1CQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxtQkFBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsbUJBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDMUssQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU07UUFDTCxPQUFPLElBQUksS0FBSyxDQUFDLG1CQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxtQkFBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsbUJBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLG1CQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzFLLENBQUM7SUFFRDs7O09BR0c7SUFDSCxPQUFPO1FBQ04sT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUTtRQUNQLE9BQU8sR0FBRyxHQUFHLG1CQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsbUJBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENB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LENBQUM7SUFFRCxZQUFZLENBQUMsUUFBYztRQUN2QixNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN0RCxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsRyxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQ3pGLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQ3BGLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQ3BGLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUE7SUFDOUYsQ0FBQztJQUdELFNBQVMsQ0FBQyxRQUFjLEVBQUUsSUFBZTtRQUNyQyxJQUFJLElBQUksR0FBbUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUVoRCxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1AsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztZQUNuRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxjQUFJLENBQUMsY0FBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztTQUNsRTtRQUNELElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3RELElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLGNBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLGNBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUU5RixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztRQUNwQixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRUQsU0FBUyxDQUFDLFFBQWE7UUFDbkIsSUFBSSxJQUFvQixDQUFDO1FBQ3pCLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDbEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLGNBQUksQ0FBQyxjQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBQy9ELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3BELElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRTtZQUN2QixRQUFRLEVBQUUsSUFBSTtZQUNkLFNBQVMsRUFBRSxJQUFJO1lBQ2YsT0FBTyxFQUFFLElBQUk7WUFDYixPQUFPLEVBQUUsSUFBSTtTQUNoQixDQUFDLENBQUM7UUFDRixJQUFJLENBQUMsRUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDO1FBRXJDLElBQUksQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLGNBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMxRCxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztRQUNwQixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDbEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDM0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxTQUFTLENBQUMsUUFBYztRQUNwQixJQUFJLElBQUksR0FBbUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNoRCxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUU3QixJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1AsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztZQUNuRCxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksY0FBSSxDQUFDLGNBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7U0FDbEU7UUFFRCxJQUFJLFFBQVEsR0FBbUIsSUFBSSxFQUFFLFNBQVMsR0FBbUIsSUFBSSxFQUFFLE9BQU8sR0FBbUIsSUFBSSxFQUFFLE9BQU8sR0FBbUIsSUFBSSxDQUFDO1FBQ3RJLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxjQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDL0IsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDcEQsTUFBTSxjQUFjLEdBQUcsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLGNBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQy9ELE1BQU0sZUFBZSxHQUFHLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxjQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0QsTUFBTSxhQUFhLEdBQUcsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLGNBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3RCxNQUFNLGFBQWEsR0FBRyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksY0FBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFOUQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUMxQixJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLEVBQUU7Z0JBQzNELFFBQVEsR0FBRyxDQUFDLENBQUM7Z0JBQ1osUUFBUSxDQUFDLEVBQWEsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLGlCQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzFELE9BQU8sQ0FBQyxHQUFHLENBQUMsb0JBQW9CLFFBQVEsRUFBRSxDQUFDLENBQUM7YUFDL0M7WUFDRCxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLEVBQUU7Z0JBQzVELFNBQVMsR0FBRyxDQUFDLENBQUM7Z0JBQ2IsU0FBUyxDQUFDLEVBQWEsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLGlCQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzFELE9BQU8sQ0FBQyxHQUFHLENBQUMscUJBQXFCLFNBQVMsRUFBRSxDQUFDLENBQUM7YUFDakQ7WUFDRCxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQUU7Z0JBQzFELE9BQU8sR0FBRyxDQUFDLENBQUM7Z0JBQ1gsT0FBTyxDQUFDLEVBQWEsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLGlCQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3ZELE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLE9BQU8sRUFBRSxDQUFDLENBQUM7YUFDN0M7WUFDRCxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQUU7Z0JBQzFELE9BQU8sR0FBRyxDQUFDLENBQUM7Z0JBQ1gsT0FBTyxDQUFDLEVBQWEsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLGlCQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3ZELE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLE9BQU8sRUFBRSxDQUFDLENBQUM7YUFDN0M7UUFDTCxDQUFDLENBQUMsQ0FBQTtRQUVGLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRTtZQUN2QixRQUFRLEVBQUUsUUFBUTtZQUNsQixTQUFTLEVBQUUsU0FBUztZQUNwQixPQUFPLEVBQUUsT0FBTztZQUNoQixPQUFPLEVBQUUsT0FBTztTQUNuQixDQUFDLENBQUE7UUFFRixJQUFJLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxjQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDMUQsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDcEIsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFRCxXQUFXLENBQUMsUUFBYztRQUN0QixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3BDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxjQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUUxRSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1QsTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUN0RCxNQUFNLENBQUMsS0FBSyxDQUFDLGtCQUFRLEVBQUUsRUFBRSxhQUFhLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7U0FDakU7UUFDRCxNQUFNLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxjQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDNUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDdEIsTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3BCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRCxXQUFXLENBQUMsUUFBYztRQUN0QixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ25DLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxjQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUUxRSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1IsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQztZQUNsRCxLQUFLLENBQUMsS0FBSyxDQUFDLGlCQUFPLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLGNBQUksQ0FBQyxHQUFHLEVBQUMsR0FBRyxDQUFDLEVBQUMsUUFBUSxFQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxjQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxVQUFVLEVBQUUsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsYUFBYSxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO1NBQzNPO1FBQ0EsS0FBSyxDQUFDLEVBQWdCLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQztRQUNwQyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztRQUM1QixLQUFLLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUMvQyxLQUFLLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxjQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDM0QsS0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDckIsS0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ25CLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFRCxlQUFlLENBQUMsSUFBb0I7UUFDaEMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLEVBQVksQ0FBQztRQUNqQyxNQUFNLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNwQyxJQUFJLENBQUMsRUFBRTtnQkFDSCxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQ1osUUFBTyxDQUFDLEVBQUU7b0JBQ04sS0FBSyxpQkFBUSxDQUFDLElBQUksQ0FBQztvQkFDbkIsS0FBSyxpQkFBUSxDQUFDLEdBQUc7d0JBQ2IsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7d0JBQ1osTUFBTTtvQkFDVixLQUFLLGlCQUFRLENBQUMsR0FBRyxDQUFDO29CQUNsQixLQUFLLGlCQUFRLENBQUMsS0FBSzt3QkFDZixHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQzt3QkFDWixNQUFNO2lCQUNiO2dCQUNBLENBQUMsQ0FBQyxFQUFhLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ3JDO1FBQ0wsQ0FBQyxDQUFDLENBQUE7SUFFTixDQUFDO0lBRUQsZ0JBQWdCLENBQUMsSUFBVSxFQUFFLEtBQWE7UUFDdEMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTTtZQUFFLE9BQU8sU0FBUyxDQUFDO1FBRWhELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMvQyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxLQUFLLEVBQUU7Z0JBQ3hELE9BQVEsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFnQixDQUFDO2FBQ2pEO1NBQ0o7SUFDTCxDQUFDO0NBRUo7QUEvV0QsNkJBK1dDOzs7Ozs7QUNwWVksUUFBQSxXQUFXLEdBQUc7SUFDdkIsQ0FBQyxFQUFFLElBQUk7SUFDUCxDQUFDLEVBQUUsR0FBRztDQUNULENBQUE7QUFFRCxJQUFZLFNBS1g7QUFMRCxXQUFZLFNBQVM7SUFDakIsMEJBQWEsQ0FBQTtJQUNiLDBCQUFhLENBQUE7SUFDYiw0QkFBZSxDQUFBO0lBQ2YsNEJBQWUsQ0FBQTtBQUNuQixDQUFDLEVBTFcsU0FBUyxHQUFULGlCQUFTLEtBQVQsaUJBQVMsUUFLcEI7QUFFRCxJQUFZLFNBS1g7QUFMRCxXQUFZLFNBQVM7SUFDakIsMEJBQWEsQ0FBQTtJQUNiLHdCQUFXLENBQUE7SUFDWCw0QkFBZSxDQUFBO0lBQ2YsNEJBQWUsQ0FBQTtBQUNuQixDQUFDLEVBTFcsU0FBUyxHQUFULGlCQUFTLEtBQVQsaUJBQVMsUUFLcEI7QUFFRCxJQUFZLFdBUVg7QUFSRCxXQUFZLFdBQVc7SUFDbkIsOEJBQWUsQ0FBQTtJQUNmLDRDQUE2QixDQUFBO0lBQzdCLHNDQUF1QixDQUFBO0lBQ3ZCLHdDQUF5QixDQUFBO0lBQ3pCLDBDQUEyQixDQUFBO0lBQzNCLHNDQUF1QixDQUFBO0lBQ3ZCLGtDQUFtQixDQUFBO0FBQ3ZCLENBQUMsRUFSVyxXQUFXLEdBQVgsbUJBQVcsS0FBWCxtQkFBVyxRQVF0QjtBQUVELElBQVksZ0JBSVg7QUFKRCxXQUFZLGdCQUFnQjtJQUN4QiwrQ0FBMkIsQ0FBQTtJQUMzQiwrQ0FBMkIsQ0FBQTtJQUMzQiwrQ0FBMkIsQ0FBQTtBQUMvQixDQUFDLEVBSlcsZ0JBQWdCLEdBQWhCLHdCQUFnQixLQUFoQix3QkFBZ0IsUUFJM0I7QUFFRCxJQUFZLGVBR1g7QUFIRCxXQUFZLGVBQWU7SUFDdkIsb0NBQWlCLENBQUE7SUFDakIsa0NBQWUsQ0FBQTtBQUNuQixDQUFDLEVBSFcsZUFBZSxHQUFmLHVCQUFlLEtBQWYsdUJBQWUsUUFHMUI7Ozs7O0FDeENELCtDQUF3QztBQUl4Qyw0REFBcUQ7QUFDckQsK0NBQThDO0FBRTlDLHFHQUFxRztBQUNyRyxDQUFDLFNBQVMsSUFBSTtJQUNWLGdCQUFnQjtJQUNoQixRQUFRLEVBQUUsQ0FBQztJQUVYLDhCQUE4QjtJQUM5QixJQUFJLE9BQU8sR0FBRztRQUNWLFVBQVUsRUFBRSxFQUFDLENBQUMsRUFBRSx1QkFBVyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsdUJBQVcsQ0FBQyxDQUFDLEVBQUM7UUFDaEQsVUFBVSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUM7UUFDcEMsTUFBTSxFQUFFO1lBQ0osRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFDO1lBQzlCLEVBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBQztZQUMvQixFQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUM7WUFDM0IsRUFBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFDO1lBQzVCLEVBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBQztZQUM3QixFQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUM7WUFDM0IsRUFBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFDO1lBQzVCLEVBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBQztTQUMvQjtRQUNELFFBQVEsRUFBRSxLQUFLO1FBQ2YsU0FBUyxFQUFFLEtBQUssQ0FBdUIsMEVBQTBFO0tBQ3BILENBQUE7SUFHRCwyQ0FBMkM7SUFDM0MsTUFBTSxJQUFJLEdBQUcsSUFBSSxjQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFL0IsaUJBQWlCO0lBQ2pCLElBQUksQ0FBQyxLQUFLLENBQUMsc0JBQVksRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNqQyxDQUFDLENBQUMsRUFBRSxDQUFDO0FBRUwsU0FBUyxRQUFRO0FBRWpCLENBQUM7QUFBQSxDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiaW1wb3J0IEFjdG9yIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BY3RvclwiO1xuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBBSSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQUlcIjtcbmltcG9ydCBHb2FwQUkgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0dvYXBBSVwiXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XG5cbi8qKlxuICogQSBtYW5hZ2VyIGNsYXNzIGZvciBhbGwgb2YgdGhlIEFJIGluIGEgc2NlbmUuXG4gKiBLZWVwcyBhIGxpc3Qgb2YgcmVnaXN0ZXJlZCBhY3RvcnMgYW5kIGhhbmRsZXMgQUkgZ2VuZXJhdGlvbiBmb3IgYWN0b3JzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBSU1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcblx0LyoqIFRoZSBhcnJheSBvZiByZWdpc3RlcmVkIGFjdG9ycyAqL1xuXHRhY3RvcnM6IEFycmF5PEFjdG9yPjtcblx0LyoqIE1hcHMgQUkgbmFtZXMgdG8gdGhlaXIgY29uc3RydWN0b3JzICovXG5cdHJlZ2lzdGVyZWRBSTogTWFwPEFJQ29uc3RydWN0b3I+O1xuXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5hY3RvcnMgPSBuZXcgQXJyYXkoKTtcblx0XHR0aGlzLnJlZ2lzdGVyZWRBSSA9IG5ldyBNYXAoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYW4gYWN0b3Igd2l0aCB0aGUgQUlNYW5hZ2VyXG5cdCAqIEBwYXJhbSBhY3RvciBUaGUgYWN0b3IgdG8gcmVnaXN0ZXJcblx0ICovXG5cdHJlZ2lzdGVyQWN0b3IoYWN0b3I6IEFjdG9yKTogdm9pZCB7XG5cdFx0dGhpcy5hY3RvcnMucHVzaChhY3Rvcik7XG5cdH1cblxuXHRyZW1vdmVBY3RvcihhY3RvcjogQWN0b3IpOiB2b2lkIHtcblx0XHRsZXQgaW5kZXggPSB0aGlzLmFjdG9ycy5pbmRleE9mKGFjdG9yKTtcblxuXHRcdGlmKGluZGV4ICE9PSAtMSl7XG5cdFx0XHR0aGlzLmFjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYW4gQUkgd2l0aCB0aGUgQUlNYW5hZ2VyIGZvciB1c2UgbGF0ZXIgb25cblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIEFJIHRvIHJlZ2lzdGVyXG5cdCAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgQUlcblx0ICovXG5cdHJlZ2lzdGVyQUkobmFtZTogc3RyaW5nLCBjb25zdHI6IG5ldyA8VCBleHRlbmRzIEFJIHwgR29hcEFJPigpID0+IFQgKTogdm9pZCB7XG5cdFx0dGhpcy5yZWdpc3RlcmVkQUkuYWRkKG5hbWUsIGNvbnN0cik7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGVzIGFuIEFJIGluc3RhbmNlIGZyb20gaXRzIG5hbWVcblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIEFJIHRvIGFkZFxuXHQgKiBAcmV0dXJucyBBIG5ldyBBSSBpbnN0YW5jZVxuXHQgKi9cblx0Z2VuZXJhdGVBSShuYW1lOiBzdHJpbmcpOiBBSSB8IEdvYXBBSSB7XG5cdFx0aWYodGhpcy5yZWdpc3RlcmVkQUkuaGFzKG5hbWUpKXtcblx0XHRcdHJldHVybiBuZXcgKHRoaXMucmVnaXN0ZXJlZEFJLmdldChuYW1lKSkoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgYENhbm5vdCBjcmVhdGUgQUkgd2l0aCBuYW1lICR7bmFtZX0sIG5vIEFJIHdpdGggdGhhdCBuYW1lIGlzIHJlZ2lzdGVyZWRgO1xuXHRcdH1cblx0fVxuXG5cdHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuXHRcdC8vIFJ1biB0aGUgYWkgZm9yIGV2ZXJ5IGFjdGl2ZSBhY3RvclxuXHRcdHRoaXMuYWN0b3JzLmZvckVhY2goYWN0b3IgPT4geyBpZihhY3Rvci5haUFjdGl2ZSkgYWN0b3IuYWkudXBkYXRlKGRlbHRhVCkgfSk7XG5cdH1cbn1cblxudHlwZSBBSUNvbnN0cnVjdG9yID0gbmV3IDxUIGV4dGVuZHMgQUk+KCkgPT4gVDsiLCIvLyBAaWdub3JlUGFnZVxuXG4vKipcbiAqIEEgcGxhY2Vob2xkZXIgZnVuY3Rpb24gZm9yIE5vIE9wZXJhdGlvbi4gRG9lcyBub3RoaW5nXG4gKi9cbmNvbnN0IE51bGxGdW5jID0gKCkgPT4ge307XG5cbmV4cG9ydCBkZWZhdWx0IE51bGxGdW5jOyIsIi8qKlxuICogQSBsaW5rZWQtbGlzdCBmb3IgdGhlIGVkZ2VzIGluIGEgQHJlZmVyZW5jZVtHcmFwaF0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVkZ2VOb2RlIHtcbiAgICAvKiogVGhlIG5vZGUgaW4gdGhlIEdyYXBoIHRoaXMgZWRnZSBjb25uZWN0cyB0byAqL1xuICAgIHk6IG51bWJlcjtcbiAgICAvKiogVGhlIHdlaWdodCBvZiB0aGlzIEVkZ2VOb2RlICovXG5cdHdlaWdodDogbnVtYmVyO1xuICAgIC8qKiBUaGUgbmV4dCBFZGdlTm9kZSBpbiB0aGUgbGlua2VkLWxpc3QgKi9cbiAgICBuZXh0OiBFZGdlTm9kZTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRWRnZU5vZGVcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRoaXMgZWRnZSBjb25uZWN0cyB0b1xuICAgICAqIEBwYXJhbSB3ZWlnaHQgVGhlIHdlaWdodCBvZiB0aGlzIGVkZ2VcbiAgICAgKi9cblx0Y29uc3RydWN0b3IoaW5kZXg6IG51bWJlciwgd2VpZ2h0PzogbnVtYmVyKXtcblx0XHR0aGlzLnkgPSBpbmRleDtcblx0XHR0aGlzLm5leHQgPSBudWxsO1xuXHRcdHRoaXMud2VpZ2h0ID0gd2VpZ2h0ID8gd2VpZ2h0IDogMTtcblx0fVxufSIsImltcG9ydCBFZGdlTm9kZSBmcm9tIFwiLi9FZGdlTm9kZVwiO1xuXG5leHBvcnQgY29uc3QgTUFYX1YgPSAxMDA7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYSBncmFwaCBkYXRhIHN0cnVjdHVyZSB1c2luZyBlZGdlIGxpc3RzLiBJbnNwaXJlZCBieSBUaGUgQWxnb3JpdGhtIERlc2lnbiBNYW51YWwuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoIHtcblx0LyoqIEFuIGFycmF5IG9mIGVkZ2VzIGF0IHRoZSBub2RlIHNwZWNpZmllZCBieSB0aGUgaW5kZXggKi9cblx0ZWRnZXM6IEFycmF5PEVkZ2VOb2RlPjtcblx0LyoqIEFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgZGVncmVlIG9mIHRoZSBub2RlIHNwZWNpZmllZCBieSB0aGUgaW5kZXggKi9cblx0ZGVncmVlOiBBcnJheTxudW1iZXI+O1xuXHQvKiogVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgZ3JhcGggKi9cblx0bnVtVmVydGljZXM6IG51bWJlcjtcblx0LyoqIFRoZSBudW1iZXIgb2YgZWRnZXMgaW4gdGhlIGdyYXBoICovXG5cdG51bUVkZ2VzOiBudW1iZXI7XG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ3JhcGggaXMgZGlyZWN0ZWQgKi9cblx0ZGlyZWN0ZWQ6IGJvb2xlYW47XG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ3JhcGggaXMgd2VpZ2h0ZWQgKi9cblx0d2VpZ2h0ZWQ6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZ3JhcGhcblx0ICogQHBhcmFtIGRpcmVjdGVkIFdoZXRoZXIgb3Igbm90IHRoaXMgZ3JhcGggaXMgZGlyZWN0ZWRcblx0ICovXG5cdGNvbnN0cnVjdG9yKGRpcmVjdGVkOiBib29sZWFuID0gZmFsc2Upe1xuXHRcdHRoaXMuZGlyZWN0ZWQgPSBkaXJlY3RlZDtcblx0XHR0aGlzLndlaWdodGVkID0gZmFsc2U7XG5cblx0XHR0aGlzLm51bVZlcnRpY2VzID0gMDtcblx0XHR0aGlzLm51bUVkZ2VzID0gMDtcblxuXHRcdHRoaXMuZWRnZXMgPSBuZXcgQXJyYXkoTUFYX1YpO1xuXHRcdHRoaXMuZGVncmVlID0gbmV3IEFycmF5KE1BWF9WKTtcblx0fVxuXG5cdC8qKiBBZGRzIGEgbm9kZSB0byB0aGlzIGdyYXBoIGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZiBpdFxuXHQgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIG5ldyBub2RlXG5cdCovXG5cdGFkZE5vZGUoKTogbnVtYmVyIHtcblx0XHR0aGlzLm51bVZlcnRpY2VzKys7XG5cdFx0cmV0dXJuIHRoaXMubnVtVmVydGljZXM7XG5cdH1cblxuXHQvKiogQWRkcyBhbiBlZGdlIGJldHdlZW4gbm9kZSB4IGFuZCB5LCB3aXRoIGFuIG9wdGlvbmFsIHdlaWdodFxuXHQgKiBAcGFyYW0geCBUaGUgaW5kZXggb2YgdGhlIHN0YXJ0IG9mIHRoZSBlZGdlXG5cdCAqIEBwYXJhbSB5IFRoZSBpbmRleCBvZiB0aGUgZW5kIG9mIHRoZSBlZGdlXG5cdCAqIEBwYXJhbSB3ZWlnaHQgVGhlIG9wdGlvbmFsIHdlaWdodCBvZiB0aGUgbmV3IGVkZ2Vcblx0Ki9cblx0YWRkRWRnZSh4OiBudW1iZXIsIHk6IG51bWJlciwgd2VpZ2h0PzogbnVtYmVyKTogdm9pZCB7XG5cdFx0bGV0IGVkZ2UgPSBuZXcgRWRnZU5vZGUoeSwgd2VpZ2h0KTtcblxuXG5cblx0XHRpZih0aGlzLmVkZ2VzW3hdKXtcblx0XHRcdGVkZ2UubmV4dCA9IHRoaXMuZWRnZXNbeF07XG5cdFx0fVxuXHRcdFxuXHRcdHRoaXMuZWRnZXNbeF0gPSBlZGdlO1xuXG5cdFx0aWYoIXRoaXMuZGlyZWN0ZWQpe1xuXHRcdFx0ZWRnZSA9IG5ldyBFZGdlTm9kZSh4LCB3ZWlnaHQpO1xuXG5cdFx0XHRpZih0aGlzLmVkZ2VzW3ldKXtcblx0XHRcdFx0ZWRnZS5uZXh0ID0gdGhpcy5lZGdlc1t5XTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5lZGdlc1t5XSA9IGVkZ2U7XG5cdFx0fVxuXG5cdFx0dGhpcy5udW1FZGdlcyArPSAxO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBhbiBlZGdlIGV4aXN0cyBiZXR3ZWVuIHR3byBub2Rlcy5cblx0ICogVGhpcyBjaGVjayBpcyBkaXJlY3Rpb25hbCBpZiB0aGlzIGlzIGEgZGlyZWN0ZWQgZ3JhcGguXG5cdCAqIEBwYXJhbSB4IFRoZSBmaXJzdCBub2RlXG5cdCAqIEBwYXJhbSB5IFRoZSBzZWNvbmQgbm9kZVxuXHQgKiBAcmV0dXJucyB0cnVlIGlmIGFuIGVkZ2UgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdGVkZ2VFeGlzdHMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBib29sZWFuIHtcblx0XHRsZXQgZWRnZSA9IHRoaXMuZWRnZXNbeF07XG5cblx0XHR3aGlsZShlZGdlICE9PSBudWxsKXtcblx0XHRcdGlmKGVkZ2UueSA9PT0geSl7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWRnZSA9IGVkZ2UubmV4dDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZWRnZSBsaXN0IGFzc29jaWF0ZWQgd2l0aCBub2RlIHhcblx0ICogQHBhcmFtIHggVGhlIGluZGV4IG9mIHRoZSBub2RlXG5cdCAqIEByZXR1cm5zIFRoZSBoZWFkIG9mIGEgbGlua2VkLWxpc3Qgb2YgZWRnZXNcblx0ICovXG5cdGdldEVkZ2VzKHg6IG51bWJlcik6IEVkZ2VOb2RlIHtcblx0XHRyZXR1cm4gdGhpcy5lZGdlc1t4XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBkZWdyZWUgYXNzb2NpYXRlZCB3aXRoIG5vZGUgeFxuXHQgKiBAcGFyYW0geCBUaGUgaW5kZXggb2YgdGhlIG5vZGVcblx0ICovXG5cdGdldERlZ3JlZSh4OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLmRlZ3JlZVt4XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgc3BlY2lmZWQgbm9kZSBpbnRvIGEgc3RyaW5nXG5cdCAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gY29udmVydCB0byBhIHN0cmluZ1xuXHQgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBub2RlOiBcIk5vZGUgeFwiXG5cdCAqL1xuXHRwcm90ZWN0ZWQgbm9kZVRvU3RyaW5nKGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuXHRcdHJldHVybiBcIk5vZGUgXCIgKyBpbmRleDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgR3JhcGggaW50byBhIHN0cmluZyBmb3JtYXRcblx0ICogQHJldHVybnMgVGhlIGdyYXBoIGFzIGEgc3RyaW5nXG5cdCAqL1xuXHR0b1N0cmluZygpOiBzdHJpbmcge1xuXHRcdGxldCByZXR2YWwgPSBcIlwiO1xuXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMubnVtVmVydGljZXM7IGkrKyl7XG5cdFx0XHRsZXQgZWRnZSA9IHRoaXMuZWRnZXNbaV07XG5cdFx0XHRsZXQgZWRnZVN0ciA9IFwiXCI7XG5cdFx0XHR3aGlsZShlZGdlICE9PSB1bmRlZmluZWQgJiYgZWRnZSAhPT0gbnVsbCl7XG5cdFx0XHRcdGVkZ2VTdHIgKz0gZWRnZS55LnRvU3RyaW5nKCk7XG5cdFx0XHRcdGlmKHRoaXMud2VpZ2h0ZWQpe1xuXHRcdFx0XHRcdGVkZ2VTdHIgKz0gXCIgKFwiICsgZWRnZS53ZWlnaHQgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihlZGdlLm5leHQgIT09IG51bGwpe1xuXHRcdFx0XHRcdGVkZ2VTdHIgKz0gXCIsIFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWRnZSA9IGVkZ2UubmV4dDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dmFsICs9IHRoaXMubm9kZVRvU3RyaW5nKGkpICsgXCI6IFwiICsgZWRnZVN0ciArIFwiXFxuXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldHZhbDtcblx0fVxufSIsImltcG9ydCBHcmFwaCwgeyBNQVhfViB9IGZyb20gXCIuL0dyYXBoXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xuaW1wb3J0IERlYnVnUmVuZGVyYWJsZSBmcm9tIFwiLi4vSW50ZXJmYWNlcy9EZWJ1Z1JlbmRlcmFibGVcIjtcblxuLyoqXG4gKiBBbiBleHRlbnNpb24gb2YgR3JhcGggdGhhdCBoYXMgbm9kZXMgd2l0aCBwb3NpdGlvbnMgaW4gMkQgc3BhY2UuXG4gKiBUaGlzIGlzIGEgd2VpZ2h0ZWQgZ3JhcGggKHRob3VnaCBub3QgaW5oZXJlbnRseSBkaXJlY3RkKVxuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc2l0aW9uR3JhcGggZXh0ZW5kcyBHcmFwaCBpbXBsZW1lbnRzIERlYnVnUmVuZGVyYWJsZSB7XG5cdC8qKiBBbiBhcnJheSBvZiB0aGUgcG9zaXRpb25zIG9mIHRoZSBub2RlcyBpbiB0aGlzIGdyYXBoICovXG5cdHBvc2l0aW9uczogQXJyYXk8VmVjMj47XG5cblx0LyoqXG5cdCAqIENyZWF0ZWVzIGEgbmV3IFBvc2l0aW9uR3JhcGhcblx0ICogQHBhcmFtIGRpcmVjdGVkIFdoZXRoZXIgb3Igbm90IHRoaXMgZ3JhcGggaXMgZGlyZWN0ZWRcblx0ICovXG5cdGNvbnN0cnVjdG9yKGRpcmVjdGVkOiBib29sZWFuID0gZmFsc2Upe1xuXHRcdHN1cGVyKGRpcmVjdGVkKTtcblx0XHR0aGlzLnBvc2l0aW9ucyA9IG5ldyBBcnJheShNQVhfVik7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHBvc2l0aW9uZWQgbm9kZSB0byB0aGlzIGdyYXBoXG5cdCAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgdG8gYWRkXG5cdCAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgYWRkZWQgbm9kZVxuXHQgKi9cblx0YWRkUG9zaXRpb25lZE5vZGUocG9zaXRpb246IFZlYzIpOiBudW1iZXIge1xuXHRcdHRoaXMucG9zaXRpb25zW3RoaXMubnVtVmVydGljZXNdID0gcG9zaXRpb247XG5cdFx0cmV0dXJuIHRoaXMuYWRkTm9kZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIGEgbm9kZS5cblx0ICogQXV0b21hdGljYWxseSBhZGp1c3RzIHRoZSB3ZWlnaHRzIG9mIHRoZSBncmFwaCB0aWVkIHRvIHRoaXMgbm9kZS5cblx0ICogQXMgc3VjaCwgYmUgd2FybmVkIHRoYXQgdGhpcyBmdW5jdGlvbiBoYXMgYW4gTyhuICsgbSkgcnVubmluZyB0aW1lLCBhbmQgdXNlIGl0IHNwYXJpbmdseS5cblx0ICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZVxuXHQgKiBAcGFyYW0gcG9zaXRpb24gVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgbm9kZVxuXHQgKi9cblx0c2V0Tm9kZVBvc2l0aW9uKGluZGV4OiBudW1iZXIsIHBvc2l0aW9uOiBWZWMyKTogdm9pZCB7XG5cdFx0dGhpcy5wb3NpdGlvbnNbaW5kZXhdID0gcG9zaXRpb247XG5cblx0XHQvLyBSZWNhbGN1bGF0ZSBhbGwgd2VpZ2h0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmRleFxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm51bUVkZ2VzOyBpKyspe1xuXG5cdFx0XHRsZXQgZWRnZSA9IHRoaXMuZWRnZXNbaV07XG5cblx0XHRcdHdoaWxlKGVkZ2UgIT09IG51bGwpe1xuXHRcdFx0XHQvLyBJZiB0aGlzIG5vZGUgaXMgb24gZWl0aGVyIHNpZGUgb2YgdGhlIGVkZ2UsIHJlY2FsY3VsYXRlIHdlaWdodFxuXHRcdFx0XHRpZihpID09PSBpbmRleCB8fCBlZGdlLnkgPT09IGluZGV4KXtcblx0XHRcdFx0XHRlZGdlLndlaWdodCA9IHRoaXMucG9zaXRpb25zW2ldLmRpc3RhbmNlVG8odGhpcy5wb3NpdGlvbnNbZWRnZS55XSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlZGdlID0gZWRnZS5uZXh0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiBhIG5vZGVcblx0ICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZVxuXHQgKiBAcmV0dXJucyBUaGUgcG9zaXRpb24gb2YgdGhlIG5vZGVcblx0ICovXG5cdGdldE5vZGVQb3NpdGlvbihpbmRleDogbnVtYmVyKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMucG9zaXRpb25zW2luZGV4XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGVkZ2UgdG8gdGhpcyBncmFwaCBiZXR3ZWVuIG5vZGUgeCBhbmQgeS5cblx0ICogQXV0b21hdGljYWxseSBjYWxjdWxhdGVzIHRoZSB3ZWlnaHQgb2YgdGhlIGVkZ2UgYXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG5vZGVzLlxuXHQgKiBAcGFyYW0geCBUaGUgYmVnaW5uaW5nIG9mIHRoZSBlZGdlXG5cdCAqIEBwYXJhbSB5IFRoZSBlbmQgb2YgdGhlIGVkZ2Vcblx0ICovXG5cdGFkZEVkZ2UoeDogbnVtYmVyLCB5OiBudW1iZXIpOiB2b2lkIHtcblx0XHRpZighdGhpcy5wb3NpdGlvbnNbeF0gfHwgIXRoaXMucG9zaXRpb25zW3ldKXtcblx0XHRcdHRocm93IFwiQ2FuJ3QgYWRkIGVkZ2UgdG8gdW4tcG9zaXRpb25lZCBub2RlIVwiO1xuXHRcdH1cblxuXHRcdC8vIFdlaWdodCBpcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbm9kZXNcblx0XHRsZXQgd2VpZ2h0ID0gdGhpcy5wb3NpdGlvbnNbeF0uZGlzdGFuY2VUbyh0aGlzLnBvc2l0aW9uc1t5XSk7XG5cblx0XHRzdXBlci5hZGRFZGdlKHgsIHksIHdlaWdodCk7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0cHJvdGVjdGVkIG5vZGVUb1N0cmluZyhpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gXCJOb2RlIFwiICsgaW5kZXggKyBcIiAtIFwiICsgdGhpcy5wb3NpdGlvbnNbaW5kZXhdLnRvU3RyaW5nKCk7XG5cdH1cblxuXHRkZWJ1Z1JlbmRlciA9ICgpOiB2b2lkID0+IHtcblx0XHQvLyBmb3IobGV0IHBvaW50IG9mIHRoaXMucG9zaXRpb25zKXtcblx0XHQvLyBcdGN0eC5maWxsUmVjdCgocG9pbnQueCAtIG9yaWdpbi54IC0gNCkqem9vbSwgKHBvaW50LnkgLSBvcmlnaW4ueSAtIDQpKnpvb20sIDgsIDgpO1xuXHRcdC8vIH1cblx0fVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vU2hhcGVzL0FBQkJcIjtcblxuLyoqIEFuIG9iamVjdCB0aGF0IGlzIGEgcmVnaW9uLCB3aXRoIGEgc2l6ZSwgc2NhbGUsIGFuZCBib3VuZGFyeS4gKi9cbmV4cG9ydCBkZWZhdWx0IGludGVyZmFjZSBSZWdpb24ge1xuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGlzIG9iamVjdC4gKi9cbiAgICBzaXplOiBWZWMyO1xuXG4gICAgLyoqIFRoZSBzY2FsZSBvZiB0aGlzIG9iamVjdC4gKi9cbiAgICBzY2FsZTogVmVjMjtcblxuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgb2JqZWN0IHRha2luZyBpbnRvIGFjY291bnQgdGhlIHpvb20gYW5kIHNjYWxlICovXG4gICAgcmVhZG9ubHkgc2l6ZVdpdGhab29tOiBWZWMyO1xuXG4gICAgLyoqIFRoZSBib3VuZGluZyBib3ggb2YgdGhpcyBvYmplY3QuICovXG4gICAgYm91bmRhcnk6IEFBQkI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlZ2lvbihhcmc6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBhcmcgJiYgYXJnLnNpemUgJiYgYXJnLnNjYWxlICYmIGFyZy5ib3VuZGFyeTtcbn0iLCJpbXBvcnQgQ29sbGVjdGlvbiBmcm9tIFwiLi9Db2xsZWN0aW9uXCI7XG5cbi8qKlxuICogQXNzb2NpYXRlcyBzdHJpbmdzIHdpdGggZWxlbWVudHMgb2YgdHlwZSBUXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcDxUPiBpbXBsZW1lbnRzIENvbGxlY3Rpb24ge1xuXHRwcml2YXRlIG1hcDogUmVjb3JkPHN0cmluZywgVD47XG5cblx0LyoqIENyZWF0ZXMgYSBuZXcgbWFwICovXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5tYXAgPSB7fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgdmFsdWUgVCBzdG9yZWQgYXQgYSBrZXkuXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byBiZSBzdG9yZWRcblx0ICogQHBhcmFtIHZhbHVlIFRoZSBpdGVtIHRvIGJlIHN0b3JlZFxuXHQgKi9cblx0YWRkKGtleTogc3RyaW5nLCB2YWx1ZTogVCk6IHZvaWQge1xuXHRcdHRoaXMubWFwW2tleV0gPSB2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIGtleS5cblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpdGVtXG5cdCAqIEByZXR1cm5zIFRoZSBpdGVtIGF0IHRoZSBrZXkgb3IgdW5kZWZpbmVkXG5cdCAqL1xuXHRnZXQoa2V5OiBzdHJpbmcpOiBUIHtcblx0XHRyZXR1cm4gdGhpcy5tYXBba2V5XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBbiBhbGlhcyBvZiBhZGQuIFNldHMgdGhlIHZhbHVlIHN0b3JlZCBhdCBrZXkgdG8gdGhlIG5ldyBzcGVjaWZpZWQgdmFsdWVcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGJlIHN0b3JlZFxuXHQgKiBAcGFyYW0gdmFsdWUgVGhlIGl0ZW0gdG8gYmUgc3RvcmVkXG5cdCAqL1xuXHRzZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBUKTogdm9pZCB7XG5cdFx0dGhpcy5hZGQoa2V5LCB2YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGEgdmFsdWUgc3RvcmVkIGF0IHRoZSBzcGVjaWZpZWQga2V5LCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBjaGVja1xuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhlIGdpdmVuIGtleS5cblx0ICovXG5cdGhhcyhrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLm1hcFtrZXldICE9PSB1bmRlZmluZWQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgb2YgdGhlIGtleXMgaW4gdGhpcyBtYXAuXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGtleXMgaW4gdGhlIG1hcC5cblx0ICovXG5cdGtleXMoKTogQXJyYXk8c3RyaW5nPiB7XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubWFwKTtcblx0fVxuXHRcblx0Ly8gQGltcGxlbWVudGVkXG5cdGZvckVhY2goZnVuYzogKGtleTogc3RyaW5nKSA9PiB2b2lkKTogdm9pZCB7XG5cdFx0T2JqZWN0LmtleXModGhpcy5tYXApLmZvckVhY2goa2V5ID0+IGZ1bmMoa2V5KSk7XG5cdH1cblxuXHQvKipcblx0ICogRGVsZXRlcyBhbiBpdGVtIGFzc29jaWF0ZWQgd2l0aCBhIGtleVxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgYXQgd2hpY2ggdG8gZGVsZXRlIGFuIGl0ZW1cblx0ICovXG5cdGRlbGV0ZShrZXk6IHN0cmluZyk6IHZvaWQge1xuXHRcdGRlbGV0ZSB0aGlzLm1hcFtrZXldO1xuXHR9XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdGNsZWFyKCk6IHZvaWQge1xuXHRcdHRoaXMuZm9yRWFjaChrZXkgPT4gZGVsZXRlIHRoaXMubWFwW2tleV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoaXMgbWFwIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuXHQgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbWFwLlxuXHQgKi9cblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcblx0XHRsZXQgc3RyID0gXCJcIjtcblxuXHRcdHRoaXMuZm9yRWFjaCgoa2V5KSA9PiBzdHIgKz0ga2V5ICsgXCIgLT4gXCIgKyB0aGlzLmdldChrZXkpLnRvU3RyaW5nKCkgKyBcIlxcblwiKTtcblxuXHRcdHJldHVybiBzdHI7XG5cdH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi9WZWMyXCI7XG5cbi8qKiBBIDR4NCBtYXRyaXgwICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXQ0eDQge1xuXHRwcml2YXRlIG1hdDogRmxvYXQzMkFycmF5O1xuXG5cdGNvbnN0cnVjdG9yKCl7XG5cdFx0dGhpcy5tYXQgPSBuZXcgRmxvYXQzMkFycmF5KFtcblx0XHRcdDAsIDAsIDAsIDAsXG5cdFx0XHQwLCAwLCAwLCAwLFxuXHRcdFx0MCwgMCwgMCwgMCxcblx0XHRcdDAsIDAsIDAsIDBcblx0XHRdKTtcblx0fVxuXG5cdC8vIFN0YXRpYyBtZW1iZXJzXG5cdHN0YXRpYyBnZXQgSURFTlRJVFkoKTogTWF0NHg0IHtcblx0XHRyZXR1cm4gbmV3IE1hdDR4NCgpLmlkZW50aXR5KCk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0IFpFUk8oKTogTWF0NHg0IHtcblx0XHRyZXR1cm4gbmV3IE1hdDR4NCgpLnplcm8oKTtcblx0fVxuXG5cdC8vIEFjY2Vzc29yc1xuXHRzZXQgXzAwKHg6IG51bWJlcikge1xuXHRcdHRoaXMubWF0WzBdID0geDtcblx0fVxuXG5cdHNldChjb2w6IG51bWJlciwgcm93OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiBNYXQ0eDQge1xuXHRcdGlmKGNvbCA8IDAgfHwgY29sID4gMyB8fCByb3cgPCAwIHx8IHJvdyA+IDMpe1xuXHRcdFx0dGhyb3cgYEVycm9yIC0gaW5kZXggKCR7Y29sfSwgJHtyb3d9KSBpcyBvdXQgb2YgYm91bmRzIGZvciBNYXQ0eDRgXG5cdFx0fVxuXHRcdHRoaXMubWF0W3Jvdyo0ICsgY29sXSA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRnZXQoY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5tYXRbcm93KjQgKyBjb2xdO1xuXHR9XG5cblx0c2V0QWxsKC4uLml0ZW1zOiBBcnJheTxudW1iZXI+KTogTWF0NHg0IHtcblx0XHR0aGlzLm1hdC5zZXQoaXRlbXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0aWRlbnRpdHkoKTogTWF0NHg0IHtcblx0XHRyZXR1cm4gdGhpcy5zZXRBbGwoXG5cdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCwgMCxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cdFx0KVxuXHR9XG5cblx0emVybygpOiBNYXQ0eDQge1xuXHRcdHJldHVybiB0aGlzLnNldEFsbChcblx0XHRcdDAsIDAsIDAsIDAsXG5cdFx0XHQwLCAwLCAwLCAwLFxuXHRcdFx0MCwgMCwgMCwgMCxcblx0XHRcdDAsIDAsIDAsIDBcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1ha2VzIHRoaXMgTWF0NHg0IGEgcm90YXRpb24gbWF0cml4IG9mIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHJhZGlhbnMgY2N3XG5cdCAqIEBwYXJhbSB6UmFkaWFucyBUaGUgbnVtYmVyIG9mIHJhZGlhbnMgdG8gcm90YXRlXG5cdCAqIEByZXR1cm5zIHRoaXMgTWF0NHg0XG5cdCAqL1xuXHRyb3RhdGUoelJhZGlhbnM6IG51bWJlcik6IE1hdDR4NCB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxuXHRcdFx0TWF0aC5jb3MoelJhZGlhbnMpLCAtTWF0aC5zaW4oelJhZGlhbnMpLCBcdDAsIDAsXG5cdFx0XHRNYXRoLnNpbih6UmFkaWFucyksIE1hdGguY29zKHpSYWRpYW5zKSwgXHQwLCAwLFxuXHRcdFx0MCwgXHRcdFx0XHRcdDAsIFx0XHRcdFx0XHRcdDEsIDAsXG5cdFx0XHQwLCBcdFx0XHRcdFx0MCwgXHRcdFx0XHRcdFx0MCwgMVxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogVHVybnMgdGhpcyBNYXQ0eDQgaW50byBhIHRyYW5zbGF0aW9uIG1hdHJpeCBvZiB0aGUgc3BlY2lmaWVkIHRyYW5zbGF0aW9uXG5cdCAqIEBwYXJhbSB0cmFuc2xhdGlvbiBUaGUgdHJhbnNsYXRpb24gaW4geCBhbmQgeVxuXHQgKiBAcmV0dXJucyB0aGlzIE1hdDR4NFxuXHQgKi9cblx0dHJhbnNsYXRlKHRyYW5zbGF0aW9uOiBWZWMyIHwgRmxvYXQzMkFycmF5KTogTWF0NHg0IHtcblx0XHQvLyBJZiB0cmFuc2xhdGlvbiBpcyBhIHZlYywgZ2V0IGl0cyBhcnJheVxuXHRcdGlmKHRyYW5zbGF0aW9uIGluc3RhbmNlb2YgVmVjMil7XG5cdFx0XHR0cmFuc2xhdGlvbiA9IHRyYW5zbGF0aW9uLnRvQXJyYXkoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRBbGwoXG5cdFx0XHQxLCAwLCAwLCB0cmFuc2xhdGlvblswXSxcblx0XHRcdDAsIDEsIDAsIHRyYW5zbGF0aW9uWzFdLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblx0XHQpO1xuXHR9XG5cblx0c2NhbGUoc2NhbGU6IFZlYzIgfCBGbG9hdDMyQXJyYXkgfCBudW1iZXIpOiBNYXQ0eDQge1xuXHRcdC8vIE1ha2Ugc3VyZSBzY2FsZSBpcyBhIGZsb2F0MzJBcnJheVxuXHRcdGlmKHNjYWxlIGluc3RhbmNlb2YgVmVjMil7XG5cdFx0XHRzY2FsZSA9IHNjYWxlLnRvQXJyYXkoKTtcblx0XHR9IGVsc2UgaWYoIShzY2FsZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpe1xuXHRcdFx0c2NhbGUgPSBuZXcgRmxvYXQzMkFycmF5KFtzY2FsZSwgc2NhbGVdKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRBbGwoXG5cdFx0XHRzY2FsZVswXSwgMCwgXHRcdDAsIDAsXG5cdFx0XHQwLCBcdFx0ICBzY2FsZVsxXSwgMCwgMCxcblx0XHRcdDAsIFx0XHQgIDAsXHRcdDEsIDAsXG5cdFx0XHQwLCBcdFx0ICAwLFx0XHQwLCAxXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IE1hdDR4NCB0aGF0IHJlcHJlc2VudHMgdGhlIHJpZ2h0IHNpZGUgbXVsdGlwbGljYXRpb24gVEhJUyB4IE9USEVSXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgTWF0NHg0IHRvIG11bHRpcGx5IGJ5XG5cdCAqIEByZXR1cm5zIGEgbmV3IE1hdDR4NCBjb250YWluaW5nIHRoZSBwcm9kdWN0IG9mIHRoZXNlIHR3byBNYXQ0eDRzXG5cdCAqL1xuXHRtdWx0KG90aGVyOiBNYXQ0eDQsIG91dD86IE1hdDR4NCk6IE1hdDR4NCB7XG5cdFx0bGV0IHRlbXAgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcblxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCA0OyBpKyspe1xuXHRcdFx0Zm9yKGxldCBqID0gMDsgaiA8IDQ7IGorKyl7XG5cdFx0XHRcdGxldCB2YWx1ZSA9IDA7XG5cdFx0XHRcdGZvcihsZXQgayA9IDA7IGsgPCA0OyBrKyspe1xuXHRcdFx0XHRcdHZhbHVlICs9IHRoaXMuZ2V0KGssIGkpICogb3RoZXIuZ2V0KGosIGspO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRlbXBbaio0ICsgaV0gID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYob3V0ICE9PSB1bmRlZmluZWQpe1xuXHRcdFx0cmV0dXJuIG91dC5zZXRBbGwoLi4udGVtcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgTWF0NHg0KCkuc2V0QWxsKC4uLnRlbXApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVzIGFsbCBnaXZlbiBtYXRyaWNpZXMgaW4gb3JkZXIuIGUuZy4gTVVMVChBLCBCLCBDKSAtPiBBKkIqQ1xuXHQgKiBAcGFyYW0gbWF0cyBBIGxpc3Qgb2YgTWF0NHg0cyB0byBtdWx0aXBseSBpbiBvcmRlclxuXHQgKiBAcmV0dXJucyBBIG5ldyBNYXQ0eDQgaG9sZGluZyB0aGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb25cblx0ICovXG5cdHN0YXRpYyBNVUxUKC4uLm1hdHM6IEFycmF5PE1hdDR4ND4pOiBNYXQ0eDQge1xuXHRcdC8vIENyZWF0ZSBhIG5ldyBhcnJheVxuXHRcdGxldCB0ZW1wID0gTWF0NHg0LklERU5USVRZO1xuXG5cdFx0Ly8gTXVsdGlwbHkgYnkgZXZlcnkgYXJyYXkgaW4gb3JkZXIsIGluIHBsYWNlXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IG1hdHMubGVuZ3RoOyBpKyspe1xuXHRcdFx0dGVtcC5tdWx0KG1hdHNbaV0sIHRlbXApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0ZW1wO1xuXHR9XG5cblx0dG9BcnJheSgpOiBGbG9hdDMyQXJyYXkge1xuXHRcdHJldHVybiB0aGlzLm1hdDtcblx0fVxuXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICBgfCR7dGhpcy5tYXRbMF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMV0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMl0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbM10udG9GaXhlZCgyKX18XFxuYCArIFxuXHRcdFx0XHRgfCR7dGhpcy5tYXRbNF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbNV0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbNl0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbN10udG9GaXhlZCgyKX18XFxuYCArXG5cdFx0XHRcdGB8JHt0aGlzLm1hdFs4XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs5XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxMF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTFdLnRvRml4ZWQoMil9fFxcbmAgK1xuXHRcdFx0XHRgfCR7dGhpcy5tYXRbMTJdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzEzXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxNF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTVdLnRvRml4ZWQoMil9fGA7XG5cdH1cbn0iLCJpbXBvcnQgUGh5c2ljYWwgZnJvbSBcIi4uL0ludGVyZmFjZXMvUGh5c2ljYWxcIjtcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcbmltcG9ydCBIaXQgZnJvbSBcIi4vSGl0XCI7XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IGNvbnRhaW5zIHRoZSBhcmVhIG9mIG92ZXJsYXAgb2YgdHdvIGNvbGxpZGluZyBvYmplY3RzIHRvIGFsbG93IGZvciBzb3J0aW5nIGJ5IHRoZSBwaHlzaWNzIHN5c3RlbS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJlYUNvbGxpc2lvbiB7XG4gICAgLyoqIFRoZSBhcmVhIG9mIHRoZSBvdmVybGFwIGZvciB0aGUgY29sbGlkaW5nIG9iamVjdHMgKi9cbiAgICBhcmVhOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIEFBQkIgb2YgdGhlIG90aGVyIGNvbGxpZGVyIGluIHRoaXMgY29sbGlzaW9uICovXG4gICAgY29sbGlkZXI6IEFBQkI7XG5cbiAgICAvKiogVHlwZSBvZiB0aGUgY29sbGlzaW9uICovXG4gICAgdHlwZTogc3RyaW5nO1xuXG4gICAgLyoqIFRoZXIgb3RoZXIgb2JqZWN0IGluIHRoZSBjb2xsaXNpb24gKi9cbiAgICBvdGhlcjogUGh5c2ljYWw7XG5cbiAgICAvKiogVGhlIHRpbGUsIGlmIHRoaXMgd2FzIGEgdGlsZW1hcCBjb2xsaXNpb24gKi9cbiAgICB0aWxlOiBWZWMyO1xuXG4gICAgLyoqIFRoZSBwaHlzaWNzIGhpdCBmb3IgdGhpcyBvYmplY3QgKi9cbiAgICBoaXQ6IEhpdDtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQXJlYUNvbGxpc2lvbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gYXJlYSBUaGUgYXJlYSBvZiB0aGUgY29sbGlzaW9uXG4gICAgICogQHBhcmFtIGNvbGxpZGVyIFRoZSBvdGhlciBjb2xsaWRlclxuICAgICAqL1xuXHRjb25zdHJ1Y3RvcihhcmVhOiBudW1iZXIsIGNvbGxpZGVyOiBBQUJCLCBvdGhlcjogUGh5c2ljYWwsIHR5cGU6IHN0cmluZywgdGlsZTogVmVjMil7XG5cdFx0dGhpcy5hcmVhID0gYXJlYTtcbiAgICAgICAgdGhpcy5jb2xsaWRlciA9IGNvbGxpZGVyO1xuICAgICAgICB0aGlzLm90aGVyID0gb3RoZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudGlsZSA9IHRpbGU7XG5cdH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xuXG4vKipcbiAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGRhdGEgY29sbGVjdGVkIGZyb20gYSBwaHlzaWNzIGhpdCBiZXR3ZWVuIHR3byBnZW9tZXRyaWMgb2JqZWN0cy5cbiAqIEluc3BpcmVkIGJ5IHRoZSBoZWxwZnVsIGNvbGxpc2lvbiBkb2N1bWVudGF0aW9uIEBsaW5rKGhlcmUpKGh0dHBzOi8vbm9vbmF0LmdpdGh1Yi5pby9pbnRlcnNlY3QvKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGl0IHtcbiAgICAvKiogVGhlIHRpbWUgb2YgdGhlIGNvbGxpc2lvbi4gT25seSBudW1iZXJzIDAgdGhyb3VnaCAxIGhhcHBlbiBpbiB0aGlzIGZyYW1lLiAqL1xuICAgIHRpbWU6IG51bWJlcjtcbiAgICAvKiogVGhlIG5lYXIgdGltZXMgb2YgdGhlIGNvbGxpc2lvbiAqL1xuICAgIG5lYXJUaW1lczogVmVjMiA9IFZlYzIuWkVSTztcbiAgICAvKiogVGhlIHBvc2l0aW9uIG9mIHRoZSBjb2xsaXNpb24gKi9cbiAgICBwb3M6IFZlYzIgPSBWZWMyLlpFUk87XG4gICAgLyoqIFRoZSBvdmVybGFwIGRpc3RhbmNlIG9mIHRoZSBoaXQgKi9cbiAgICBkZWx0YTogVmVjMiA9IFZlYzIuWkVSTztcbiAgICAvKiogVGhlIG5vcm1hbCB2ZWN0b3Igb2YgdGhlIGhpdCAqL1xuICAgIG5vcm1hbDogVmVjMiA9IFZlYzIuWkVSTztcbn0iLCJpbXBvcnQgQ29sbGVjdGlvbiBmcm9tIFwiLi9Db2xsZWN0aW9uXCI7XG5cbi8qKlxuICogQSBGSUZPIHF1ZXVlIHdpdGggZWxlbWVudHMgb2YgdHlwZSBUXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1ZXVlPFQ+IGltcGxlbWVudHMgQ29sbGVjdGlvbiB7XG4gICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgUXVldWUgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IE1BWF9FTEVNRU5UUzogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcXVldWUgKi9cbiAgICBwcml2YXRlIHE6IEFycmF5PFQ+O1xuICAgIFxuICAgIC8qKiBUaGUgaGVhZCBvZiB0aGUgcXVldWUgKi9cbiAgICBwcml2YXRlIGhlYWQ6IG51bWJlcjtcbiAgICBcbiAgICAvKiogVGhlIHRhaWwgb2YgdGhlIHF1ZXVlICovXG4gICAgcHJpdmF0ZSB0YWlsOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBxdWV1ZSAqL1xuICAgIHByaXZhdGUgc2l6ZTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBxdWV1ZVxuICAgICAqIEBwYXJhbSBtYXhFbGVtZW50cyBUaGUgbWF4aW11bSBzaXplIG9mIHRoZSBzdGFja1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1heEVsZW1lbnRzOiBudW1iZXIgPSAxMDApe1xuICAgICAgICB0aGlzLk1BWF9FTEVNRU5UUyA9IG1heEVsZW1lbnRzO1xuICAgICAgICB0aGlzLnEgPSBuZXcgQXJyYXkodGhpcy5NQVhfRUxFTUVOVFMpO1xuICAgICAgICB0aGlzLmhlYWQgPSAwO1xuICAgICAgICB0aGlzLnRhaWwgPSAwO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gaXRlbSB0byB0aGUgYmFjayBvZiB0aGUgcXVldWVcbiAgICAgKiBAcGFyYW0gaXRlbSBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIGJhY2sgb2YgdGhlIHF1ZXVlXG4gICAgICovXG4gICAgZW5xdWV1ZShpdGVtOiBUKTogdm9pZHtcbiAgICAgICAgaWYoKHRoaXMudGFpbCArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFMgPT09IHRoaXMuaGVhZCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdWV1ZSBmdWxsIC0gY2Fubm90IGFkZCBlbGVtZW50XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaXplICs9IDE7XG4gICAgICAgIHRoaXMucVt0aGlzLnRhaWxdID0gaXRlbTtcbiAgICAgICAgdGhpcy50YWlsID0gKHRoaXMudGFpbCArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIGl0ZW0gZnJvbSB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxuICAgICAqL1xuICAgIGRlcXVldWUoKTogVCB7XG4gICAgICAgIGlmKHRoaXMuaGVhZCA9PT0gdGhpcy50YWlsKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIGVtcHR5IC0gY2Fubm90IHJlbW92ZSBlbGVtZW50XCIpO1xuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLnNpemUgLT0gMTtcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLnFbdGhpcy5oZWFkXTtcbiAgICAgICAgLy8gTm93IGRlbGV0ZSB0aGUgaXRlbVxuICAgICAgICBkZWxldGUgdGhpcy5xW3RoaXMuaGVhZF07XG4gICAgICAgIHRoaXMuaGVhZCA9ICh0aGlzLmhlYWQgKyAxKSAlIHRoaXMuTUFYX0VMRU1FTlRTO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaXRlbSBhdCB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlLCBidXQgZG9lcyBub3QgcmVtb3ZlIGl0XG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxuICAgICAqL1xuICAgIHBlZWtOZXh0KCk6IFQge1xuICAgICAgICBpZih0aGlzLmhlYWQgPT09IHRoaXMudGFpbCl7XG4gICAgICAgICAgICB0aHJvdyBcIlF1ZXVlIGVtcHR5IC0gY2Fubm90IGdldCBlbGVtZW50XCJcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5xW3RoaXMuaGVhZF07XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHF1ZXVlIGhhcyBpdGVtcyBpbiBpdCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIHF1ZXVlIGhhcyBpdGVtc1xuICAgICAqL1xuICAgIGhhc0l0ZW1zKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkICE9PSB0aGlzLnRhaWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBxdWV1ZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2l6ZSBvZiB0aGUgcXVldWVcbiAgICAgKi9cbiAgICBnZXRTaXplKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgfVxuXG4gICAgLy8gQGltcGxlbWVudGVkXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IGRlbGV0ZSB0aGlzLnFbaW5kZXhdKTtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsO1xuICAgIH1cblxuICAgIC8vIEBpbXBsZW1lbnRlZFxuICAgIGZvckVhY2goZnVuYzogKGl0ZW06IFQsIGluZGV4PzogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIGxldCBpID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZShpICE9PSB0aGlzLnRhaWwpe1xuICAgICAgICAgICAgZnVuYyh0aGlzLnFbaV0sIGkpO1xuICAgICAgICAgICAgaSA9IChpICsgMSkgJSB0aGlzLk1BWF9FTEVNRU5UUztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgcXVldWUgaW50byBhIHN0cmluZyBmb3JtYXRcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBxdWV1ZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIGxldCByZXR2YWwgPSBcIlwiO1xuXG4gICAgICAgIHRoaXMuZm9yRWFjaCggKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RyID0gaXRlbS50b1N0cmluZygpXG4gICAgICAgICAgICBpZihpbmRleCAhPT0gMCl7XG4gICAgICAgICAgICAgICAgc3RyICs9IFwiIC0+IFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR2YWwgPSBzdHIgKyByZXR2YWw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBcIlRvcCAtPiBcIiArIHJldHZhbDtcbiAgICB9XG59IiwiLyoqIEEgY29udGFpbmVyIGZvciBpbmZvIGFib3V0IGEgd2ViR0wgc2hhZGVyIHByb2dyYW0gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMUHJvZ3JhbVR5cGUge1xuXHQvKiogQSB3ZWJHTCBwcm9ncmFtICovXG5cdHByb2dyYW06IFdlYkdMUHJvZ3JhbTtcblx0XG5cdC8qKiBBIHZlcnRleCBzaGFkZXIgKi9cblx0dmVydGV4U2hhZGVyOiBXZWJHTFNoYWRlcjtcblxuXHQvKiogQSBmcmFnbWVudCBzaGFkZXIgKi9cblx0ZnJhZ21lbnRTaGFkZXI6IFdlYkdMU2hhZGVyO1xuXG5cdC8qKlxuXHQgKiBEZWxldGVzIHRoaXMgc2hhZGVyIHByb2dyYW1cblx0ICovXG5cdGRlbGV0ZShnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogdm9pZCB7XG5cdFx0Ly8gQ2xlYW4gdXAgYWxsIGFzcGVjdHMgb2YgdGhpcyBwcm9ncmFtXG5cdFx0aWYodGhpcy5wcm9ncmFtKXtcblx0XHRcdGdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcblx0XHR9XG5cdFx0XHRcblx0XHRpZih0aGlzLnZlcnRleFNoYWRlcil7XG5cdFx0XHRnbC5kZWxldGVTaGFkZXIodGhpcy52ZXJ0ZXhTaGFkZXIpO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMuZnJhZ21lbnRTaGFkZXIpe1xuXHRcdFx0Z2wuZGVsZXRlU2hhZGVyKHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xuXHRcdH1cblx0fVxufSIsImltcG9ydCBTaGFwZSBmcm9tIFwiLi9TaGFwZVwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uLy4uL1V0aWxzL01hdGhVdGlsc1wiO1xuaW1wb3J0IENpcmNsZSBmcm9tIFwiLi9DaXJjbGVcIjtcbmltcG9ydCBIaXQgZnJvbSBcIi4uL1BoeXNpY3MvSGl0XCI7XG5cbi8qKlxuICogQW4gQXhpcy1BbGlnbmVkIEJvdW5kaW5nIEJveC4gSW4gb3RoZXIgd29yZHMsIGEgcmVjdGFuZ2xlIHRoYXQgaXMgYWx3YXlzIGFsaWduZWQgdG8gdGhlIHgteSBncmlkLlxuICogSW5zcGlyZWQgYnkgdGhlIGhlbHBmdWwgY29sbGlzaW9uIGRvY3VtZW50YXRpb24gQGxpbmsoaGVyZSkoaHR0cHM6Ly9ub29uYXQuZ2l0aHViLmlvL2ludGVyc2VjdC8pLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBQUJCIGV4dGVuZHMgU2hhcGUge1xuICAgIGNlbnRlcjogVmVjMjtcbiAgICBoYWxmU2l6ZTogVmVjMjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQUFCQlxuICAgICAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgQUFCQlxuICAgICAqIEBwYXJhbSBoYWxmU2l6ZSBUaGUgaGFsZiBzaXplIG9mIHRoZSBBQUJCIC0gVGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0byBhbiBlZGdlIGluIHggYW5kIHlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjZW50ZXI/OiBWZWMyLCBoYWxmU2l6ZT86IFZlYzIpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNlbnRlciA9IGNlbnRlciA/IGNlbnRlciA6IG5ldyBWZWMyKDAsIDApO1xuICAgICAgICB0aGlzLmhhbGZTaXplID0gaGFsZlNpemUgPyBoYWxmU2l6ZSA6IG5ldyBWZWMyKDAsIDApO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cbiAgICBnZXQgdG9wTGVmdCgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMubGVmdCwgdGhpcy50b3ApXG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgYSBwb2ludCByZXByZXNlbnRpbmcgdGhlIHRvcCByaWdodCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cbiAgICBnZXQgdG9wUmlnaHQoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLnJpZ2h0LCB0aGlzLnRvcClcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyBhIHBvaW50IHJlcHJlc2VudGluZyB0aGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSBBQUJCICovXG4gICAgZ2V0IGJvdHRvbUxlZnQoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLmxlZnQsIHRoaXMuYm90dG9tKVxuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBBQUJCICovXG4gICAgZ2V0IGJvdHRvbVJpZ2h0KCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy5yaWdodCwgdGhpcy5ib3R0b20pXG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCk6IEFBQkIge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIGdldEJvdW5kaW5nQ2lyY2xlKCk6IENpcmNsZSB7XG4gICAgICAgIGxldCByID0gTWF0aC5tYXgodGhpcy5odywgdGhpcy5oaClcbiAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGUodGhpcy5jZW50ZXIuY2xvbmUoKSwgcik7XG4gICAgfVxuXG4gICAgLy8gQGRlcHJlY2F0ZWRcbiAgICBnZXRIYWxmU2l6ZSgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFsZlNpemU7XG4gICAgfVxuXG4gICAgLy8gQGRlcHJlY2F0ZWRcbiAgICBzZXRIYWxmU2l6ZShoYWxmU2l6ZTogVmVjMik6IHZvaWQge1xuICAgICAgICB0aGlzLmhhbGZTaXplID0gaGFsZlNpemU7XG4gICAgfVxuXG4gICAgLy8gVE9ETyAtIG1vdmUgdGhlc2UgYWxsIHRvIHRoZSBTaGFwZSBjbGFzc1xuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgYSBwb2ludFxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcbiAgICAgKi9cbiAgICBjb250YWluc1BvaW50KHBvaW50OiBWZWMyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBwb2ludC54ID49IHRoaXMueCAtIHRoaXMuaHcgJiYgcG9pbnQueCA8PSB0aGlzLnggKyB0aGlzLmh3XG4gICAgICAgICAgICAmJiBwb2ludC55ID49IHRoaXMueSAtIHRoaXMuaGggJiYgcG9pbnQueSA8PSB0aGlzLnkgKyB0aGlzLmhoXG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgYSBwb2ludFxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgZHggPSBwb2ludC54IC0gdGhpcy54O1xuICAgICAgICBsZXQgcHggPSB0aGlzLmh3IC0gTWF0aC5hYnMoZHgpO1xuICAgICAgICBcbiAgICAgICAgaWYocHggPD0gMCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZHkgPSBwb2ludC55IC0gdGhpcy55O1xuICAgICAgICBsZXQgcHkgPSB0aGlzLmhoIC0gTWF0aC5hYnMoZHkpO1xuXG4gICAgICAgIGlmKHB5IDw9IDApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIGEgcG9pbnQgd2l0aCBzb2Z0IGxlZnQgYW5kIHRvcCBib3VuZGFyaWVzLlxuICAgICAqIEluIG90aGVyIHdvcmRzLCBpZiB0aGUgdG9wIGxlZnQgaXMgKDAsIDApLCB0aGUgcG9pbnQgKDAsIDApIGlzIG5vdCBpbiB0aGUgQUFCQlxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcbiAgICAgKi9cbiAgICBjb250YWluc1BvaW50U29mdChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gcG9pbnQueCA+IHRoaXMueCAtIHRoaXMuaHcgJiYgcG9pbnQueCA8PSB0aGlzLnggKyB0aGlzLmh3XG4gICAgICAgICAgICAmJiBwb2ludC55ID4gdGhpcy55IC0gdGhpcy5oaCAmJiBwb2ludC55IDw9IHRoaXMueSArIHRoaXMuaGhcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRhdGEgZnJvbSB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoaXMgQUFCQiB3aXRoIGEgbGluZSBzZWdtZW50IGZyb20gYSBwb2ludCBpbiBhIGRpcmVjdGlvblxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdGhhdCB0aGUgbGluZSBzZWdtZW50IHN0YXJ0cyBmcm9tXG4gICAgICogQHBhcmFtIGRlbHRhIFRoZSBkaXJlY3Rpb24gYW5kIGRpc3RhbmNlIG9mIHRoZSBzZWdtZW50XG4gICAgICogQHBhcmFtIHBhZGRpbmcgUGFkcyB0aGUgQUFCQiB0byBtYWtlIGl0IHdpZGVyIGZvciB0aGUgaW50ZXJzZWN0aW9uIHRlc3RcbiAgICAgKiBAcmV0dXJucyBUaGUgSGl0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGludGVyc2VjdGlvbiwgb3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gaW50ZXJzZWN0aW9uXG4gICAgICovXG4gICAgaW50ZXJzZWN0U2VnbWVudChwb2ludDogVmVjMiwgZGVsdGE6IFZlYzIsIHBhZGRpbmc/OiBWZWMyKTogSGl0IHtcbiAgICAgICAgbGV0IHBhZGRpbmdYID0gcGFkZGluZyA/IHBhZGRpbmcueCA6IDA7XG4gICAgICAgIGxldCBwYWRkaW5nWSA9IHBhZGRpbmcgPyBwYWRkaW5nLnkgOiAwO1xuXG4gICAgICAgIGxldCBzY2FsZVggPSAxL2RlbHRhLng7XG4gICAgICAgIGxldCBzY2FsZVkgPSAxL2RlbHRhLnk7XG5cbiAgICAgICAgbGV0IHNpZ25YID0gTWF0aFV0aWxzLnNpZ24oc2NhbGVYKTtcbiAgICAgICAgbGV0IHNpZ25ZID0gTWF0aFV0aWxzLnNpZ24oc2NhbGVZKTtcblxuICAgICAgICBsZXQgdG5lYXJ4ID0gc2NhbGVYKih0aGlzLnggLSBzaWduWCoodGhpcy5odyArIHBhZGRpbmdYKSAtIHBvaW50LngpO1xuICAgICAgICBsZXQgdG5lYXJ5ID0gc2NhbGVZKih0aGlzLnkgLSBzaWduWSoodGhpcy5oaCArIHBhZGRpbmdZKSAtIHBvaW50LnkpO1xuICAgICAgICBsZXQgdGZhcnggPSBzY2FsZVgqKHRoaXMueCArIHNpZ25YKih0aGlzLmh3ICsgcGFkZGluZ1gpIC0gcG9pbnQueCk7XG4gICAgICAgIGxldCB0ZmFyeSA9IHNjYWxlWSoodGhpcy55ICsgc2lnblkqKHRoaXMuaGggKyBwYWRkaW5nWSkgLSBwb2ludC55KTtcbiAgICAgICAgXG4gICAgICAgIGlmKHRuZWFyeCA+IHRmYXJ5IHx8IHRuZWFyeSA+IHRmYXJ4KXtcbiAgICAgICAgICAgIC8vIFdlIGFyZW4ndCBjb2xsaWRpbmcgLSB3ZSBjbGVhciBvbmUgYXhpcyBiZWZvcmUgaW50ZXJzZWN0aW5nIGFub3RoZXJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRuZWFyID0gTWF0aC5tYXgodG5lYXJ4LCB0bmVhcnkpO1xuXG4gICAgICAgIC8vIERvdWJsZSBjaGVjayBmb3IgTmFOc1xuICAgICAgICBpZih0bmVhcnggIT09IHRuZWFyeCl7XG4gICAgICAgICAgICB0bmVhciA9IHRuZWFyeTtcbiAgICAgICAgfSBlbHNlIGlmICh0bmVhcnkgIT09IHRuZWFyeSl7XG4gICAgICAgICAgICB0bmVhciA9IHRuZWFyeDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0ZmFyID0gTWF0aC5taW4odGZhcngsIHRmYXJ5KTtcblxuICAgICAgICBpZih0bmVhciA9PT0gLUluZmluaXR5KXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodG5lYXIgPj0gMSB8fCB0ZmFyIDw9IDApe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBhcmUgY29sbGlkaW5nXG4gICAgICAgIGxldCBoaXQgPSBuZXcgSGl0KCk7XG4gICAgICAgIGhpdC50aW1lID0gTWF0aFV0aWxzLmNsYW1wMDEodG5lYXIpO1xuICAgICAgICBoaXQubmVhclRpbWVzLnggPSB0bmVhcng7XG4gICAgICAgIGhpdC5uZWFyVGltZXMueSA9IHRuZWFyeTtcblxuICAgICAgICBpZih0bmVhcnggPiB0bmVhcnkpe1xuICAgICAgICAgICAgLy8gV2UgaGl0IG9uIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpemVcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueCA9IC1zaWduWDtcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZihNYXRoLmFicyh0bmVhcnggLSB0bmVhcnkpIDwgMC4wMDAxKXtcbiAgICAgICAgICAgIC8vIFdlIGhpdCBvbiB0aGUgY29ybmVyXG4gICAgICAgICAgICBoaXQubm9ybWFsLnggPSAtc2lnblg7XG4gICAgICAgICAgICBoaXQubm9ybWFsLnkgPSAtc2lnblk7XG4gICAgICAgICAgICBoaXQubm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgaGl0IG9uIHRoZSB0b3Agb3IgYm90dG9tXG4gICAgICAgICAgICBoaXQubm9ybWFsLnggPSAwO1xuICAgICAgICAgICAgaGl0Lm5vcm1hbC55ID0gLXNpZ25ZO1xuICAgICAgICB9XG5cbiAgICAgICAgaGl0LmRlbHRhLnggPSAoMS4wIC0gaGl0LnRpbWUpICogLWRlbHRhLng7XG4gICAgICAgIGhpdC5kZWx0YS55ID0gKDEuMCAtIGhpdC50aW1lKSAqIC1kZWx0YS55O1xuICAgICAgICBoaXQucG9zLnggPSBwb2ludC54ICsgZGVsdGEueCAqIGhpdC50aW1lO1xuICAgICAgICBoaXQucG9zLnkgPSBwb2ludC55ICsgZGVsdGEueSAqIGhpdC50aW1lO1xuXG4gICAgICAgIHJldHVybiBoaXQ7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgb3ZlcmxhcHMob3RoZXI6IFNoYXBlKTogYm9vbGVhbiB7XG4gICAgICAgIGlmKG90aGVyIGluc3RhbmNlb2YgQUFCQil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdmVybGFwc0FBQkIob3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IFwiT3ZlcmxhcCBub3QgZGVmaW5lZCBiZXR3ZWVuIHRoZXNlIHNoYXBlcy5cIlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgb3ZlcmxhcHMgYW5vdGhlclxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgQUFCQiB0byBjaGVjayBhZ2FpbnN0XG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGlzIEFBQkIgb3ZlcmxhcHMgdGhlIG90aGVyLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgb3ZlcmxhcHNBQUJCKG90aGVyOiBBQUJCKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBkeCA9IG90aGVyLnggLSB0aGlzLng7XG4gICAgICAgIGxldCBweCA9IHRoaXMuaHcgKyBvdGhlci5odyAtIE1hdGguYWJzKGR4KTtcbiAgICAgICAgXG4gICAgICAgIGlmKHB4IDw9IDApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGR5ID0gb3RoZXIueSAtIHRoaXMueTtcbiAgICAgICAgbGV0IHB5ID0gdGhpcy5oaCArIG90aGVyLmhoIC0gTWF0aC5hYnMoZHkpO1xuXG4gICAgICAgIGlmKHB5IDw9IDApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZXNlIEFBQkJzIGFyZSBKVVNUIHRvdWNoaW5nIC0gbm90IG92ZXJsYXBwaW5nLlxuICAgICAqIFZlYzIueCBpcyAtMSBpZiB0aGUgb3RoZXIgaXMgdG8gdGhlIGxlZnQsIDEgaWYgdG8gdGhlIHJpZ2h0LlxuICAgICAqIExpa2V3aXNlLCBWZWMyLnkgaXMgLTEgaWYgdGhlIG90aGVyIGlzIG9uIHRvcCwgMSBpZiBvbiBib3R0b20uXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBBQUJCIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgVGhlIGNvbGxpc2lvbiBzaWRlcyBzdG9yZWQgaW4gYSBWZWMyIGlmIHRoZSBBQUJCcyBhcmUgdG91Y2hpbmcsIG51bGwgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgdG91Y2hlc0FBQkIob3RoZXI6IEFBQkIpOiBWZWMyIHtcbiAgICAgICAgbGV0IGR4ID0gb3RoZXIueCAtIHRoaXMueDtcbiAgICAgICAgbGV0IHB4ID0gdGhpcy5odyArIG90aGVyLmh3IC0gTWF0aC5hYnMoZHgpO1xuXG4gICAgICAgIGxldCBkeSA9IG90aGVyLnkgLSB0aGlzLnk7XG4gICAgICAgIGxldCBweSA9IHRoaXMuaGggKyBvdGhlci5oaCAtIE1hdGguYWJzKGR5KTtcblxuICAgICAgICAvLyBJZiBvbmUgYXhpcyBpcyBqdXN0IHRvdWNoaW5nIGFuZCB0aGUgb3RoZXIgaXMgb3ZlcmxhcHBpbmcsIHRydWVcbiAgICAgICAgaWYoKHB4ID09PSAwICYmIHB5ID49IDApIHx8IChweSA9PT0gMCAmJiBweCA+PSAwKSl7XG4gICAgICAgICAgICBsZXQgcmV0ID0gbmV3IFZlYzIoKTtcblxuICAgICAgICAgICAgaWYocHggPT09IDApe1xuICAgICAgICAgICAgICAgIHJldC54ID0gb3RoZXIueCA8IHRoaXMueCA/IC0xIDogMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYocHkgPT09IDApe1xuICAgICAgICAgICAgICAgIHJldC55ID0gb3RoZXIueSA8IHRoaXMueSA/IC0xIDogMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZXNlIEFBQkJzIGFyZSBKVVNUIHRvdWNoaW5nIC0gbm90IG92ZXJsYXBwaW5nLlxuICAgICAqIEFsc28sIGlmIHRoZXkgYXJlIG9ubHkgdG91Y2hpbmcgY29ybmVycywgdGhleSBhcmUgY29uc2lkZXJlZCBub3QgdG91Y2hpbmcuXG4gICAgICogVmVjMi54IGlzIC0xIGlmIHRoZSBvdGhlciBpcyB0byB0aGUgbGVmdCwgMSBpZiB0byB0aGUgcmlnaHQuXG4gICAgICogTGlrZXdpc2UsIFZlYzIueSBpcyAtMSBpZiB0aGUgb3RoZXIgaXMgb24gdG9wLCAxIGlmIG9uIGJvdHRvbS5cbiAgICAgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIEFBQkIgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBUaGUgc2lkZSBvZiB0aGUgdG91Y2gsIHN0b3JlZCBhcyBhIFZlYzIsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gdG91Y2hcbiAgICAgKi9cbiAgICB0b3VjaGVzQUFCQldpdGhvdXRDb3JuZXJzKG90aGVyOiBBQUJCKTogVmVjMiB7XG4gICAgICAgIGxldCBkeCA9IG90aGVyLnggLSB0aGlzLng7XG4gICAgICAgIGxldCBweCA9IHRoaXMuaHcgKyBvdGhlci5odyAtIE1hdGguYWJzKGR4KTtcblxuICAgICAgICBsZXQgZHkgPSBvdGhlci55IC0gdGhpcy55O1xuICAgICAgICBsZXQgcHkgPSB0aGlzLmhoICsgb3RoZXIuaGggLSBNYXRoLmFicyhkeSk7XG5cbiAgICAgICAgLy8gSWYgb25lIGF4aXMgaXMgdG91Y2hpbmcsIGFuZCB0aGUgb3RoZXIgaXMgc3RyaWN0bHkgb3ZlcmxhcHBpbmdcbiAgICAgICAgaWYoKHB4ID09PSAwICYmIHB5ID4gMCkgfHwgKHB5ID09PSAwICYmIHB4ID4gMCkpe1xuICAgICAgICAgICAgbGV0IHJldCA9IG5ldyBWZWMyKCk7XG5cbiAgICAgICAgICAgIGlmKHB4ID09PSAwKXtcbiAgICAgICAgICAgICAgICByZXQueCA9IG90aGVyLnggPCB0aGlzLnggPyAtMSA6IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldC55ID0gb3RoZXIueSA8IHRoaXMueSA/IC0xIDogMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhcmVhIG9mIHRoZSBvdmVybGFwIGJldHdlZW4gdGhpcyBBQUJCIGFuZCBhbm90aGVyXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBBQUJCXG4gICAgICogQHJldHVybnMgVGhlIGFyZWEgb2YgdGhlIG92ZXJsYXAgYmV0d2VlbiB0aGUgQUFCQnNcbiAgICAgKi9cbiAgICBvdmVybGFwQXJlYShvdGhlcjogQUFCQik6IG51bWJlciB7XG4gICAgICAgIGxldCBsZWZ0eCA9IE1hdGgubWF4KHRoaXMueCAtIHRoaXMuaHcsIG90aGVyLnggLSBvdGhlci5odyk7XG4gICAgICAgIGxldCByaWdodHggPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLmh3LCBvdGhlci54ICsgb3RoZXIuaHcpO1xuICAgICAgICBsZXQgZHggPSByaWdodHggLSBsZWZ0eDtcblxuICAgICAgICBsZXQgbGVmdHkgPSBNYXRoLm1heCh0aGlzLnkgLSB0aGlzLmhoLCBvdGhlci55IC0gb3RoZXIuaGgpO1xuICAgICAgICBsZXQgcmlnaHR5ID0gTWF0aC5taW4odGhpcy55ICsgdGhpcy5oaCwgb3RoZXIueSArIG90aGVyLmhoKTtcbiAgICAgICAgbGV0IGR5ID0gcmlnaHR5IC0gbGVmdHk7XG5cbiAgICAgICAgaWYoZHggPCAwIHx8IGR5IDwgMCkgcmV0dXJuIDA7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZHgqZHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW5kIHJlc2l6ZXMgdGhpcyByZWN0IGZyb20gaXRzIGN1cnJlbnQgcG9zaXRpb24gdG8gdGhlIHBvc2l0aW9uIHNwZWNpZmllZFxuICAgICAqIEBwYXJhbSB2ZWxvY2l0eSBUaGUgbW92ZW1lbnQgb2YgdGhlIHJlY3QgZnJvbSBpdHMgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gZnJvbVBvc2l0aW9uIEEgcG9zaXRpb24gc3BlY2lmaWVkIHRvIGJlIHRoZSBzdGFydGluZyBwb2ludCBvZiBzd2VlcGluZ1xuICAgICAqIEBwYXJhbSBoYWxmU2l6ZSBUaGUgaGFsZlNpemUgb2YgdGhlIHN3ZWVwaW5nIHJlY3QgXG4gICAgICovXG4gICAgc3dlZXAodmVsb2NpdHk6IFZlYzIsIGZyb21Qb3NpdGlvbj86IFZlYzIsIGhhbGZTaXplPzogVmVjMik6IHZvaWQge1xuICAgICAgICBpZighZnJvbVBvc2l0aW9uKXtcbiAgICAgICAgICAgIGZyb21Qb3NpdGlvbiA9IHRoaXMuY2VudGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWhhbGZTaXplKXtcbiAgICAgICAgICAgIGhhbGZTaXplID0gdGhpcy5oYWxmU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjZW50ZXJYID0gZnJvbVBvc2l0aW9uLnggKyB2ZWxvY2l0eS54LzI7XG4gICAgICAgIGxldCBjZW50ZXJZID0gZnJvbVBvc2l0aW9uLnkgKyB2ZWxvY2l0eS55LzI7XG5cbiAgICAgICAgbGV0IG1pblggPSBNYXRoLm1pbihmcm9tUG9zaXRpb24ueCAtIGhhbGZTaXplLngsIGZyb21Qb3NpdGlvbi54ICsgdmVsb2NpdHkueCAtIGhhbGZTaXplLngpO1xuICAgICAgICBsZXQgbWluWSA9IE1hdGgubWluKGZyb21Qb3NpdGlvbi55IC0gaGFsZlNpemUueSwgZnJvbVBvc2l0aW9uLnkgKyB2ZWxvY2l0eS55IC0gaGFsZlNpemUueSk7XG5cbiAgICAgICAgdGhpcy5jZW50ZXIuc2V0KGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICB0aGlzLmhhbGZTaXplLnNldChjZW50ZXJYIC0gbWluWCwgY2VudGVyWSAtIG1pblkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBjbG9uZSgpOiBBQUJCIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBQUJCKHRoaXMuY2VudGVyLmNsb25lKCksIHRoaXMuaGFsZlNpemUuY2xvbmUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBBQUJCIHRvIGEgc3RyaW5nIGZvcm1hdFxuICAgICAqIEByZXR1cm5zIChjZW50ZXI6ICh4LCB5KSwgaGFsZlNpemU6ICh4LCB5KSlcbiAgICAgKi9cbiAgICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gXCIoY2VudGVyOiBcIiArIHRoaXMuY2VudGVyLnRvU3RyaW5nKCkgKyBcIiwgaGFsZi1zaXplOiBcIiArIHRoaXMuaGFsZlNpemUudG9TdHJpbmcoKSArIFwiKVwiXG4gICAgfVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi9BQUJCXCI7XG5pbXBvcnQgU2hhcGUgZnJvbSBcIi4vU2hhcGVcIjtcblxuLyoqXG4gKiBBIENpcmNsZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaXJjbGUgZXh0ZW5kcyBTaGFwZSB7XG5cdHByaXZhdGUgX2NlbnRlcjogVmVjMjtcblx0cmFkaXVzOiBudW1iZXI7XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBDaXJjbGVcblx0ICogQHBhcmFtIGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcblx0ICogQHBhcmFtIHJhZGl1cyBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcblx0ICovXG5cdGNvbnN0cnVjdG9yKGNlbnRlcjogVmVjMiwgcmFkaXVzOiBudW1iZXIpIHtcblx0XHRzdXBlcigpO1xuICAgICAgICB0aGlzLl9jZW50ZXIgPSBjZW50ZXIgPyBjZW50ZXIgOiBuZXcgVmVjMigwLCAwKTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXMgPyByYWRpdXMgOiAwO1xuXHR9XG5cblx0Z2V0IGNlbnRlcigpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5fY2VudGVyO1xuXHR9XG5cblx0c2V0IGNlbnRlcihjZW50ZXI6IFZlYzIpIHtcblx0XHR0aGlzLl9jZW50ZXIgPSBjZW50ZXI7XG5cdH1cblxuXHRnZXQgaGFsZlNpemUoKTogVmVjMiB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cyk7XG5cdH1cblxuXHRnZXQgcigpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLnJhZGl1cztcblx0fVxuXG5cdHNldCByKHJhZGl1czogbnVtYmVyKSB7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0LyoqXG4gICAgICogQSBzaW1wbGUgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyBhIHBvaW50XG4gICAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQocG9pbnQ6IFZlYzIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VudGVyLmRpc3RhbmNlU3FUbyhwb2ludCkgPD0gdGhpcy5yYWRpdXMqdGhpcy5yYWRpdXM7XG4gICAgfVxuXG5cdC8vIEBvdmVycmlkZVxuXHRnZXRCb3VuZGluZ1JlY3QoKTogQUFCQiB7XG5cdFx0cmV0dXJuIG5ldyBBQUJCKHRoaXMuX2NlbnRlci5jbG9uZSgpLCBuZXcgVmVjMih0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMpKTtcblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRnZXRCb3VuZGluZ0NpcmNsZSgpOiBDaXJjbGUge1xuXHRcdHJldHVybiB0aGlzLmNsb25lKCk7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0b3ZlcmxhcHMob3RoZXI6IFNoYXBlKTogYm9vbGVhbiB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0Y2xvbmUoKTogQ2lyY2xlIHtcblx0XHRyZXR1cm4gbmV3IENpcmNsZSh0aGlzLl9jZW50ZXIuY2xvbmUoKSwgdGhpcy5yYWRpdXMpO1xuXHR9XG5cblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gXCIoY2VudGVyOiBcIiArIHRoaXMuY2VudGVyLnRvU3RyaW5nKCkgKyBcIiwgcmFkaXVzOiBcIiArIHRoaXMucmFkaXVzICsgXCIpXCI7XG5cdH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4vQUFCQlwiO1xuaW1wb3J0IENpcmNsZSBmcm9tIFwiLi9DaXJjbGVcIjtcblxuLyoqXG4gKiBBbiBhYnN0cmFjdCBTaGFwZSBjbGFzcyB0aGF0IGFjdHMgYXMgYW4gaW50ZXJmYWNlIGZvciBiZXR0ZXIgaW50ZXJhY3Rpb25zIHdpdGggc3ViY2xhc3Nlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU2hhcGUge1xuICAgIGFic3RyYWN0IGdldCBjZW50ZXIoKTogVmVjMjtcblxuICAgIGFic3RyYWN0IHNldCBjZW50ZXIoY2VudGVyOiBWZWMyKTtcblxuICAgIGFic3RyYWN0IGdldCBoYWxmU2l6ZSgpOiBWZWMyO1xuXG4gICAgZ2V0IHgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VudGVyLng7XG4gICAgfVxuXG4gICAgZ2V0IHkoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VudGVyLnk7XG4gICAgfVxuXG4gICAgZ2V0IGh3KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbGZTaXplLng7XG4gICAgfVxuXG4gICAgZ2V0IGhoKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbGZTaXplLnk7XG4gICAgfVxuXG4gICAgZ2V0IHRvcCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy55IC0gdGhpcy5oaDtcbiAgICB9XG5cbiAgICBnZXQgYm90dG9tKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhoO1xuICAgIH1cblxuICAgIGdldCBsZWZ0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnggLSB0aGlzLmh3O1xuICAgIH1cblxuICAgIGdldCByaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy5odztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgYm91bmRpbmcgcmVjdGFuZ2xlIGZvciB0aGlzIHNoYXBlLiBXYXJuaW5nIC0gbWF5IGJlIHRoZSBzYW1lIGFzIHRoaXMgU2hhcGUuXG4gICAgICogRm9yIGluc3RhbmNlLCB0aGUgYm91bmRpbmcgY2lyY2xlIG9mIGFuIEFBQkIgaXMgaXRzZWxmLiBVc2UgY2xvbmUoKSBpZiB5b3UgbmVlZCBhIG5ldyBzaGFwZS5cbiAgICAgKiBAcmV0dXJucyBBbiBBQUJCIHRoYXQgYm91bmRzIHRoaXMgc2hhcGVcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXRCb3VuZGluZ1JlY3QoKTogQUFCQjtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBib3VuZGluZyBjaXJjbGUgZm9yIHRoaXMgc2hhcGUuIFdhcm5pbmcgLSBtYXkgYmUgdGhlIHNhbWUgYXMgdGhpcyBTaGFwZS5cbiAgICAgKiBGb3IgaW5zdGFuY2UsIHRoZSBib3VuZGluZyBjaXJjbGUgb2YgYSBDaXJjbGUgaXMgaXRzZWxmLiBVc2UgY2xvbmUoKSBpZiB5b3UgbmVlZCBhIG5ldyBzaGFwZS5cbiAgICAgKiBAcmV0dXJucyBBIENpcmNsZSB0aGF0IGJvdW5kcyB0aGlzIHNoYXBlXG4gICAgICovXG4gICAgYWJzdHJhY3QgZ2V0Qm91bmRpbmdDaXJjbGUoKTogQ2lyY2xlO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBTaGFwZVxuICAgICAqIEByZXR1cm5zIEEgbmV3IGNvcHkgb2YgdGhpcyBzaGFwZVxuICAgICAqL1xuICAgIGFic3RyYWN0IGNsb25lKCk6IFNoYXBlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgc2hhcGUgb3ZlcmxhcHMgYW5vdGhlclxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgc2hhcGUgdG8gY2hlY2sgYWdhaW5zdFxuICAgICAqIEByZXR1cm5zIGEgYm9vbGVhbiB0aGF0IHJlcHJlc2VudHMgd2hldGhlciB0aGlzIFNoYXBlIG92ZXJsYXBzIHRoZSBvdGhlciBvbmVcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBvdmVybGFwcyhvdGhlcjogU2hhcGUpOiBib29sZWFuO1xuXG4gICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIFNoYXBlIGNvbnRhaW5zIGEgcG9pbnRcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgU2hhcGUgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxuICAgICAqL1xuICAgIGFic3RyYWN0IGNvbnRhaW5zUG9pbnQocG9pbnQ6IFZlYzIpOiBib29sZWFuO1xuXG4gICAgc3RhdGljIGdldFRpbWVPZkNvbGxpc2lvbihBOiBTaGFwZSwgdmVsQTogVmVjMiwgQjogU2hhcGUsIHZlbEI6IFZlYzIpOiBbVmVjMiwgVmVjMiwgYm9vbGVhbiwgYm9vbGVhbl0ge1xuXHRcdGlmKEEgaW5zdGFuY2VvZiBBQUJCICYmIEIgaW5zdGFuY2VvZiBBQUJCKXtcblx0XHRcdHJldHVybiBTaGFwZS5nZXRUaW1lT2ZDb2xsaXNpb25fQUFCQl9BQUJCKEEsIHZlbEEsIEIsIHZlbEIpO1xuXHRcdH1cbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0VGltZU9mQ29sbGlzaW9uX0FBQkJfQUFCQihBOiBBQUJCLCB2ZWxBOiBWZWMyLCBCOiBTaGFwZSwgdmVsQjogVmVjMik6IFtWZWMyLCBWZWMyLCBib29sZWFuLCBib29sZWFuXSB7XG4gICAgICAgIGxldCBwb3NTbWFsbGVyID0gQS5jZW50ZXI7XG4gICAgICAgIGxldCBwb3NMYXJnZXIgPSBCLmNlbnRlcjtcbiAgICAgICAgXG4gICAgICAgIGxldCBzaXplU21hbGxlciA9IEEuaGFsZlNpemU7XG4gICAgICAgIGxldCBzaXplTGFyZ2VyID0gQi5oYWxmU2l6ZTtcbiAgICBcbiAgICAgICAgbGV0IGZpcnN0Q29udGFjdCA9IG5ldyBWZWMyKDAsIDApO1xuICAgICAgICBsZXQgbGFzdENvbnRhY3QgPSBuZXcgVmVjMigwLCAwKTtcbiAgICBcbiAgICAgICAgbGV0IGNvbGxpZGluZ1ggPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvbGxpZGluZ1kgPSBmYWxzZTtcbiAgICBcbiAgICAgICAgLy8gU29ydCBieSBwb3NpdGlvblxuICAgICAgICBpZihwb3NMYXJnZXIueCA8IHBvc1NtYWxsZXIueCl7XG4gICAgICAgICAgICAvLyBTd2FwLCBiZWNhdXNlIHNtYWxsZXIgaXMgZnVydGhlciByaWdodCB0aGFuIGxhcmdlclxuICAgICAgICAgICAgbGV0IHRlbXA6IFZlYzI7XG4gICAgICAgICAgICB0ZW1wID0gc2l6ZVNtYWxsZXI7XG4gICAgICAgICAgICBzaXplU21hbGxlciA9IHNpemVMYXJnZXI7XG4gICAgICAgICAgICBzaXplTGFyZ2VyID0gdGVtcDtcbiAgICBcbiAgICAgICAgICAgIHRlbXAgPSBwb3NTbWFsbGVyO1xuICAgICAgICAgICAgcG9zU21hbGxlciA9IHBvc0xhcmdlcjtcbiAgICAgICAgICAgIHBvc0xhcmdlciA9IHRlbXA7XG4gICAgXG4gICAgICAgICAgICB0ZW1wID0gdmVsQTtcbiAgICAgICAgICAgIHZlbEEgPSB2ZWxCO1xuICAgICAgICAgICAgdmVsQiA9IHRlbXA7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gQSBpcyBsZWZ0LCBCIGlzIHJpZ2h0XG4gICAgICAgIGZpcnN0Q29udGFjdC54ID0gSW5maW5pdHk7XG4gICAgICAgIGxhc3RDb250YWN0LnggPSBJbmZpbml0eTtcbiAgICBcbiAgICAgICAgaWYgKHBvc0xhcmdlci54IC0gc2l6ZUxhcmdlci54ID49IHBvc1NtYWxsZXIueCArIHNpemVTbWFsbGVyLngpe1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlbid0IGN1cnJlbnRseSBjb2xsaWRpbmdcbiAgICAgICAgICAgIGxldCByZWxWZWwgPSB2ZWxBLnggLSB2ZWxCLng7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHJlbFZlbCA+IDApe1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXkgYXJlIG1vdmluZyB0b3dhcmRzIGVhY2ggb3RoZXJcbiAgICAgICAgICAgICAgICBmaXJzdENvbnRhY3QueCA9ICgocG9zTGFyZ2VyLnggLSBzaXplTGFyZ2VyLngpIC0gKHBvc1NtYWxsZXIueCArIHNpemVTbWFsbGVyLngpKS8ocmVsVmVsKTtcbiAgICAgICAgICAgICAgICBsYXN0Q29udGFjdC54ID0gKChwb3NMYXJnZXIueCArIHNpemVMYXJnZXIueCkgLSAocG9zU21hbGxlci54IC0gc2l6ZVNtYWxsZXIueCkpLyhyZWxWZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sbGlkaW5nWCA9IHRydWU7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYocG9zTGFyZ2VyLnkgPCBwb3NTbWFsbGVyLnkpe1xuICAgICAgICAgICAgLy8gU3dhcCwgYmVjYXVzZSBzbWFsbGVyIGlzIGZ1cnRoZXIgdXAgdGhhbiBsYXJnZXJcbiAgICAgICAgICAgIGxldCB0ZW1wOiBWZWMyO1xuICAgICAgICAgICAgdGVtcCA9IHNpemVTbWFsbGVyO1xuICAgICAgICAgICAgc2l6ZVNtYWxsZXIgPSBzaXplTGFyZ2VyO1xuICAgICAgICAgICAgc2l6ZUxhcmdlciA9IHRlbXA7XG4gICAgXG4gICAgICAgICAgICB0ZW1wID0gcG9zU21hbGxlcjtcbiAgICAgICAgICAgIHBvc1NtYWxsZXIgPSBwb3NMYXJnZXI7XG4gICAgICAgICAgICBwb3NMYXJnZXIgPSB0ZW1wO1xuICAgIFxuICAgICAgICAgICAgdGVtcCA9IHZlbEE7XG4gICAgICAgICAgICB2ZWxBID0gdmVsQjtcbiAgICAgICAgICAgIHZlbEIgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIEEgaXMgdG9wLCBCIGlzIGJvdHRvbVxuICAgICAgICBmaXJzdENvbnRhY3QueSA9IEluZmluaXR5O1xuICAgICAgICBsYXN0Q29udGFjdC55ID0gSW5maW5pdHk7XG4gICAgXG4gICAgICAgIGlmIChwb3NMYXJnZXIueSAtIHNpemVMYXJnZXIueSA+PSBwb3NTbWFsbGVyLnkgKyBzaXplU21hbGxlci55KXtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZW4ndCBjdXJyZW50bHkgY29sbGlkaW5nXG4gICAgICAgICAgICBsZXQgcmVsVmVsID0gdmVsQS55IC0gdmVsQi55O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihyZWxWZWwgPiAwKXtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGV5IGFyZSBtb3ZpbmcgdG93YXJkcyBlYWNoIG90aGVyXG4gICAgICAgICAgICAgICAgZmlyc3RDb250YWN0LnkgPSAoKHBvc0xhcmdlci55IC0gc2l6ZUxhcmdlci55KSAtIChwb3NTbWFsbGVyLnkgKyBzaXplU21hbGxlci55KSkvKHJlbFZlbCk7XG4gICAgICAgICAgICAgICAgbGFzdENvbnRhY3QueSA9ICgocG9zTGFyZ2VyLnkgKyBzaXplTGFyZ2VyLnkpIC0gKHBvc1NtYWxsZXIueSAtIHNpemVTbWFsbGVyLnkpKS8ocmVsVmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbGxpZGluZ1kgPSB0cnVlO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiBbZmlyc3RDb250YWN0LCBsYXN0Q29udGFjdCwgY29sbGlkaW5nWCwgY29sbGlkaW5nWV07XG4gICAgfVxufSIsImltcG9ydCBDb2xsZWN0aW9uIGZyb20gXCIuL0NvbGxlY3Rpb25cIjtcblxuLyoqXG4gKiBBIExJRk8gc3RhY2sgd2l0aCBpdGVtcyBvZiB0eXBlIFRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhY2s8VD4gaW1wbGVtZW50cyBDb2xsZWN0aW9uIHtcbiAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBTdGFjayAqL1xuICAgIHByaXZhdGUgTUFYX0VMRU1FTlRTOiBudW1iZXI7XG4gICAgXG4gICAgLyoqIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3RhY2sgKi9cbiAgICBwcml2YXRlIHN0YWNrOiBBcnJheTxUPjtcbiAgICBcbiAgICAvKiogVGhlIGhlYWQgb2YgdGhlIHN0YWNrICovXG5cdHByaXZhdGUgaGVhZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBzdGFja1xuICAgICAqIEBwYXJhbSBtYXhFbGVtZW50cyBUaGUgbWF4aW11bSBzaXplIG9mIHRoZSBzdGFja1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1heEVsZW1lbnRzOiBudW1iZXIgPSAxMDApe1xuICAgICAgICB0aGlzLk1BWF9FTEVNRU5UUyA9IG1heEVsZW1lbnRzO1xuICAgICAgICB0aGlzLnN0YWNrID0gbmV3IEFycmF5PFQ+KHRoaXMuTUFYX0VMRU1FTlRTKTtcbiAgICAgICAgdGhpcy5oZWFkID0gLTE7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gaXRlbSB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAqIEBwYXJhbSBpdGVtIFRoZSBuZXcgaXRlbSB0byBhZGQgdG8gdGhlIHN0YWNrXG4gICAgICovXG4gICAgcHVzaChpdGVtOiBUKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMuaGVhZCArIDEgPT09IHRoaXMuTUFYX0VMRU1FTlRTKXtcbiAgICAgICAgICAgIHRocm93IFwiU3RhY2sgZnVsbCAtIGNhbm5vdCBhZGQgZWxlbWVudFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZCArPSAxO1xuICAgICAgICB0aGlzLnN0YWNrW3RoaXMuaGVhZF0gPSBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgKi9cbiAgICBwb3AoKTogVCB7XG4gICAgICAgIGlmKHRoaXMuaGVhZCA9PT0gLTEpe1xuICAgICAgICAgICAgdGhyb3cgXCJTdGFjayBlbXB0eSAtIGNhbm5vdCByZW1vdmUgZWxlbWVudFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZCAtPSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLmhlYWQgKyAxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IGN1cnJlbnRseSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAqIEByZXR1cm5zIFRoZSBpdGVtIGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICovXG4gICAgcGVlaygpOiBUIHtcbiAgICAgICAgaWYodGhpcy5oZWFkID09PSAtMSl7XG4gICAgICAgICAgICB0aHJvdyBcIlN0YWNrIGVtcHR5IC0gY2Fubm90IGdldCBlbGVtZW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5oZWFkXTtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoaXMgc3RhY2sgaXMgZW1wdHlcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gdGhhdCByZXByZXNlbnRzIHdoZXRoZXIgb3Igbm90IHRoZSBzdGFjayBpcyBlbXB0eVxuICAgICovXG4gICAgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZCA9PT0gLTE7XG4gICAgfVxuXG4gICAgLy8gQGltcGxlbWVudGVkXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IGRlbGV0ZSB0aGlzLnN0YWNrW2luZGV4XSk7XG4gICAgICAgIHRoaXMuaGVhZCA9IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBpdGVtcyBjdXJyZW50bHkgaW4gdGhlIHN0YWNrXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgc3RhY2tcbiAgICAgKi9cbiAgICBzaXplKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWQgKyAxO1xuICAgIH1cblxuICAgIC8vIEBpbXBsZW1lbnRlZFxuICAgIGZvckVhY2goZnVuYzogKGl0ZW06IFQsIGluZGV4PzogbnVtYmVyKSA9PiB2b2lkKTogdm9pZHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZShpIDw9IHRoaXMuaGVhZCl7XG4gICAgICAgICAgICBmdW5jKHRoaXMuc3RhY2tbaV0sIGkpO1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBzdGFjayBpbnRvIGEgc3RyaW5nIGZvcm1hdFxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIHN0YWNrXG4gICAgICovXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHJldHZhbCA9IFwiXCI7XG5cbiAgICAgICAgdGhpcy5mb3JFYWNoKCAoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBpdGVtLnRvU3RyaW5nKClcbiAgICAgICAgICAgIGlmKGluZGV4ICE9PSAwKXtcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCIgLT4gXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHZhbCA9IHN0ciArIHJldHZhbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFwiVG9wIC0+IFwiICsgcmV0dmFsO1xuICAgIH1cbn0iLCJpbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xuaW1wb3J0IHsgVGlsZWRUaWxlc2V0RGF0YSB9IGZyb20gXCIuL1RpbGVkRGF0YVwiO1xuXG4vKipcbiAqIFRoZSBkYXRhIHJlcHJlc2VudGF0aW9uIG9mIGEgVGlsZXNldCBmb3IgdGhlIGdhbWUgZW5naW5lLiBUaGlzIHJlcHJlc2VudHMgb25lIGltYWdlLFxuICogd2l0aCBhIHN0YXJ0SW5kZXggaWYgcmVxdWlyZWQgKGFzIGl0IGlzIHdpdGggVGlsZWQgdXNpbmcgdHdvIGltYWdlcyBpbiBvbmUgdGlsc2V0KS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZXNldCB7XG4gICAgLyoqIFRoZSBrZXkgb2YgdGhlIGltYWdlIHVzZWQgYnkgdGhpcyB0aWxlc2V0ICovXG4gICAgcHJvdGVjdGVkIGltYWdlS2V5OiBzdHJpbmc7XG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSB0aWxlc2V0IGltYWdlICovXG4gICAgcHJvdGVjdGVkIGltYWdlU2l6ZTogVmVjMjtcbiAgICAvKiogVGhlIGluZGV4IG9mIDB0aCBpbWFnZSBvZiB0aGlzIHRpbGVzZXQgKi9cbiAgICBwcm90ZWN0ZWQgc3RhcnRJbmRleDogbnVtYmVyO1xuICAgIC8qKiBUaGUgaW5kZXggb2YgdGhlIGxhc3QgaW1hZ2Ugb2YgdGhpcyB0aWxzZXQgKi9cbiAgICBwcm90ZWN0ZWQgZW5kSW5kZXg6IG51bWJlcjtcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIHRpbGVzIGluIHRoaXMgdGlsZXNldCAqL1xuICAgIHByb3RlY3RlZCB0aWxlU2l6ZTogVmVjMjtcbiAgICAvKiogVGhlIG51bWJlciBvZiByb3dzIGluIHRoaXMgdGlsZXNldCAqL1xuICAgIHByb3RlY3RlZCBudW1Sb3dzOiBudW1iZXI7XG4gICAgLyoqIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGlzIHRpbGVzZXQgKi9cbiAgICBwcm90ZWN0ZWQgbnVtQ29sczogbnVtYmVyO1xuXG4gICAgLy8gVE9ETzogQ2hhbmdlIHRoaXMgdG8gYmUgbW9yZSBnZW5lcmFsIGFuZCB3b3JrIHdpdGggb3RoZXIgdGlsZXNldCBmb3JtYXRzXG4gICAgY29uc3RydWN0b3IodGlsZXNldERhdGE6IFRpbGVkVGlsZXNldERhdGEpe1xuICAgICAgICAvLyBEZWZlciBoYW5kbGluZyBvZiB0aGUgZGF0YSB0byBhIGhlbHBlciBjbGFzc1xuICAgICAgICB0aGlzLmluaXRGcm9tVGlsZWREYXRhKHRpbGVzZXREYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSB0aWxlc2V0IGZyb20gdGhlIGRhdGEgZnJvbSBhIFRpbGVkIGpzb24gZmlsZVxuICAgICAqIEBwYXJhbSB0aWxlZERhdGEgVGhlIHBhcnNlZCBvYmplY3QgZnJvbSBhIFRpbGVkIGpzb24gZmlsZVxuICAgICAqL1xuICAgIGluaXRGcm9tVGlsZWREYXRhKHRpbGVkRGF0YTogVGlsZWRUaWxlc2V0RGF0YSk6IHZvaWQge1xuICAgICAgICB0aGlzLm51bVJvd3MgPSB0aWxlZERhdGEudGlsZWNvdW50L3RpbGVkRGF0YS5jb2x1bW5zO1xuICAgICAgICB0aGlzLm51bUNvbHMgPSB0aWxlZERhdGEuY29sdW1ucztcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gdGlsZWREYXRhLmZpcnN0Z2lkO1xuICAgICAgICB0aGlzLmVuZEluZGV4ID0gdGhpcy5zdGFydEluZGV4ICsgdGlsZWREYXRhLnRpbGVjb3VudCAtIDE7XG4gICAgICAgIHRoaXMudGlsZVNpemUgPSBuZXcgVmVjMih0aWxlZERhdGEudGlsZXdpZHRoLCB0aWxlZERhdGEudGlsZXdpZHRoKTtcbiAgICAgICAgdGhpcy5pbWFnZUtleSA9IHRpbGVkRGF0YS5pbWFnZTtcbiAgICAgICAgdGhpcy5pbWFnZVNpemUgPSBuZXcgVmVjMih0aWxlZERhdGEuaW1hZ2V3aWR0aCwgdGlsZWREYXRhLmltYWdlaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogR2V0cyB0aGUgaW1hZ2Uga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRpbGVtYXBcbiAgICAgKiBAcmV0dXJucyBUaGUgaW1hZ2Uga2V5IG9mIHRoaXMgdGlsZW1hcFxuICAgICAqL1xuICAgIGdldEltYWdlS2V5KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlS2V5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBWZWMyIGNvbnRhaW5pbmcgdGhlIGxlZnQgYW5kIHRvcCBvZmZzZXQgZnJvbSB0aGUgaW1hZ2Ugb3JpZ2luIGZvciB0aGlzIHRpbGUuXG4gICAgICogQHBhcmFtIHRpbGVJbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgZnJvbSBzdGFydEluZGV4IHRvIGVuZEluZGV4IG9mIHRoaXMgdGlsZXNldFxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSBvZmZzZXQgZm9yIHRoZSBzcGVjaWZpZWQgdGlsZS5cbiAgICAgKi9cbiAgICBnZXRJbWFnZU9mZnNldEZvclRpbGUodGlsZUluZGV4OiBudW1iZXIpOiBWZWMyIHtcbiAgICAgICAgLy8gR2V0IHRoZSB0cnVlIGluZGV4XG4gICAgICAgIGxldCBpbmRleCA9IHRpbGVJbmRleCAtIHRoaXMuc3RhcnRJbmRleDtcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLm51bUNvbHMpO1xuICAgICAgICBsZXQgY29sID0gaW5kZXggJSB0aGlzLm51bUNvbHM7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMudGlsZVNpemUueDtcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMudGlsZVNpemUueTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIHRvIHN0YXJ0IGEgY3JvcCBpbiB0aGUgdGlsZXNldCBpbWFnZVxuICAgICAgICBsZXQgbGVmdCA9IGNvbCAqIHdpZHRoO1xuICAgICAgICBsZXQgdG9wID0gcm93ICogaGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiBuZXcgVmVjMihsZWZ0LCB0b3ApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YXJ0IGluZGV4XG4gICAgICogQHJldHVybnMgVGhlIHN0YXJ0IGluZGV4XG4gICAgICovXG4gICAgZ2V0U3RhcnRJbmRleCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydEluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRpbGUgc2V0XG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIHRpbGUgc2l6ZVxuICAgICAqL1xuICAgIGdldFRpbGVTaXplKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGlsZXNldFxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2Ygcm93c1xuICAgICAqL1xuICAgIGdldE51bVJvd3MoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtUm93cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgdGlsc2V0XG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjb2x1bW5zXG4gICAgICovXG4gICAgZ2V0TnVtQ29scygpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1Db2xzO1xuICAgIH1cblxuICAgIGdldFRpbGVDb3VudCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRJbmRleCAtIHRoaXMuc3RhcnRJbmRleCArIDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgdGlsc2V0IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgdGlsZSBpbmRleC4gVGhpcyBpcyB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHRpbGVJbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgdGlsc2V0IHVzZXMgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqL1xuICAgIGhhc1RpbGUodGlsZUluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRpbGVJbmRleCA+PSB0aGlzLnN0YXJ0SW5kZXggJiYgdGlsZUluZGV4IDw9IHRoaXMuZW5kSW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgc2luZ3VsYXIgdGlsZSB3aXRoIGluZGV4IHRpbGVJbmRleCBmcm9tIHRoZSB0aWxlc2V0IGxvY2F0ZWQgYXQgcG9zaXRpb24gZGF0YUluZGV4XG4gICAgICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gdGlsZUluZGV4IFRoZSB2YWx1ZSBvZiB0aGUgdGlsZSB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0gZGF0YUluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZSBpbiB0aGUgZGF0YSBhcnJheVxuICAgICAqIEBwYXJhbSB3b3JsZFNpemUgVGhlIHNpemUgb2YgdGhlIHdvcmxkXG4gICAgICogQHBhcmFtIG9yaWdpbiBUaGUgdmlld3BvcnQgb3JpZ2luIGluIHRoZSBjdXJyZW50IGxheWVyXG4gICAgICogQHBhcmFtIHNjYWxlIFRoZSBzY2FsZSBvZiB0aGUgdGlsZW1hcFxuICAgICAqL1xuICAgIHJlbmRlclRpbGUoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHRpbGVJbmRleDogbnVtYmVyLCBkYXRhSW5kZXg6IG51bWJlciwgbWF4Q29sczogbnVtYmVyLCBvcmlnaW46IFZlYzIsIHNjYWxlOiBWZWMyLCB6b29tOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGltYWdlID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0SW1hZ2UodGhpcy5pbWFnZUtleSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSB0cnVlIGluZGV4XG4gICAgICAgIGxldCBpbmRleCA9IHRpbGVJbmRleCAtIHRoaXMuc3RhcnRJbmRleDtcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLm51bUNvbHMpO1xuICAgICAgICBsZXQgY29sID0gaW5kZXggJSB0aGlzLm51bUNvbHM7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMudGlsZVNpemUueDtcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMudGlsZVNpemUueTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIHRvIHN0YXJ0IGEgY3JvcCBpbiB0aGUgdGlsZXNldCBpbWFnZVxuICAgICAgICBsZXQgbGVmdCA9IGNvbCAqIHdpZHRoO1xuICAgICAgICBsZXQgdG9wID0gcm93ICogaGVpZ2h0O1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gaW4gdGhlIHdvcmxkIHRvIHJlbmRlciB0aGUgdGlsZVxuICAgICAgICBsZXQgeCA9IE1hdGguZmxvb3IoKGRhdGFJbmRleCAlIG1heENvbHMpICogd2lkdGggKiBzY2FsZS54KTtcbiAgICAgICAgbGV0IHkgPSBNYXRoLmZsb29yKE1hdGguZmxvb3IoZGF0YUluZGV4IC8gbWF4Q29scykgKiBoZWlnaHQgKiBzY2FsZS55KTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0LCBNYXRoLmZsb29yKCh4IC0gb3JpZ2luLngpKnpvb20pLCBNYXRoLmZsb29yKCh5IC0gb3JpZ2luLnkpKnpvb20pLCBNYXRoLmNlaWwod2lkdGggKiBzY2FsZS54ICogem9vbSksIE1hdGguY2VpbChoZWlnaHQgKiBzY2FsZS55ICogem9vbSkpO1xuICAgIH1cbn0iLCJpbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi9VdGlscy9NYXRoVXRpbHNcIjtcblxuLyoqXG4gKiBBIHR3by1kaW1lbnNpb25hbCB2ZWN0b3IgKHgsIHkpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlYzIge1xuXG5cdC8vIFN0b3JlIHggYW5kIHkgaW4gYW4gYXJyYXlcblx0LyoqIFRoZSBhcnJheSB0aGF0IHN0b3JlcyB0aGUgYWN0dWFsIHZlY3RvciB2YWx1ZXMgeCBhbmQgeSAqL1xuXHRwcml2YXRlIHZlYzogRmxvYXQzMkFycmF5O1xuXG5cdC8qKlx0XG5cdCAqIFdoZW4gdGhpcyB2ZWN0b3IgY2hhbmdlcyBpdHMgdmFsdWUsIGRvIHNvbWV0aGluZ1xuXHQgKi9cblx0cHJpdmF0ZSBvbkNoYW5nZTogRnVuY3Rpb24gPSAoKSA9PiB7fTtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBWZWMyXG5cdCAqIEBwYXJhbSB4IFRoZSB4IHZhbHVlIG9mIHRoZSB2ZWN0b3Jcblx0ICogQHBhcmFtIHkgVGhlIHkgdmFsdWUgb2YgdGhlIHZlY3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3IoeDogbnVtYmVyID0gMCwgeTogbnVtYmVyID0gMCkge1xuXHRcdHRoaXMudmVjID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcblx0XHR0aGlzLnZlY1swXSA9IHg7XG5cdFx0dGhpcy52ZWNbMV0gPSB5O1xuXHR9XG5cblx0Ly8gRXhwb3NlIHggYW5kIHkgd2l0aCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG5cdGdldCB4KCkge1xuXHRcdHJldHVybiB0aGlzLnZlY1swXTtcblx0fVxuXG5cdHNldCB4KHg6IG51bWJlcikge1xuXHRcdHRoaXMudmVjWzBdID0geDtcblxuXHRcdGlmKHRoaXMub25DaGFuZ2Upe1xuXHRcdFx0dGhpcy5vbkNoYW5nZSgpO1xuXHRcdH1cblx0fVxuXG5cdGdldCB5KCkge1xuXHRcdHJldHVybiB0aGlzLnZlY1sxXTtcblx0fVxuXG5cdHNldCB5KHk6IG51bWJlcikge1xuXHRcdHRoaXMudmVjWzFdID0geTtcblxuXHRcdGlmKHRoaXMub25DaGFuZ2Upe1xuXHRcdFx0dGhpcy5vbkNoYW5nZSgpO1xuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBnZXQgWkVSTygpIHtcblx0XHRyZXR1cm4gbmV3IFZlYzIoMCwgMCk7XG5cdH1cblxuXHRzdGF0aWMgcmVhZG9ubHkgWkVST19TVEFUSUMgPSBuZXcgVmVjMigwLCAwKTtcblxuXHRzdGF0aWMgZ2V0IElORigpIHtcblx0XHRyZXR1cm4gbmV3IFZlYzIoSW5maW5pdHksIEluZmluaXR5KTtcblx0fVxuXG5cdHN0YXRpYyBnZXQgVVAoKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKDAsIC0xKTtcblx0fVxuXG5cdHN0YXRpYyBnZXQgRE9XTigpIHtcblx0XHRyZXR1cm4gbmV3IFZlYzIoMCwgMSk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0IExFRlQoKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKC0xLCAwKTtcblx0fVxuXG5cdHN0YXRpYyBnZXQgUklHSFQoKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKDEsIDApO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBzcXVhcmVkIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yLiBUaGlzIHRlbmRzIHRvIGJlIGZhc3Rlciwgc28gdXNlIGl0IGluIHNpdHVhdGlvbnMgd2hlcmUgdGFraW5nIHRoZVxuXHQgKiBzcXVhcmUgcm9vdCBkb2Vzbid0IG1hdHRlciwgbGlrZSBmb3IgY29tcGFyaW5nIGRpc3RhbmNlcy5cblx0ICogQHJldHVybnMgVGhlIHNxdWFyZWQgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3Jcblx0ICovXG5cdG1hZ1NxKCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMueCp0aGlzLnggKyB0aGlzLnkqdGhpcy55O1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3Rvci5cblx0ICogQHJldHVybnMgVGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yLlxuXHQgKi9cblx0bWFnKCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLm1hZ1NxKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpdmRlcyB4IGFuZCB5IGJ5IHRoZSBtYWduaXR1ZGUgdG8gb2J0YWluIHRoZSB1bml0IHZlY3RvciBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoaXMgdmVjdG9yLlxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhcyBhIHVuaXQgdmVjdG9yLlxuXHQgKi9cblx0bm9ybWFsaXplKCk6IFZlYzIge1xuXHRcdGlmKHRoaXMueCA9PT0gMCAmJiB0aGlzLnkgPT09IDApIHJldHVybiB0aGlzO1xuXHRcdGxldCBtYWcgPSB0aGlzLm1hZygpO1xuXHRcdHRoaXMueCAvPSBtYWc7XG5cdFx0dGhpcy55IC89IG1hZztcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBXb3JrcyBsaWtlIG5vcm1hbGl6ZSgpLCBidXQgcmV0dXJucyBhIG5ldyBWZWMyXG5cdCAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciB0aGF0IGlzIHRoZSB1bml0IHZlY3RvciBmb3IgdGhpcyBvbmVcblx0ICovXG5cdG5vcm1hbGl6ZWQoKTogVmVjMiB7XG5cdFx0aWYodGhpcy5pc1plcm8oKSl7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0XG5cdFx0bGV0IG1hZyA9IHRoaXMubWFnKCk7XG5cdFx0cmV0dXJuIG5ldyBWZWMyKHRoaXMueC9tYWcsIHRoaXMueS9tYWcpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHggYW5kIHkgZWxlbWVudHMgb2YgdGhpcyB2ZWN0b3IgdG8gemVyby5cblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IsIHdpdGggeCBhbmQgeSBzZXQgdG8gemVyby5cblx0ICovXG5cdHplcm8oKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0KDAsIDApO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZlY3RvcidzIHggYW5kIHkgYmFzZWQgb24gdGhlIGFuZ2xlIHByb3ZpZGVkLiBHb2VzIGNvdW50ZXIgY2xvY2t3aXNlLlxuXHQgKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIGluIHJhZGlhbnNcblx0ICogQHBhcmFtIHJhZGl1cyBUaGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IgYXQgdGhlIHNwZWNpZmllZCBhbmdsZVxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3Rvci5cblx0ICovXG5cdHNldFRvQW5nbGUoYW5nbGU6IG51bWJlciwgcmFkaXVzOiBudW1iZXIgPSAxKTogVmVjMiB7XG5cdFx0dGhpcy54ID0gTWF0aFV0aWxzLmZsb29yVG9QbGFjZShNYXRoLmNvcyhhbmdsZSkqcmFkaXVzLCA1KTtcblx0XHR0aGlzLnkgPSBNYXRoVXRpbHMuZmxvb3JUb1BsYWNlKC1NYXRoLnNpbihhbmdsZSkqcmFkaXVzLCA1KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdmVjdG9yIHRoYXQgcG9pbnQgZnJvbSB0aGlzIHZlY3RvciB0byBhbm90aGVyIG9uZVxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBwb2ludCB0b1xuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHRoYXQgcG9pbnRzIGZyb20gdGhpcyB2ZWN0b3IgdG8gdGhlIG9uZSBwcm92aWRlZFxuXHQgKi9cblx0dmVjVG8ob3RoZXI6IFZlYzIpOiBWZWMyIHtcblx0XHRyZXR1cm4gbmV3IFZlYzIob3RoZXIueCAtIHRoaXMueCwgb3RoZXIueSAtIHRoaXMueSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdmVjdG9yIGNvbnRhaW5pbmcgdGhlIGRpcmVjdGlvbiBmcm9tIHRoaXMgdmVjdG9yIHRvIGFub3RoZXJcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gcG9pbnQgdG9cblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiB0aGF0IHBvaW50cyBmcm9tIHRoaXMgdmVjdG9yIHRvIHRoZSBvbmUgcHJvdmlkZWQuIFRoaXMgbmV3IFZlYzIgd2lsbCBiZSBhIHVuaXQgdmVjdG9yLlxuXHQgKi9cblx0ZGlyVG8ob3RoZXI6IFZlYzIpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy52ZWNUbyhvdGhlcikubm9ybWFsaXplKCk7XG5cdH1cblxuXHQvKipcblx0ICogS2VlcHMgdGhlIHZlY3RvcidzIGRpcmVjdGlvbiwgYnV0IHNldHMgaXRzIG1hZ25pdHVkZSB0byBiZSB0aGUgcHJvdmlkZWQgbWFnbml0dWRlXG5cdCAqIEBwYXJhbSBtYWduaXR1ZGUgVGhlIG1hZ25pdHVkZSB0aGUgdmVjdG9yIHNob3VsZCBiZVxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciB3aXRoIGl0cyBtYWduaXR1ZGUgc2V0IHRvIHRoZSBuZXcgbWFnbml0dWRlXG5cdCAqL1xuXHRzY2FsZVRvKG1hZ25pdHVkZTogbnVtYmVyKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkuc2NhbGUobWFnbml0dWRlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTY2FsZXMgeCBhbmQgeSBieSB0aGUgbnVtYmVyIHByb3ZpZGVkLCBvciBpZiB0d28gbnVtYmVyIGFyZSBwcm92aWRlZCwgc2NhbGVzIHRoZW0gaW5kaXZpZHVhbGx5LlxuXHQgKiBAcGFyYW0gZmFjdG9yIFRoZSBzY2FsaW5nIGZhY3RvciBmb3IgdGhlIHZlY3Rvciwgb3IgZm9yIG9ubHkgdGhlIHgtY29tcG9uZW50IGlmIHlGYWN0b3IgaXMgcHJvdmlkZWRcblx0ICogQHBhcmFtIHlGYWN0b3IgVGhlIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgeS1jb21wb25lbnQgb2YgdGhlIHZlY3RvclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBzY2FsaW5nXG5cdCAqL1xuXHRzY2FsZShmYWN0b3I6IG51bWJlciwgeUZhY3RvcjogbnVtYmVyID0gbnVsbCk6IFZlYzIge1xuXHRcdGlmKHlGYWN0b3IgIT09IG51bGwpe1xuXHRcdFx0dGhpcy54ICo9IGZhY3Rvcjtcblx0XHRcdHRoaXMueSAqPSB5RmFjdG9yO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHRoaXMueCAqPSBmYWN0b3I7XG5cdFx0dGhpcy55ICo9IGZhY3Rvcjtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc2NhbGVkIHZlcnNpb24gb2YgdGhpcyB2ZWN0b3Igd2l0aG91dCBtb2RpZnlpbmcgaXQuXG5cdCAqIEBwYXJhbSBmYWN0b3IgVGhlIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgdmVjdG9yLCBvciBmb3Igb25seSB0aGUgeC1jb21wb25lbnQgaWYgeUZhY3RvciBpcyBwcm92aWRlZFxuXHQgKiBAcGFyYW0geUZhY3RvciBUaGUgc2NhbGluZyBmYWN0b3IgZm9yIHRoZSB5LWNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG5cdCAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciB0aGF0IGhhcyB0aGUgdmFsdWVzIG9mIHRoaXMgdmVjdG9yIGFmdGVyIHNjYWxpbmdcblx0ICovXG5cdHNjYWxlZChmYWN0b3I6IG51bWJlciwgeUZhY3RvcjogbnVtYmVyID0gbnVsbCk6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuc2NhbGUoZmFjdG9yLCB5RmFjdG9yKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSb3RhdGVzIHRoZSB2ZWN0b3IgY291bnRlci1jbG9ja3dpc2UgYnkgdGhlIGFuZ2xlIGFtb3VudCBzcGVjaWZpZWRcblx0ICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSB0byByb3RhdGUgYnkgaW4gcmFkaWFuc1xuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciByb3RhdGlvbi5cblx0ICovXG5cdHJvdGF0ZUNDVyhhbmdsZTogbnVtYmVyKTogVmVjMiB7XG5cdFx0bGV0IGNzID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdGxldCBzbiA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRsZXQgdGVtcFggPSB0aGlzLngqY3MgLSB0aGlzLnkqc247XG5cdFx0bGV0IHRlbXBZID0gdGhpcy54KnNuICsgdGhpcy55KmNzO1xuXHRcdHRoaXMueCA9IHRlbXBYO1xuXHRcdHRoaXMueSA9IHRlbXBZO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZlY3RvcnMgY29vcmRpbmF0ZXMgdG8gYmUgdGhlIG9uZXMgcHJvdmlkZWRcblx0ICogQHBhcmFtIHggVGhlIG5ldyB4IHZhbHVlIGZvciB0aGlzIHZlY3RvclxuXHQgKiBAcGFyYW0geSBUaGUgbmV3IHkgdmFsdWUgZm9yIHRoaXMgdmVjdG9yXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yXG5cdCAqL1xuXHRzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBWZWMyIHtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgdGhlIG90aGVyIFZlYzIgaW50byB0aGlzIG9uZS5cblx0ICogQHBhcmFtIG90aGVyIFRoZSBWZWMyIHRvIGNvcHlcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3Igd2l0aCBpdHMgdmFsdWVzIHNldCB0byB0aGUgdmVjdG9yIHByb3ZpZGVkXG5cdCAqL1xuXHRjb3B5KG90aGVyOiBWZWMyKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0KG90aGVyLngsIG90aGVyLnkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhpcyB2ZWN0b3IgdGhlIGFub3RoZXIgdmVjdG9yXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgVmVjMiB0byBhZGQgdG8gdGhpcyBvbmVcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgYWRkaW5nIHRoZSBvbmUgcHJvdmlkZWRcblx0ICovXG5cdGFkZChvdGhlcjogVmVjMik6IFZlYzIge1xuXHRcdHRoaXMueCArPSBvdGhlci54O1xuXHRcdHRoaXMueSArPSBvdGhlci55O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluY3JlbWVudHMgdGhlIGZpZWxkcyBvZiB0aGlzIHZlY3Rvci4gQm90aCBhcmUgaW5jcmVtZW50ZWQgd2l0aCBhLCBpZiBvbmx5IGEgaXMgcHJvdmlkZWQuXG5cdCAqIEBwYXJhbSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gaW5jcmVtZW50IGJ5XG5cdCAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgbnVtYmVyIHRvIGluY3JlbWVudCBieVxuXHQgKiBAcmV0dXJuc3MgVGhpcyB2ZWN0b3IgYWZ0ZXIgaW5jcmVtZW50aW5nXG5cdCAqL1xuXHRpbmMoYTogbnVtYmVyLCBiPzogbnVtYmVyKTogVmVjMiB7XG5cdFx0aWYoYiA9PT0gdW5kZWZpbmVkKXtcblx0XHRcdHRoaXMueCArPSBhO1xuXHRcdFx0dGhpcy55ICs9IGE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMueCArPSBhO1xuXHRcdFx0dGhpcy55ICs9IGI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN1YnRyYWN0cyBhbm90aGVyIHZlY3RvciBmcm9tIHRoaXMgdmVjdG9yXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgVmVjMiB0byBzdWJ0cmFjdCBmcm9tIHRoaXMgb25lXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIHN1YnRyYWN0aW5nIHRoZSBvbmUgcHJvdmlkZWRcblx0ICovXG5cdHN1YihvdGhlcjogVmVjMik6IFZlYzIge1xuXHRcdHRoaXMueCAtPSBvdGhlci54O1xuXHRcdHRoaXMueSAtPSBvdGhlci55O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGxpZXMgdGhpcyB2ZWN0b3Igd2l0aCBhbm90aGVyIHZlY3RvciBlbGVtZW50LXdpc2UuIEluIG90aGVyIHdvcmRzLCB0aGlzLnggKj0gb3RoZXIueCBhbmQgdGhpcy55ICo9IG90aGVyLnlcblx0ICogQHBhcmFtIG90aGVyIFRoZSBWZWMyIHRvIG11bHRpcGx5IHRoaXMgb25lIGJ5XG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIG11bHRpcGx5aW5nIGl0cyBjb21wb25lbnRzIGJ5IHRoaXMgb25lXG5cdCAqL1xuXHRtdWx0KG90aGVyOiBWZWMyKTogVmVjMiB7XG5cdFx0dGhpcy54ICo9IG90aGVyLng7XG5cdFx0dGhpcy55ICo9IG90aGVyLnk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogRGl2aWRlcyB0aGlzIHZlY3RvciB3aXRoIGFub3RoZXIgdmVjdG9yIGVsZW1lbnQtd2lzZS4gSW4gb3RoZXIgd29yZHMsIHRoaXMueCAvPSBvdGhlci54IGFuZCB0aGlzLnkgLz0gb3RoZXIueVxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBkaXZpZGUgdGhpcyBvbmUgYnlcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgZGl2aXNpb25cblx0ICovXG5cdGRpdihvdGhlcjogVmVjMik6IFZlYzIge1xuXHRcdGlmKG90aGVyLnggPT09IDAgfHwgb3RoZXIueSA9PT0gMCkgdGhyb3cgXCJEaXZpZGUgYnkgemVybyBlcnJvclwiO1xuXHRcdHRoaXMueCAvPSBvdGhlci54O1xuXHRcdHRoaXMueSAvPSBvdGhlci55O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIERvZXMgYW4gZWxlbWVudCB3aXNlIHJlbWFpbmRlciBvcGVyYXRpb24gb24gdGhpcyB2ZWN0b3IuIHRoaXMueCAlPSBvdGhlci54IGFuZCB0aGlzLnkgJT0gb3RoZXIueVxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIHZlY3RvclxuXHQgKiBAcmV0dXJucyB0aGlzIHZlY3RvclxuXHQgKi9cblx0cmVtYWluZGVyKG90aGVyOiBWZWMyKTogVmVjMiB7XG5cdFx0dGhpcy54ID0gdGhpcy54ICUgb3RoZXIueDtcblx0XHR0aGlzLnkgPSB0aGlzLnkgJSBvdGhlci55O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgYW5vdGhlciB2ZWN0b3Jcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY29tcHV0ZSBkaXN0YW5jZSBzcXVhcmVkIHRvXG5cdCAqIEByZXR1cm5zIFRoZSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIHRoZSBvbmUgcHJvdmlkZWRcblx0ICovXG5cdGRpc3RhbmNlU3FUbyhvdGhlcjogVmVjMik6IG51bWJlciB7XG5cdFx0cmV0dXJuICh0aGlzLnggLSBvdGhlci54KSoodGhpcy54IC0gb3RoZXIueCkgKyAodGhpcy55IC0gb3RoZXIueSkqKHRoaXMueSAtIG90aGVyLnkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXIgdmVjdG9yXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgZGlzdGFuY2UgdG9cblx0ICogQHJldHVybnMgVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIHRoZSBvbmUgcHJvdmlkZWRcblx0ICovXG5cdGRpc3RhbmNlVG8ob3RoZXI6IFZlYzIpOiBudW1iZXIge1xuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVNxVG8ob3RoZXIpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkb3QgcHJvZHVjdCBvZiB0aGlzIHZlY3RvciBhbmQgYW5vdGhlclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjb21wdXRlIHRoZSBkb3QgcHJvZHVjdCB3aXRoXG5cdCAqIEByZXR1cm5zIFRoZSBkb3QgcHJvZHVjdCBvZiB0aGlzIHZlY3RvciBhbmQgdGhlIG9uZSBwcm92aWRlZC5cblx0ICovXG5cdGRvdChvdGhlcjogVmVjMik6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMueCpvdGhlci54ICsgdGhpcy55Km90aGVyLnk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYW5nbGUgY291bnRlci1jbG9ja3dpc2UgaW4gcmFkaWFucyBmcm9tIHRoaXMgdmVjdG9yIHRvIGFub3RoZXIgdmVjdG9yXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgdGhlIGFuZ2xlIHRvXG5cdCAqIEByZXR1cm5zIFRoZSBhbmdsZSwgcm90YXRpbmcgQ0NXLCBmcm9tIHRoaXMgdmVjdG9yIHRvIHRoZSBvdGhlciB2ZWN0b3Jcblx0ICovXG5cdGFuZ2xlVG9DQ1cob3RoZXI6IFZlYzIpOiBudW1iZXIge1xuXHRcdGxldCBkb3QgPSB0aGlzLmRvdChvdGhlcik7XG5cdFx0bGV0IGRldCA9IHRoaXMueCpvdGhlci55IC0gdGhpcy55Km90aGVyLng7XG5cdFx0bGV0IGFuZ2xlID0gLU1hdGguYXRhbjIoZGV0LCBkb3QpO1xuXG5cdFx0aWYoYW5nbGUgPCAwKXtcblx0XHRcdGFuZ2xlICs9IDIqTWF0aC5QSTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYW5nbGU7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZlY3RvciByb3VuZGVkIHRvIDEgZGVjaW1hbCBwb2ludFxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhcyBhIHN0cmluZ1xuXHQgKi9cblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy50b0ZpeGVkKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZlY3RvciByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzXG5cdCAqIEBwYXJhbSBudW1EZWNpbWFsUG9pbnRzIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMgdG8gY3JlYXRlIGEgc3RyaW5nIHRvXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFzIGEgc3RyaW5nXG5cdCAqL1xuXHR0b0ZpeGVkKG51bURlY2ltYWxQb2ludHM6IG51bWJlciA9IDEpOiBzdHJpbmcge1xuXHRcdHJldHVybiBcIihcIiArIHRoaXMueC50b0ZpeGVkKG51bURlY2ltYWxQb2ludHMpICsgXCIsIFwiICsgdGhpcy55LnRvRml4ZWQobnVtRGVjaW1hbFBvaW50cykgKyBcIilcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciB3aXRoIHRoZSBzYW1lIGNvb3JkaW5hdGVzIGFzIHRoaXMgb25lLlxuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgb25lXG5cdCAqL1xuXHRjbG9uZSgpOiBWZWMyIHtcblx0XHRyZXR1cm4gbmV3IFZlYzIodGhpcy54LCB0aGlzLnkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHZlY3RvciBhbmQgb3RoZXIgaGF2ZSB0aGUgRVhBQ1Qgc2FtZSB4IGFuZCB5IChub3QgYXNzdXJlZCB0byBiZSBzYWZlIGZvciBmbG9hdHMpXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNoZWNrIGFnYWluc3Rcblx0ICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgZXF1YWxpdHkgb2YgdGhlIHR3byB2ZWN0b3JzXG5cdCAqL1xuXHRzdHJpY3RFcXVhbHMob3RoZXI6IFZlYzIpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy54ID09PSBvdGhlci54ICYmIHRoaXMueSA9PT0gb3RoZXIueTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB2ZWN0b3IgYW5kIG90aGVyIGhhdmUgdGhlIHNhbWUgeCBhbmQgeVxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjaGVjayBhZ2FpbnN0XG5cdCAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIGVxdWFsaXR5IG9mIHRoZSB0d28gdmVjdG9yc1xuXHQgKi9cblx0ZXF1YWxzKG90aGVyOiBWZWMyKTogYm9vbGVhbiB7XG5cdFx0bGV0IHhFcSA9IE1hdGguYWJzKHRoaXMueCAtIG90aGVyLngpIDwgMC4wMDAwMDAxO1xuXHRcdGxldCB5RXEgPSBNYXRoLmFicyh0aGlzLnkgLSBvdGhlci55KSA8IDAuMDAwMDAwMTtcblxuXHRcdHJldHVybiB4RXEgJiYgeUVxO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHZlY3RvciBpcyB0aGUgemVybyB2ZWN0b3IgZXhhY3RseSAobm90IGFzc3VyZWQgdG8gYmUgc2FmZSBmb3IgZmxvYXRzKS5cblx0ICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgZXF1YWxpdHkgb2YgdGhpcyB2ZWN0b3IgYW5kIHRoZSB6ZXJvIHZlY3RvclxuXHQgKi9cblx0c3RyaWN0SXNaZXJvKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLnggPT09IDAgJiYgdGhpcy55ID09PSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHggYW5kIHkgZm9yIHRoaXMgdmVjdG9yIGFyZSBib3RoIHplcm8uXG5cdCAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIGVxdWFsaXR5IG9mIHRoaXMgdmVjdG9yIGFuZCB0aGUgemVybyB2ZWN0b3Jcblx0ICovXG5cdGlzWmVybygpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gTWF0aC5hYnModGhpcy54KSA8IDAuMDAwMDAwMSAmJiBNYXRoLmFicyh0aGlzLnkpIDwgMC4wMDAwMDAxO1xuXHR9XG5cdFxuXHQvKipcblx0ICogU2V0cyB0aGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhpcyB2ZWN0b3IgaXMgY2hhbmdlZC5cblx0ICogQHBhcmFtIGYgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuXHQgKi9cblx0c2V0T25DaGFuZ2UoZjogRnVuY3Rpb24pOiB2b2lkIHtcblx0XHR0aGlzLm9uQ2hhbmdlID0gZjtcblx0fVxuXG5cdHRvQXJyYXkoKTogRmxvYXQzMkFycmF5IHtcblx0XHRyZXR1cm4gdGhpcy52ZWM7XG5cdH1cblxuXHQvKipcblx0ICogUGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjdG9yc1xuXHQgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmVjdG9yXG5cdCAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yXG5cdCAqIEBwYXJhbSB0IFRoZSB0aW1lIG9mIHRoZSBsZXJwLCB3aXRoIDAgYmVpbmcgdmVjdG9yIEEsIGFuZCAxIGJlaW5nIHZlY3RvciBCXG5cdCAqIEByZXR1cm5zIEEgbmV3IFZlYzIgcmVwcmVzZW50aW5nIHRoZSBsZXJwIGJldHdlZW4gdmVjdG9yIGEgYW5kIGIuXG5cdCAqL1xuXHRzdGF0aWMgbGVycChhOiBWZWMyLCBiOiBWZWMyLCB0OiBudW1iZXIpOiBWZWMyIHtcblx0XHRyZXR1cm4gbmV3IFZlYzIoTWF0aFV0aWxzLmxlcnAoYS54LCBiLngsIHQpLCBNYXRoVXRpbHMubGVycChhLnksIGIueSwgdCkpO1xuXHR9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XG5cbi8qKlxuICogQSB1dGlsIGNsYXNzIGZvciByZW5kZXJpbmcgRGVidWcgbWVzc2FnZXMgdG8gdGhlIGNhbnZhcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVidWcge1xuXG5cdC8qKiBBIG1hcCBvZiBsb2cgbWVzc2FnZXMgdG8gZGlzcGxheSBvbiB0aGUgc2NyZWVuICovIFxuXHRwcml2YXRlIHN0YXRpYyBsb2dNZXNzYWdlczogTWFwPHN0cmluZz4gPSBuZXcgTWFwKCk7XG5cblx0LyoqIEFuIGFycmF5IG9mIGdhbWUgbm9kZXMgdG8gcmVuZGVyIGRlYnVnIGluZm8gZm9yICovXG5cdHByaXZhdGUgc3RhdGljIG5vZGVzOiBBcnJheTxHYW1lTm9kZT47XG5cblx0LyoqIFRoZSByZW5kZXJpbmcgY29udGV4dCBmb3IgYW55IGRlYnVnIG1lc3NhZ2VzICovXG5cdHByaXZhdGUgc3RhdGljIGRlYnVnUmVuZGVyaW5nQ29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuXG5cdC8qKlx0VGhlIHNpemUgb2YgdGhlIGRlYnVnIGNhbnZhcyAqL1xuXHRwcml2YXRlIHN0YXRpYyBkZWJ1Z0NhbnZhc1NpemU6IFZlYzI7XG5cblx0LyoqIFRoZSByZW5kZXJpbmcgY29sb3IgZm9yIHRleHQgKi9cblx0cHJpdmF0ZSBzdGF0aWMgZGVmYXVsdFRleHRDb2xvcjogQ29sb3IgPSBDb2xvci5XSElURTtcblxuXHQvKipcblx0ICogQWRkIGEgbWVzc2FnZSB0byBkaXNwbGF5IG9uIHRoZSBkZWJ1ZyBzY3JlZW5cblx0ICogQHBhcmFtIGlkIEEgdW5pcXVlIElEIGZvciB0aGlzIG1lc3NhZ2Vcblx0ICogQHBhcmFtIG1lc3NhZ2VzIFRoZSBtZXNzYWdlcyB0byBwcmludCB0byB0aGUgZGVidWcgc2NyZWVuXG5cdCAqL1xuXHRzdGF0aWMgbG9nKGlkOiBzdHJpbmcsIC4uLm1lc3NhZ2VzOiBhbnkpOiB2b2lkIHtcblx0XHQvLyBsZXQgbWVzc2FnZSA9IFwiXCI7XG5cdFx0Ly8gZm9yKGxldCBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKXtcblx0XHQvLyBcdG1lc3NhZ2UgKz0gbWVzc2FnZXNbaV0udG9TdHJpbmcoKTtcblx0XHQvLyB9XG5cdFx0Ly8gSm9pbiBhbGwgbWVzc2FnZXMgd2l0aCBzcGFjZXNcblx0XHRsZXQgbWVzc2FnZSA9IG1lc3NhZ2VzLm1hcCgobTogYW55KSA9PiBtLnRvU3RyaW5nKCkpLmpvaW4oXCIgXCIpO1xuXHRcdHRoaXMubG9nTWVzc2FnZXMuYWRkKGlkLCBtZXNzYWdlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWxldGVzIGEgYSBrZXkgZnJvbSB0aGUgbG9nIGFuZCBzdG9wcyBpdCBmcm9tIGtlZXBpbmcgdXAgc3BhY2Ugb24gdGhlIHNjcmVlblxuXHQgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBsb2cgaXRlbSB0byBjbGVhclxuXHQgKi9cblx0c3RhdGljIGNsZWFyTG9nSXRlbShpZDogc3RyaW5nKTogdm9pZCB7XG5cdFx0dGhpcy5sb2dNZXNzYWdlcy5kZWxldGUoaWQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGxpc3Qgb2Ygbm9kZXMgdG8gcmVuZGVyIHdpdGggdGhlIGRlYnVnZ2VyXG5cdCAqIEBwYXJhbSBub2RlcyBUaGUgbmV3IGxpc3Qgb2Ygbm9kZXNcblx0ICovXG5cdHN0YXRpYyBzZXROb2Rlcyhub2RlczogQXJyYXk8R2FtZU5vZGU+KTogdm9pZCB7XG5cdFx0dGhpcy5ub2RlcyA9IG5vZGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgYm94IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cblx0ICogQHBhcmFtIGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSBib3hcblx0ICogQHBhcmFtIGhhbGZTaXplIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBib3hcblx0ICogQHBhcmFtIGZpbGxlZCBBIGJvb2xlYW4gZm9yIHdoZXRoZXIgb3Igbm90IHRoZSBib3ggaXMgZmlsbGVkXG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIGJveCB0byBkcmF3XG5cdCAqL1xuXHRzdGF0aWMgZHJhd0JveChjZW50ZXI6IFZlYzIsIGhhbGZTaXplOiBWZWMyLCBmaWxsZWQ6IGJvb2xlYW4sIGNvbG9yOiBDb2xvcik6IHZvaWQge1xuXHRcdGxldCBhbHBoYSA9IHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lmdsb2JhbEFscGhhO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lmdsb2JhbEFscGhhID0gY29sb3IuYTtcblxuXHRcdGlmKGZpbGxlZCl7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFJlY3QoY2VudGVyLnggLSBoYWxmU2l6ZS54LCBjZW50ZXIueSAtIGhhbGZTaXplLnksIGhhbGZTaXplLngqMiwgaGFsZlNpemUueSoyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGxpbmVXaWR0aCA9IDI7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2VSZWN0KGNlbnRlci54IC0gaGFsZlNpemUueCwgY2VudGVyLnkgLSBoYWxmU2l6ZS55LCBoYWxmU2l6ZS54KjIsIGhhbGZTaXplLnkqMik7XG5cdFx0fVxuXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIGNpcmNsZSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG5cdCAqIEBwYXJhbSByYWRpdXMgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGJveFxuXHQgKiBAcGFyYW0gZmlsbGVkIEEgYm9vbGVhbiBmb3Igd2hldGhlciBvciBub3QgdGhlIGNpcmNsZSBpcyBmaWxsZWRcblx0ICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgY2lyY2xlXG5cdCAqL1xuXHRzdGF0aWMgZHJhd0NpcmNsZShjZW50ZXI6IFZlYzIsIHJhZGl1czogbnVtYmVyLCBmaWxsZWQ6IGJvb2xlYW4sIGNvbG9yOiBDb2xvcik6IHZvaWQge1xuXHRcdGxldCBhbHBoYSA9IHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lmdsb2JhbEFscGhhO1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lmdsb2JhbEFscGhhID0gY29sb3IuYTtcblxuXHRcdGlmKGZpbGxlZCl7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5hcmMoY2VudGVyLngsIGNlbnRlci55LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmNsb3NlUGF0aCgpO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgbGluZVdpZHRoID0gMjtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuYXJjKGNlbnRlci54LCBjZW50ZXIueSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5jbG9zZVBhdGgoKTtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG5cdH1cblxuXHQvKipcblx0ICogRHJhd3MgYSByYXkgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuXHQgKiBAcGFyYW0gZnJvbSBUaGUgc3RhcnRpbmcgcG9zaXRpb24gb2YgdGhlIHJheVxuXHQgKiBAcGFyYW0gdG8gVGhlIGVuZGluZyBwb3NpdGlvbiBvZiB0aGUgcmF5XG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIHJheVxuXHQgKi9cblx0c3RhdGljIGRyYXdSYXkoZnJvbTogVmVjMiwgdG86IFZlYzIsIGNvbG9yOiBDb2xvcik6IHZvaWQge1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmxpbmVXaWR0aCA9IDI7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xuXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubW92ZVRvKGZyb20ueCwgZnJvbS55KTtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5saW5lVG8odG8ueCwgdG8ueSk7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuY2xvc2VQYXRoKCk7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlKCk7XG5cdH1cblxuXHQvKipcblx0ICogRHJhd3MgYSBwb2ludCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXG5cdCAqIEBwYXJhbSBwb3MgVGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludFxuXHQgKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBwb2ludFxuXHQgKi9cblx0c3RhdGljIGRyYXdQb2ludChwb3M6IFZlYzIsIGNvbG9yOiBDb2xvcik6IHZvaWQge1xuXHRcdGxldCBwb2ludFNpemUgPSA2O1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFJlY3QocG9zLnggLSBwb2ludFNpemUvMiwgcG9zLnkgLSBwb2ludFNpemUvMiwgcG9pbnRTaXplLCBwb2ludFNpemUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGRlZmF1bHQgcmVuZGVyaW5nIGNvbG9yIGZvciB0ZXh0IGZvciB0aGUgZGVidWdnZXJcblx0ICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciB0byByZW5kZXIgdGhlIHRleHRcblx0ICovXG5cdHN0YXRpYyBzZXREZWZhdWx0VGV4dENvbG9yKGNvbG9yOiBDb2xvcik6IHZvaWQge1xuXHRcdHRoaXMuZGVmYXVsdFRleHRDb2xvciA9IGNvbG9yO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBlcmZvcm1zIGFueSBuZWNlc3Nhcnkgc2V0dXAgb3BlcmF0aW9ucyBvbiB0aGUgRGVidWcgY2FudmFzXG5cdCAqIEBwYXJhbSBjYW52YXMgVGhlIGRlYnVnIGNhbnZhc1xuXHQgKiBAcGFyYW0gd2lkdGggVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0gaGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgY2FudmFzXG5cdCAqIEByZXR1cm5zIFRoZSByZW5kZXJpbmcgY29udGV4dCBleHRyYWN0ZWQgZnJvbSB0aGUgY2FudmFzXG5cdCAqL1xuXHRzdGF0aWMgaW5pdGlhbGl6ZURlYnVnQ2FudmFzKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG5cdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcblx0XHRcblx0XHR0aGlzLmRlYnVnQ2FudmFzU2l6ZSA9IG5ldyBWZWMyKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQ7XG5cdH1cblxuXHQvKiogQ2xlYXJzIHRoZSBkZWJ1ZyBjYW52YXMgKi9cblx0c3RhdGljIGNsZWFyQ2FudmFzKCk6IHZvaWQge1xuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmRlYnVnQ2FudmFzU2l6ZS54LCB0aGlzLmRlYnVnQ2FudmFzU2l6ZS55KTtcblx0fVxuXG5cdC8qKiBSZW5kZXJzIHRoZSB0ZXh0IGFuZCBub2RlcyBzZW50IHRvIHRoZSBEZWJ1ZyBzeXN0ZW0gKi9cblx0c3RhdGljIHJlbmRlcigpOiB2b2lkIHtcblx0XHR0aGlzLnJlbmRlclRleHQoKTtcblx0XHR0aGlzLnJlbmRlck5vZGVzKCk7XG5cdH1cblxuXHQvKiogUmVuZGVycyB0aGUgdGV4dCBzZW50IHRvIHRoZSBEZWJ1ZyBjYW52YXMgKi9cblx0c3RhdGljIHJlbmRlclRleHQoKTogdm9pZCB7XG5cdFx0bGV0IHkgPSAyMDtcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5mb250ID0gXCIyMHB4IEFyaWFsXCI7XG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5kZWZhdWx0VGV4dENvbG9yLnRvU3RyaW5nKCk7XG5cblx0XHQvLyBEcmF3IGFsbCBvZiB0aGUgdGV4dFxuXHRcdHRoaXMubG9nTWVzc2FnZXMuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IHtcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxUZXh0KHRoaXMubG9nTWVzc2FnZXMuZ2V0KGtleSksIDEwLCB5KVxuXHRcdFx0eSArPSAzMDtcdFxuXHRcdH0pO1xuXHR9XG5cblx0LyoqIFJlbmRlcnMgdGhlIG5vZGVzIHJlZ2lzdGVyZWQgd2l0aCB0aGUgZGVidWcgY2FudmFzICovXG5cdHN0YXRpYyByZW5kZXJOb2RlcygpOiB2b2lkIHtcblx0XHRpZih0aGlzLm5vZGVzKXtcblx0XHRcdHRoaXMubm9kZXMuZm9yRWFjaChub2RlID0+IHtcblx0XHRcdFx0bm9kZS5kZWJ1Z1JlbmRlcigpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59IiwiaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuXG4vLyBAaWdub3JlUGFnZVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdHMgZXh0ZW5kcyBPYmplY3Qge1xuICAgIC8vIFRoZSBmcHMgb2YgdGhlIGdhbWUuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJldmZwczogQXJyYXk8bnVtYmVyPjtcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBOVU1fUE9JTlRTOiBudW1iZXIgPSA2MDtcbiAgICBwcml2YXRlIHN0YXRpYyBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICBwcml2YXRlIHN0YXRpYyBDQU5WQVNfV0lEVEg6IG51bWJlciA9IDMwMDtcbiAgICBwcml2YXRlIHN0YXRpYyBDQU5WQVNfSEVJR0hUOiBudW1iZXIgPSAzMDA7XG4gICAgcHJpdmF0ZSBzdGF0aWMgc3RhdHNEaXY6IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgc3RhdGljIGdyYXBoQ2hvaWNlczogSFRNTFNlbGVjdEVsZW1lbnQ7XG5cbiAgICAvLyBRdWFkdHJlZSBzdGF0c1xuICAgIHByaXZhdGUgc3RhdGljIHByZXZDbGVhclRpbWVzOiBBcnJheTxudW1iZXI+O1xuICAgIHByaXZhdGUgc3RhdGljIFNHQ2xlYXJUaW1lczogQXJyYXk8bnVtYmVyPjtcbiAgICBwcml2YXRlIHN0YXRpYyBhdmdTR0NsZWFyVGltZTogbnVtYmVyO1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJldkZpbGxUaW1lczogQXJyYXk8bnVtYmVyPjtcbiAgICBwcml2YXRlIHN0YXRpYyBTR0ZpbGxUaW1lczogQXJyYXk8bnVtYmVyPjtcbiAgICBwcml2YXRlIHN0YXRpYyBhdmdTR0ZpbGxUaW1lOiBudW1iZXI7XG5cbiAgICBwcml2YXRlIHN0YXRpYyBwcmV2VXBkYXRlVGltZXM6IEFycmF5PG51bWJlcj47XG4gICAgcHJpdmF0ZSBzdGF0aWMgU0dVcGRhdGVUaW1lczogQXJyYXk8bnVtYmVyPjtcbiAgICBwcml2YXRlIHN0YXRpYyBhdmdTR1VwZGF0ZVRpbWU6IG51bWJlcjtcblxuICAgIHByaXZhdGUgc3RhdGljIHByZXZRdWVyeVRpbWVzOiBBcnJheTxudW1iZXI+O1xuICAgIHByaXZhdGUgc3RhdGljIFNHUXVlcnlUaW1lczogQXJyYXk8bnVtYmVyPjtcbiAgICBwcml2YXRlIHN0YXRpYyBhdmdTR1F1ZXJ5VGltZTogbnVtYmVyO1xuXG4gICAgc3RhdGljIGluaXRTdGF0cygpOiB2b2lkIHtcbiAgICAgICAgbGV0IGNhbnZhcyA9IDxIVE1MQ2FudmFzRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXRzLWNhbnZhc1wiKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5DQU5WQVNfV0lEVEg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLkNBTlZBU19IRUlHSFQ7XG4gICAgICAgIHRoaXMuY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgICB0aGlzLnN0YXRzRGl2ID0gPEhUTUxEaXZFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhdHMtZGlzcGxheVwiKTtcblxuICAgICAgICB0aGlzLnByZXZmcHMgPSBuZXcgQXJyYXkoKTtcblxuICAgICAgICB0aGlzLnByZXZDbGVhclRpbWVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuU0dDbGVhclRpbWVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuYXZnU0dDbGVhclRpbWUgPSAwO1xuXG4gICAgICAgIHRoaXMucHJldkZpbGxUaW1lcyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLlNHRmlsbFRpbWVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuYXZnU0dGaWxsVGltZSA9IDA7XG5cbiAgICAgICAgdGhpcy5wcmV2VXBkYXRlVGltZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5TR1VwZGF0ZVRpbWVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuYXZnU0dVcGRhdGVUaW1lID0gMDtcblxuICAgICAgICB0aGlzLnByZXZRdWVyeVRpbWVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuU0dRdWVyeVRpbWVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuYXZnU0dRdWVyeVRpbWUgPSAwO1xuXG4gICAgICAgIGxldCBjbGVhclRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgY2xlYXJUaW1lLnNldEF0dHJpYnV0ZShcImlkXCIsIFwic2djbGVhclwiKTtcbiAgICAgICAgbGV0IGZpbGxUaW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIGZpbGxUaW1lLnNldEF0dHJpYnV0ZShcImlkXCIsIFwic2dmaWxsXCIpO1xuICAgICAgICBsZXQgdXBkYXRlVGltZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB1cGRhdGVUaW1lLnNldEF0dHJpYnV0ZShcImlkXCIsIFwic2d1cGRhdGVcIik7XG4gICAgICAgIGxldCBxdWVyeVRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgcXVlcnlUaW1lLnNldEF0dHJpYnV0ZShcImlkXCIsIFwic2dxdWVyeVwiKTtcbiAgICAgICAgbGV0IGJyMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcbiAgICAgICAgbGV0IGJyMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcbiAgICAgICAgbGV0IGJyMyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcblxuICAgICAgICB0aGlzLnN0YXRzRGl2LmFwcGVuZChjbGVhclRpbWUsIGJyMSwgZmlsbFRpbWUsIGJyMiwgdXBkYXRlVGltZSwgYnIzLCBxdWVyeVRpbWUpO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhDaG9pY2VzID0gPEhUTUxTZWxlY3RFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2hhcnQtb3B0aW9uXCIpO1xuICAgICAgICBsZXQgb3B0aW9uMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgIG9wdGlvbjEudmFsdWUgPSBcInByZXZmcHNcIjtcbiAgICAgICAgb3B0aW9uMS5sYWJlbCA9IFwiRlBTXCI7XG4gICAgICAgIGxldCBvcHRpb24yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgb3B0aW9uMi52YWx1ZSA9IFwicHJldkNsZWFyVGltZXNcIjtcbiAgICAgICAgb3B0aW9uMi5sYWJlbCA9IFwiQ2xlYXIgVGltZVwiO1xuICAgICAgICBsZXQgb3B0aW9uMyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgIG9wdGlvbjMudmFsdWUgPSBcInByZXZGaWxsVGltZXNcIjtcbiAgICAgICAgb3B0aW9uMy5sYWJlbCA9IFwiRmlsbCB0aW1lXCI7XG4gICAgICAgIGxldCBvcHRpb240ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgb3B0aW9uNC52YWx1ZSA9IFwicHJldlVwZGF0ZVRpbWVzXCI7XG4gICAgICAgIG9wdGlvbjQubGFiZWwgPSBcIlVwZGF0ZSB0aW1lXCI7XG4gICAgICAgIGxldCBvcHRpb241ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgb3B0aW9uNS52YWx1ZSA9IFwicHJldlF1ZXJ5VGltZXNcIjtcbiAgICAgICAgb3B0aW9uNS5sYWJlbCA9IFwiUXVlcnkgVGltZVwiO1xuICAgICAgICBsZXQgb3B0aW9uQWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgb3B0aW9uQWxsLnZhbHVlID0gXCJhbGxcIjtcbiAgICAgICAgb3B0aW9uQWxsLmxhYmVsID0gXCJBbGxcIjtcbiAgICAgICAgdGhpcy5ncmFwaENob2ljZXMuYXBwZW5kKG9wdGlvbjEsIG9wdGlvbjIsIG9wdGlvbjMsIG9wdGlvbjQsIG9wdGlvbjUsIG9wdGlvbkFsbCk7XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZUZQUyhmcHM6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnByZXZmcHMucHVzaChmcHMpO1xuICAgICAgICBpZih0aGlzLnByZXZmcHMubGVuZ3RoID4gU3RhdHMuTlVNX1BPSU5UUyl7XG4gICAgICAgICAgICB0aGlzLnByZXZmcHMuc2hpZnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuU0dDbGVhclRpbWVzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy5wcmV2Q2xlYXJUaW1lcy5wdXNoKHRoaXMuYXZnU0dDbGVhclRpbWUpO1xuICAgICAgICAgICAgaWYodGhpcy5wcmV2Q2xlYXJUaW1lcy5sZW5ndGggPiB0aGlzLk5VTV9QT0lOVFMpe1xuICAgICAgICAgICAgICAgIHRoaXMucHJldkNsZWFyVGltZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLlNHRmlsbFRpbWVzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy5wcmV2RmlsbFRpbWVzLnB1c2godGhpcy5hdmdTR0ZpbGxUaW1lKTtcbiAgICAgICAgICAgIGlmKHRoaXMucHJldkZpbGxUaW1lcy5sZW5ndGggPiB0aGlzLk5VTV9QT0lOVFMpe1xuICAgICAgICAgICAgICAgIHRoaXMucHJldkZpbGxUaW1lcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuU0dVcGRhdGVUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMucHJldlVwZGF0ZVRpbWVzLnB1c2godGhpcy5hdmdTR1VwZGF0ZVRpbWUpO1xuICAgICAgICAgICAgaWYodGhpcy5wcmV2VXBkYXRlVGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZVcGRhdGVUaW1lcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuU0dRdWVyeVRpbWVzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy5wcmV2UXVlcnlUaW1lcy5wdXNoKHRoaXMuYXZnU0dRdWVyeVRpbWUpO1xuICAgICAgICAgICAgaWYodGhpcy5wcmV2UXVlcnlUaW1lcy5sZW5ndGggPiB0aGlzLk5VTV9QT0lOVFMpe1xuICAgICAgICAgICAgICAgIHRoaXMucHJldlF1ZXJ5VGltZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlU0dTdGF0cygpO1xuICAgIH1cblxuICAgIHN0YXRpYyBsb2coa2V5OiBzdHJpbmcsIGRhdGE6IGFueSk6IHZvaWQge1xuICAgICAgICBpZihrZXkgPT09IFwic2djbGVhclwiKXtcbiAgICAgICAgICAgIHRoaXMuU0dDbGVhclRpbWVzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICBpZih0aGlzLlNHQ2xlYXJUaW1lcy5sZW5ndGggPiAxMDApe1xuICAgICAgICAgICAgICAgIHRoaXMuU0dDbGVhclRpbWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihrZXkgPT09IFwic2dmaWxsXCIpe1xuICAgICAgICAgICAgdGhpcy5TR0ZpbGxUaW1lcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgaWYodGhpcy5TR0ZpbGxUaW1lcy5sZW5ndGggPiAxMDApe1xuICAgICAgICAgICAgICAgIHRoaXMuU0dGaWxsVGltZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKGtleSA9PT0gXCJzZ3VwZGF0ZVwiKXtcbiAgICAgICAgICAgIHRoaXMuU0dVcGRhdGVUaW1lcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgaWYodGhpcy5TR1VwZGF0ZVRpbWVzLmxlbmd0aCA+IDEwMCl7XG4gICAgICAgICAgICAgICAgdGhpcy5TR1VwZGF0ZVRpbWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihrZXkgPT09IFwic2dxdWVyeVwiKXtcbiAgICAgICAgICAgIHRoaXMuU0dRdWVyeVRpbWVzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICBpZih0aGlzLlNHUXVlcnlUaW1lcy5sZW5ndGggPiAxMDAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLlNHUXVlcnlUaW1lcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBzdGF0aWMgcmVuZGVyKCk6IHZvaWQge1xuICAgICAgICAvLyBEaXNwbGF5IHN0YXRzXG4gICAgICAgIHRoaXMuZHJhd0NoYXJ0cygpO1xuICAgIH1cblxuICAgIHN0YXRpYyBkcmF3Q2hhcnRzKCl7XG4gICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLkNBTlZBU19XSURUSCwgdGhpcy5DQU5WQVNfSEVJR0hUKTtcblxuICAgICAgICBsZXQgcGFyYW1TdHJpbmcgPSB0aGlzLmdyYXBoQ2hvaWNlcy52YWx1ZTtcblxuICAgICAgICBpZihwYXJhbVN0cmluZyA9PT0gXCJwcmV2ZnBzXCIgfHwgcGFyYW1TdHJpbmcgPT09IFwiYWxsXCIpe1xuICAgICAgICAgICAgbGV0IHBhcmFtID0gdGhpcy5wcmV2ZnBzO1xuICAgICAgICAgICAgbGV0IGNvbG9yID0gQ29sb3IuQkxVRS50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Q2hhcnQocGFyYW0sIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZihwYXJhbVN0cmluZyA9PT0gXCJwcmV2Q2xlYXJUaW1lc1wiIHx8IHBhcmFtU3RyaW5nID09PSBcImFsbFwiKXtcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMucHJldkNsZWFyVGltZXM7XG4gICAgICAgICAgICBsZXQgY29sb3IgPSBDb2xvci5SRUQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NoYXJ0KHBhcmFtLCBjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldkZpbGxUaW1lc1wiIHx8IHBhcmFtU3RyaW5nID09PSBcImFsbFwiKXtcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMucHJldkZpbGxUaW1lcztcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLkdSRUVOLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBhcmFtU3RyaW5nID09PSBcInByZXZVcGRhdGVUaW1lc1wiIHx8IHBhcmFtU3RyaW5nID09PSBcImFsbFwiKXtcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMucHJldlVwZGF0ZVRpbWVzO1xuICAgICAgICAgICAgbGV0IGNvbG9yID0gQ29sb3IuQ1lBTi50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Q2hhcnQocGFyYW0sIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZihwYXJhbVN0cmluZyA9PT0gXCJwcmV2UXVlcnlUaW1lc1wiIHx8IHBhcmFtU3RyaW5nID09PSBcImFsbFwiKXtcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMucHJldlF1ZXJ5VGltZXM7XG4gICAgICAgICAgICBsZXQgY29sb3IgPSBDb2xvci5PUkFOR0UudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NoYXJ0KHBhcmFtLCBjb2xvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZHJhd0NoYXJ0KHBhcmFtOiBBcnJheTxudW1iZXI+LCBjb2xvcjogc3RyaW5nKXtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBDb2xvci5CTEFDSy50b1N0cmluZygpO1xuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKDEwLCAxMCk7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbygxMCwgdGhpcy5DQU5WQVNfSEVJR0hUIC0gMTApO1xuICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oMTAsIHRoaXMuQ0FOVkFTX0hFSUdIVCAtIDEwKTtcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKHRoaXMuQ0FOVkFTX1dJRFRIIC0gMTAsIHRoaXMuQ0FOVkFTX0hFSUdIVCAtIDEwKTtcbiAgICAgICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIGxldCBtYXggPSBNYXRoLm1heCguLi5wYXJhbSk7XG4gICAgICAgIGxldCBwcmV2WCA9IDEwO1xuICAgICAgICBsZXQgcHJldlkgPSB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCAtIHBhcmFtWzBdL21heCoodGhpcy5DQU5WQVNfSEVJR0hULTIwKTtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcblxuICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgcGFyYW0ubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbGV0IGZwcyA9IHBhcmFtW2ldO1xuICAgICAgICAgICAgbGV0IHggPSAxMCArIGkqKHRoaXMuQ0FOVkFTX1dJRFRIIC0gMjApL3RoaXMuTlVNX1BPSU5UUztcbiAgICAgICAgICAgIGxldCB5ID0gdGhpcy5DQU5WQVNfSEVJR0hUIC0gMTAgLSBmcHMvbWF4Kih0aGlzLkNBTlZBU19IRUlHSFQtMjApXG4gICAgICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuY3R4Lm1vdmVUbyhwcmV2WCwgcHJldlkpO1xuICAgICAgICAgICAgdGhpcy5jdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcblxuICAgICAgICAgICAgcHJldlggPSB4O1xuICAgICAgICAgICAgcHJldlkgPSB5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZVNHU3RhdHMoKXtcbiAgICAgICAgaWYodGhpcy5TR0NsZWFyVGltZXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICB0aGlzLmF2Z1NHQ2xlYXJUaW1lID0gdGhpcy5TR0NsZWFyVGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKS90aGlzLlNHQ2xlYXJUaW1lcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLlNHRmlsbFRpbWVzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy5hdmdTR0ZpbGxUaW1lID0gdGhpcy5TR0ZpbGxUaW1lcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpL3RoaXMuU0dGaWxsVGltZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5TR1VwZGF0ZVRpbWVzLmxlbmd0aCA+IDApe1xuICAgICAgICB0aGlzLmF2Z1NHVXBkYXRlVGltZSA9IHRoaXMuU0dVcGRhdGVUaW1lcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpL3RoaXMuU0dVcGRhdGVUaW1lcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLlNHUXVlcnlUaW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMuYXZnU0dRdWVyeVRpbWUgPSB0aGlzLlNHUXVlcnlUaW1lcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpL3RoaXMuU0dRdWVyeVRpbWVzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2djbGVhclwiKS5pbm5lckhUTUwgPSBcIkF2ZyBTRyBjbGVhciB0aW1lOiBcIiArIHRoaXMuYXZnU0dDbGVhclRpbWU7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2dmaWxsXCIpLmlubmVySFRNTCA9IFwiQXZnIFNHIGZpbGwgdGltZTogXCIgKyB0aGlzLmF2Z1NHRmlsbFRpbWU7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2d1cGRhdGVcIikuaW5uZXJIVE1MID0gXCJBdmcgU0cgdXBkYXRlIHRpbWU6IFwiICsgdGhpcy5hdmdTR1VwZGF0ZVRpbWU7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2dxdWVyeVwiKS5pbm5lckhUTUwgPSBcIkF2ZyBTRyBxdWVyeSB0aW1lOiBcIiArIHRoaXMuYXZnU0dRdWVyeVRpbWU7XG4gICAgfVxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuL0V2ZW50UXVldWVcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4vR2FtZUV2ZW50XCI7XG5cbi8qKlxuICogQW4gZXZlbnQgZW1pdHRlciBvYmplY3Qgb3RoZXIgc3lzdGVtcyBjYW4gdXNlIHRvIGhvb2sgaW50byB0aGUgRXZlbnRRdWV1ZS5cbiAqIFByb3ZpZGVzIGFuIGVhc3kgaW50ZXJmYWNlIGZvciBmaXJpbmcgb2ZmIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW1pdHRlciB7XG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgRXZlbnRRdWV1ZSAqL1xuXHRwcml2YXRlIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XG5cblx0LyoqIENyZWF0ZXMgYSBuZXcgRW1pdHRlciAqL1xuXHRjb25zdHJ1Y3Rvcigpe1xuXHRcdHRoaXMuZXZlbnRRdWV1ZSA9IEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbWl0IGFuZCBldmVudCBvZiB0eXBlIGV2ZW50VHlwZSB3aXRoIHRoZSBkYXRhIHBhY2tldCBkYXRhXG5cdCAqIEBwYXJhbSBldmVudFR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgb2ZmXG5cdCAqIEBwYXJhbSBkYXRhIEEgQHJlZmVyZW5jZVtNYXBdIG9yIHJlY29yZCBjb250YWluaW5nIGFueSBkYXRhIGFib3V0IHRoZSBldmVudFxuXHQgKi9cblx0ZmlyZUV2ZW50KGV2ZW50VHlwZTogc3RyaW5nLCBkYXRhOiBNYXA8YW55PiB8IFJlY29yZDxzdHJpbmcsIGFueT4gPSBudWxsKTogdm9pZCB7XG5cdFx0dGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KG5ldyBHYW1lRXZlbnQoZXZlbnRUeXBlLCBkYXRhKSk7XG5cdH1cbn0iLCJpbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9RdWV1ZVwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi9HYW1lRXZlbnRcIjtcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi9SZWNlaXZlclwiO1xuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuL0dhbWVFdmVudFR5cGVcIjtcblxuLyoqXG4gKiBUaGUgbWFpbiBldmVudCBzeXN0ZW0gb2YgdGhlIGdhbWUgZW5naW5lLlxuICogRXZlbnRzIGFyZSBzZW50IHRvIHRoZSBFdmVudFF1ZXVlLCB3aGljaCBoYW5kbGVzIGRpc3RyaWJ1dGlvbiB0byBhbnkgc3lzdGVtcyB0aGF0IGFyZSBsaXN0ZW5pbmcgZm9yIHRob3NlIGV2ZW50cy5cbiAqIFRoaXMgYWxsb3dzIGZvciBoYW5kbGluZyBvZiBpbnB1dCB3aXRob3V0IGhhdmluZyBjbGFzc2VzIGRpcmVjdGx5IGhvb2sgaW50byBqYXZhc2NyaXB0IGV2ZW50IGhhbmRsZXMsIFxuICogYW5kIGFsbG93cyBvdGhlcndpc2Ugc2VwYXJhdGUgY2xhc3NlcyB0byBjb21tdW5pY2F0ZSB3aXRoIGVhY2ggb3RoZXIgY2xlYW5seSwgc3VjaCBhcyBhIFBsYXllciBvYmplY3QgXG4gKiByZXF1ZXN0aW5nIGEgc291bmQgYmUgcGxheWVkIGJ5IHRoZSBhdWRpbyBzeXN0ZW0uXG4gKiBcbiAqIFRoZSBkaXN0cmlidXRpb24gb2YgQHJlZmVyZW5jZVtHYW1lRXZlbnRdcyBoYXBwZW5zIGFzIGZvbGxvd3M6XG4gKiBcbiAqIEV2ZW50cyBhcmUgcmVjaWV2ZWQgdGhyb3VnaG91dCBhIGZyYW1lIGFuZCBhcmUgcXVldWVkIHVwIGJ5IHRoZSBFdmVudFF1ZXVlLlxuICogQXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBmcmFtZSwgZXZlbnRzIGFyZSBzZW50IG91dCB0byBhbnkgcmVjZWl2ZXJzIHRoYXQgYXJlIGhvb2tlZCBpbnRvIHRoZSBldmVudCB0eXBlLlxuICogQHJlZmVyZW5jZVtSZWNlaXZlcl1zIGFyZSB0aGVuIGZyZWUgdG8gcHJvY2VzcyBldmVudHMgYXMgdGhleSBzZWUgZml0LlxuICogXG4gKiBPdmVyYWxsLCB0aGUgRXZlbnRRdWV1ZSBjYW4gYmUgY29uc2lkZXJlZCBhcyBzb21ldGhpbmcgc2ltaWxhciB0byBhbiBlbWFpbCBzZXJ2ZXIsXG4gKiBhbmQgdGhlIEByZWZlcmVuY2VbUmVjZWl2ZXJdcyBjYW4gYmUgY29uc2lkZXJlZCBhcyB0aGUgY2xpZW50IGluYm94ZXMuXG4gKiBcbiAqIFNlZSBAbGluayhHYW1lIFByb2dyYW1taW5nIFBhdHRlcm5zKShodHRwczovL2dhbWVwcm9ncmFtbWluZ3BhdHRlcm5zLmNvbS9ldmVudC1xdWV1ZS5odG1sKSBmb3IgbW9yZSBkaXNjdXNzaW9uIG9uIEV2ZW50UXVldWVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50UXVldWUge1xuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBFdmVudFF1ZXVlID0gbnVsbDtcbiAgICBcbiAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50cyB2aXNpYmxlICovXG4gICAgcHJpdmF0ZSByZWFkb25seSBNQVhfU0laRTogbnVtYmVyO1xuICAgIFxuICAgIC8qKiBUaGUgYWN0dWFsIHF1ZXVlIG9mIGV2ZW50cyAqL1xuICAgIHByaXZhdGUgcTogUXVldWU8R2FtZUV2ZW50PjtcbiAgICBcbiAgICAvKiogVGhlIG1hcCBvZiByZWNlaXZlcnMgcmVnaXN0ZXJlZCBmb3IgYW4gZXZlbnQgbmFtZSAqL1xuXHRwcml2YXRlIHJlY2VpdmVyczogTWFwPEFycmF5PFJlY2VpdmVyPj47XG5cbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuTUFYX1NJWkUgPSAxMDA7XG4gICAgICAgIHRoaXMucSA9IG5ldyBRdWV1ZTxHYW1lRXZlbnQ+KHRoaXMuTUFYX1NJWkUpO1xuICAgICAgICB0aGlzLnJlY2VpdmVycyA9IG5ldyBNYXA8QXJyYXk8UmVjZWl2ZXI+PigpO1xuXHR9XG4gICAgXG4gICAgLyoqIFJldHJpZXZlcyB0aGUgaW5zdGFuY2Ugb2YgdGhlIFNpbmdsZXRvbiBFdmVudFF1ZXVlICovXG5cdHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBFdmVudFF1ZXVlIHtcblx0XHRpZih0aGlzLmluc3RhbmNlID09PSBudWxsKXtcblx0XHRcdHRoaXMuaW5zdGFuY2UgPSBuZXcgRXZlbnRRdWV1ZSgpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZTtcblx0fVxuXG4gICAgLyoqIEFkZHMgYW4gZXZlbnQgdG8gdGhlIEV2ZW50UXVldWUuXG4gICAgICogVGhpcyBpcyBleHBvc2VkIHRvIHRoZSByZXN0IG9mIHRoZSBnYW1lIGVuZ2luZSB0aHJvdWdoIHRoZSBAcmVmZXJlbmNlW0VtaXR0ZXJdIGNsYXNzICovXG4gICAgYWRkRXZlbnQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLnEuZW5xdWV1ZShldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzb2NpYXRlcyBhIHJlY2VpdmVyIHdpdGggYSB0eXBlIG9mIGV2ZW50LiBFdmVyeSB0aW1lIHRoaXMgZXZlbnQgYXBwZWFycyBpbiB0aGUgZnV0dXJlLFxuICAgICAqIGl0IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIHJlY2VpdmVyIChhbmQgYW55IG90aGVycyB3YXRjaGluZyB0aGF0IHR5cGUpLlxuICAgICAqIFRoaXMgaXMgZXhwb3NlZCB0byB0aGUgcmVzdCBvZiB0aGUgZ2FtZSBlbmdpbmUgdGhyb3VnaCB0aGUgQHJlZmVyZW5jZVtSZWNlaXZlcl0gY2xhc3NcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXIgVGhlIGV2ZW50IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb3IgdHlwZXMgb2YgZXZlbnRzIHRvIHN1YnNjcmliZSB0b1xuICAgICAqL1xuICAgIHN1YnNjcmliZShyZWNlaXZlcjogUmVjZWl2ZXIsIHR5cGU6IHN0cmluZyB8IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcbiAgICAgICAgaWYodHlwZSBpbnN0YW5jZW9mIEFycmF5KXtcbiAgICAgICAgICAgIC8vIElmIGl0IGlzIGFuIGFycmF5LCBzdWJzY3JpYmUgdG8gYWxsIGV2ZW50IHR5cGVzXG4gICAgICAgICAgICBmb3IobGV0IHQgb2YgdHlwZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcihyZWNlaXZlciwgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZExpc3RlbmVyKHJlY2VpdmVyLCB0eXBlKTtcbiAgICAgICAgfVxuXHR9XG5cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgdGhlIHNwZWNpZmllZCByZWNlaXZlciBmcm9tIGFsbCBldmVudHMsIG9yIGZyb20gd2hhdGV2ZXIgZXZlbnRzIGFyZSBwcm92aWRlZFxuICAgICAqIEBwYXJhbSByZWNlaXZlciBUaGUgcmVjZWl2ZXIgdG8gdW5zdWJzY3JpYmVcbiAgICAgKiBAcGFyYW0ga2V5cyBUaGUgZXZlbnRzIHRvIHVuc3Vic2NyaWJlIGZyb20uIElmIG5vbmUgYXJlIHByb3ZpZGVkLCB1bnN1YnNjcmliZSBmcm9tIGFsbFxuICAgICAqL1xuICAgIHVuc3Vic2NyaWJlKHJlY2VpdmVyOiBSZWNlaXZlciwgLi4uZXZlbnRzOiBBcnJheTxzdHJpbmc+KTogdm9pZCB7XG4gICAgICAgIHRoaXMucmVjZWl2ZXJzLmZvckVhY2goZXZlbnROYW1lID0+IHtcbiAgICAgICAgICAgIC8vIElmIGtleXMgd2VyZSBwcm92aWRlZCwgb25seSBjb250aW51ZSBpZiB0aGlzIGtleSBpcyBvbmUgb2YgdGhlbVxuICAgICAgICAgICAgaWYoZXZlbnRzLmxlbmd0aCA+IDAgJiYgZXZlbnRzLmluZGV4T2YoZXZlbnROYW1lKSA9PT0gLTEpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gRmluZCB0aGUgaW5kZXggb2Ygb3VyIHJlY2VpdmVyIGZvciB0aGlzIGtleVxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5yZWNlaXZlcnMuZ2V0KGV2ZW50TmFtZSkuaW5kZXhPZihyZWNlaXZlcik7XG5cbiAgICAgICAgICAgIC8vIElmIGFuIGluZGV4IHdhcyBmb3VuZCwgcmVtb3ZlIHRoZSByZWNlaXZlclxuICAgICAgICAgICAgaWYoaW5kZXggIT09IC0xKXtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmVycy5nZXQoZXZlbnROYW1lKS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBc3NvY2lhdGUgdGhlIHJlY2VpdmVyIGFuZCB0aGUgdHlwZVxuXHRwcml2YXRlIGFkZExpc3RlbmVyKHJlY2VpdmVyOiBSZWNlaXZlciwgdHlwZTogc3RyaW5nKTogdm9pZCB7XG5cdFx0aWYodGhpcy5yZWNlaXZlcnMuaGFzKHR5cGUpKXtcblx0XHRcdHRoaXMucmVjZWl2ZXJzLmdldCh0eXBlKS5wdXNoKHJlY2VpdmVyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5yZWNlaXZlcnMuYWRkKHR5cGUsIFtyZWNlaXZlcl0pO1xuXHRcdH1cblx0fVxuICAgIFxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB3aGlsZSh0aGlzLnEuaGFzSXRlbXMoKSl7XG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBlYWNoIGV2ZW50XG5cdFx0XHRsZXQgZXZlbnQgPSB0aGlzLnEuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiBhIHJlY2VpdmVyIGhhcyB0aGlzIGV2ZW50IHR5cGUsIHNlbmQgaXQgdGhlIGV2ZW50XG4gICAgICAgICAgICBpZih0aGlzLnJlY2VpdmVycy5oYXMoZXZlbnQudHlwZSkpe1xuICAgICAgICAgICAgICAgIGZvcihsZXQgcmVjZWl2ZXIgb2YgdGhpcy5yZWNlaXZlcnMuZ2V0KGV2ZW50LnR5cGUpKXtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXIucmVjZWl2ZShldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuXHRcdFx0fVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiBhIHJlY2VpdmVyIGlzIHN1YnNjcmliZWQgdG8gYWxsIGV2ZW50cywgc2VuZCBpdCB0aGUgZXZlbnRcbiAgICAgICAgICAgIGlmKHRoaXMucmVjZWl2ZXJzLmhhcyhHYW1lRXZlbnRUeXBlLkFMTCkpe1xuICAgICAgICAgICAgICAgIGZvcihsZXQgcmVjZWl2ZXIgb2YgdGhpcy5yZWNlaXZlcnMuZ2V0KEdhbWVFdmVudFR5cGUuQUxMKSl7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyLnJlY2VpdmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCJcblxuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluLWdhbWUgZXZlbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGUgQHJlZmVyZW5jZVtFdmVudFF1ZXVlXVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lRXZlbnQge1xuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGUgZXZlbnQgKi9cbiAgICBwdWJsaWMgdHlwZTogc3RyaW5nO1xuICAgIC8qKiBUaGUgZGF0YSBjb250YWluZWQgYnkgdGhlIGV2ZW50ICovXG4gICAgcHVibGljIGRhdGE6IE1hcDxhbnk+O1xuICAgIC8qKiBUaGUgdGltZSBvZiB0aGUgZXZlbnQgaW4gbXMgKi9cblx0cHVibGljIHRpbWU6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgR2FtZUV2ZW50LlxuICAgICAqIFRoaXMgaXMgaGFuZGxlZCBpbXBsaWNpdGx5IHRocm91Z2ggdGhlIEByZWZlcmVuY2VbRW1pdHRlcl0gY2xhc3NcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgR2FtZUV2ZW50XG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgY29udGFpbmVkIGJ5IHRoZSBHYW1lRXZlbnRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eXBlOiBzdHJpbmcsIGRhdGE6IE1hcDxhbnk+IHwgUmVjb3JkPHN0cmluZywgYW55PiA9IG51bGwpIHtcbiAgICAgICAgLy8gUGFyc2UgdGhlIGdhbWUgZXZlbnQgZGF0YVxuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IE1hcDxhbnk+KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIShkYXRhIGluc3RhbmNlb2YgTWFwKSl7XG4gICAgICAgICAgICAvLyBkYXRhIGlzIGEgcmF3IG9iamVjdCwgdW5wYWNrXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgTWFwPGFueT4oKTtcbiAgICAgICAgICAgIGZvcihsZXQga2V5IGluIGRhdGEpe1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5hZGQoa2V5LCBkYXRhW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudGltZSA9IERhdGUubm93KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSB0eXBlIG9mIHRoZSBHYW1lRXZlbnRcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIEdhbWVFdmVudCBpcyB0aGUgc3BlY2lmaWVkIHR5cGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1R5cGUodHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIEdhbWVFdmVudCBhcyBhIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEdhbWVFdmVudFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgKyBcIjogQFwiICsgdGhpcy50aW1lO1xuICAgIH1cbn0iLCIvLyBAaWdub3JlUGFnZVxuXG5leHBvcnQgZW51bSBHYW1lRXZlbnRUeXBlIHtcblx0LyoqXG5cdCAqIE1vdXNlIERvd24gZXZlbnQuIEhhcyBkYXRhOiB7cG9zaXRpb246IFZlYzIgLSBNb3VzZSBQb3NpdGlvbn1cblx0ICovXG5cdE1PVVNFX0RPV04gPSBcIm1vdXNlX2Rvd25cIixcblx0LyoqXG5cdCAqIE1vdXNlIFVwIGV2ZW50LiBIYXMgZGF0YToge3Bvc2l0aW9uOiBWZWMyIC0gTW91c2UgUG9zaXRpb259XG5cdCAqL1xuXHRNT1VTRV9VUCA9IFwibW91c2VfdXBcIixcblx0LyoqXG5cdCAqIE1vdXNlIE1vdmUgZXZlbnQuIEhhcyBkYXRhOiB7cG9zaXRpb246IFZlYzIgLSBNb3VzZSBQb3NpdGlvbn1cblx0ICovXG5cdE1PVVNFX01PVkUgPSBcIm1vdXNlX21vdmVcIixcblxuXHQvKipcblx0ICogS2V5IERvd24gZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmcgLSBUaGUga2V5IHRoYXQgaXMgZG93bn1cblx0ICovXG5cdEtFWV9ET1dOID0gXCJrZXlfZG93blwiLFxuXG5cdC8qKlxuXHQgKiBLZXkgVXAgZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmcgLSBUaGUga2V5IHRoYXQgaXMgdXB9XG5cdCAqL1xuXHRLRVlfVVAgPSBcImtleV91cFwiLFxuXG5cdC8qKlxuXHQgKiBDYW52YXMgQmx1ciBldmVudC4gSGFzIGRhdGE6IHt9XG5cdCAqL1xuXHRDQU5WQVNfQkxVUiA9IFwiY2FudmFzX2JsdXJcIixcblxuXHQvKipcblx0ICogTW91c2Ugd2hlZWwgdXAgZXZlbnQuIEhhcyBkYXRhOiB7fVxuXHQgKi9cblx0V0hFRUxfVVAgPSBcIndoZWVsX3VwXCIsXG5cblx0LyoqXG5cdCAqIE1vdXNlIHdoZWVsIGRvd24gZXZlbnQuIEhhcyBkYXRhOiB7fVxuXHQgKi9cblx0V0hFRUxfRE9XTiA9IFwid2hlZWxfZG93blwiLFxuXG5cdC8qKlxuXHQgKiBTdGFydCBSZWNvcmRpbmcgZXZlbnQuIEhhcyBkYXRhOiB7fVxuXHQgKi9cblx0U1RBUlRfUkVDT1JESU5HID0gXCJzdGFydF9yZWNvcmRpbmdcIixcblxuXHQvKipcblx0ICogU3RvcCBSZWNvcmRpbmcgZXZlbnQuIEhhcyBkYXRhOiB7fVxuXHQgKi9cblx0U1RPUF9SRUNPUkRJTkcgPSBcInN0b3BfcmVjb3JkaW5nXCIsXG5cdFxuXHQvKipcblx0ICogUGxheSBSZWNvcmRpbmcgZXZlbnQuIEhhcyBkYXRhOiB7fVxuXHQgKi9cblx0UExBWV9SRUNPUkRJTkcgPSBcInBsYXlfcmVjb3JkaW5nXCIsXG5cblx0LyoqXG5cdCAqIFBsYXkgU291bmQgZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmcsIGxvb3A6IGJvb2xlYW4sIGhvbGRSZWZlcmVuY2U6IGJvb2xlYW4gfVxuXHQgKi9cblx0UExBWV9TT1VORCA9IFwicGxheV9zb3VuZFwiLFxuXG5cdC8qKlxuXHQgKiBQbGF5IFNvdW5kIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nfVxuXHQgKi9cblx0U1RPUF9TT1VORCA9IFwic3RvcF9zb3VuZFwiLFxuXG5cdC8qKlxuXHQgKiBQbGF5IFNvdW5kIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nLCBsb29wOiBib29sZWFuLCBob2xkUmVmZXJlbmNlOiBib29sZWFuLCBjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlIH1cblx0ICovXG4gXHRQTEFZX1NGWCA9IFwicGxheV9zZnhcIixcblxuIFx0LyoqXG5cdCAqIFBsYXkgU291bmQgZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmcsIGxvb3A6IGJvb2xlYW4sIGhvbGRSZWZlcmVuY2U6IGJvb2xlYW4gfVxuXHQgKi9cbiAgXHRQTEFZX01VU0lDID0gXCJwbGF5X211c2ljXCIsXG5cblx0LyoqXG5cdCAqIE11dGUgYXVkaW8gY2hhbm5lbCBldmVudC4gSGFzIGRhdGE6IHtjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlfVxuXHQgKi9cblx0TVVURV9DSEFOTkVMID0gXCJtdXRlX2NoYW5uZWxcIixcblxuXHQvKipcblx0ICogVW5tdXRlIGF1ZGlvIGNoYW5uZWwgZXZlbnQuIEhhcyBkYXRhOiB7Y2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZX1cblx0ICovXG5cdFVOTVVURV9DSEFOTkVMID0gXCJ1bm11dGVfY2hhbm5lbFwiLFxuXG5cdC8qKlxuXHQgKiBFbmNvbXBhc3NlcyBhbGwgZXZlbnQgdHlwZXMuIFVzZWQgZm9yIHJlY2VpdmVycyBvbmx5LlxuXHQgKi9cblx0QUxMID0gXCJhbGxcIixcbn0iLCJpbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9RdWV1ZVwiO1xuaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4vRXZlbnRRdWV1ZVwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi9HYW1lRXZlbnRcIjtcblxuLyoqXG4gKiBSZWNlaXZlcyBzdWJzY3JpYmVkIGV2ZW50cyBmcm9tIHRoZSBFdmVudFF1ZXVlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWNlaXZlciB7XG5cdC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzIHRoaXMgUmVjZWl2ZXIgY2FuIGhvbGQgYXQgb25lIHRpbWUgKi9cblx0cmVhZG9ubHkgTUFYX1NJWkU6IG51bWJlcjtcblxuXHQvKiogVGhlIGluYm94IG9mIHRoZSBSZWNlaXZlciAqL1xuXHRwcml2YXRlIHE6IFF1ZXVlPEdhbWVFdmVudD47XG5cblx0LyoqIENyZWF0ZXMgYSBuZXcgUmVjZWl2ZXIgKi9cblx0Y29uc3RydWN0b3IoKXtcblx0XHR0aGlzLk1BWF9TSVpFID0gMTAwO1xuICAgICAgICB0aGlzLnEgPSBuZXcgUXVldWUodGhpcy5NQVhfU0laRSk7XG5cdH1cblxuXHRkZXN0cm95KCl7XG5cdFx0RXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpLnVuc3Vic2NyaWJlKHRoaXMpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQWRkcyB0aGVzZSB0eXBlcyBvZiBldmVudHMgdG8gdGhpcyByZWNlaXZlcidzIHF1ZXVlIGV2ZXJ5IHVwZGF0ZS5cblx0ICogQHBhcmFtIGV2ZW50VHlwZXMgVGhlIHR5cGVzIG9mIGV2ZW50cyB0aGlzIHJlY2VpdmVyIHdpbGwgYmUgc3Vic2NyaWJlZCB0b1xuXHQgKi9cblx0c3Vic2NyaWJlKGV2ZW50VHlwZXM6IHN0cmluZyB8IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcblx0XHRFdmVudFF1ZXVlLmdldEluc3RhbmNlKCkuc3Vic2NyaWJlKHRoaXMsIGV2ZW50VHlwZXMpO1xuXHRcdHRoaXMucS5jbGVhcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gZXZlbnQgdG8gdGhlIHF1ZXVlIG9mIHRoaXMgcmVjaWV2ZXIuIFRoaXMgaXMgdXNlZCBieSB0aGUgQHJlZmVyZW5jZVtFdmVudFF1ZXVlXSB0byBkaXN0cmlidXRlIGV2ZW50c1xuXHQgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHJlY2VpdmVcblx0ICovXG5cdHJlY2VpdmUoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xuXHRcdHRyeXtcblx0XHR0aGlzLnEuZW5xdWV1ZShldmVudCk7XG5cdFx0fSBjYXRjaChlKXtcblx0XHRcdGNvbnNvbGUud2FybihcIlJlY2VpdmVyIG92ZXJmbG93IGZvciBldmVudCBcIiArIGV2ZW50LnRvU3RyaW5nKCkpO1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0cmlldmVzIHRoZSBuZXh0IGV2ZW50IGZyb20gdGhlIHJlY2VpdmVyJ3MgcXVldWVcblx0ICogQHJldHVybnMgVGhlIG5leHQgR2FtZUV2ZW50XG5cdCAqL1xuXHRnZXROZXh0RXZlbnQoKTogR2FtZUV2ZW50IHtcblx0XHRyZXR1cm4gdGhpcy5xLmRlcXVldWUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMb29rcyBhdCB0aGUgbmV4dCBldmVudCBpbiB0aGUgcmVjZWl2ZXIncyBxdWV1ZSwgYnV0IGRvZXNuJ3QgcmVtb3ZlIGl0IGZyb20gdGhlIHF1ZXVlXG5cdCAqIEByZXR1cm5zIFRoZSBuZXh0IEdhbWVFdmVudFxuXHQgKi9cblx0cGVla05leHRFdmVudCgpOiBHYW1lRXZlbnQge1xuXHRcdHJldHVybiB0aGlzLnEucGVla05leHQoKVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVjZWl2ZXIgaGFzIGFueSBldmVudHMgaW4gaXRzIHF1ZXVlXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHJlY2VpdmVyIGhhcyBhbm90aGVyIGV2ZW50LCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdGhhc05leHRFdmVudCgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5xLmhhc0l0ZW1zKCk7XG5cdH1cblxuXHQvKipcblx0ICogSWdub3JlIGFsbCBldmVudHMgdGhpcyBmcmFtZVxuXHQgKi9cblx0aWdub3JlRXZlbnRzKCk6IHZvaWQge1xuXHRcdHRoaXMucS5jbGVhcigpO1xuXHR9XG59IiwiaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4uL0V2ZW50cy9FdmVudFF1ZXVlXCI7XG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4uL1NjZW5lR3JhcGgvVmlld3BvcnRcIjtcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFR5cGVcIjtcblxuLyoqXG4gKiBSZWNlaXZlcyBpbnB1dCBldmVudHMgZnJvbSB0aGUgQHJlZmVyZW5jZVtFdmVudFF1ZXVlXSBhbmQgYWxsb3dzIGZvciBlYXN5IGFjY2VzcyBvZiBpbmZvcm1hdGlvbiBhYm91dCBpbnB1dCBieSBvdGhlciBzeXN0ZW1zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0IHtcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VQcmVzc2VkOiBib29sZWFuO1xuXHRwcml2YXRlIHN0YXRpYyBtb3VzZUp1c3RQcmVzc2VkOiBib29sZWFuO1xuXHRwcml2YXRlIHN0YXRpYyBtb3VzZUJ1dHRvblByZXNzZWQ6IG51bWJlcjtcblxuXHRwcml2YXRlIHN0YXRpYyBrZXlKdXN0UHJlc3NlZDogTWFwPGJvb2xlYW4+O1xuXHRwcml2YXRlIHN0YXRpYyBrZXlQcmVzc2VkOiBNYXA8Ym9vbGVhbj47XG5cblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VQb3NpdGlvbjogVmVjMjtcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VQcmVzc1Bvc2l0aW9uOiBWZWMyO1xuXG5cdHByaXZhdGUgc3RhdGljIHNjcm9sbERpcmVjdGlvbjogbnVtYmVyO1xuXHRwcml2YXRlIHN0YXRpYyBqdXN0U2Nyb2xsZWQ6IGJvb2xlYW47XG5cblx0cHJpdmF0ZSBzdGF0aWMgZXZlbnRRdWV1ZTogRXZlbnRRdWV1ZTtcblx0cHJpdmF0ZSBzdGF0aWMgcmVjZWl2ZXI6IFJlY2VpdmVyO1xuXHRwcml2YXRlIHN0YXRpYyB2aWV3cG9ydDogVmlld3BvcnQ7XG5cblx0cHJpdmF0ZSBzdGF0aWMga2V5TWFwOiBNYXA8QXJyYXk8c3RyaW5nPj47XG5cblx0cHJpdmF0ZSBzdGF0aWMga2V5c0Rpc2FibGVkOiBib29sZWFuO1xuXHRwcml2YXRlIHN0YXRpYyBtb3VzZURpc2FibGVkOiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgSW5wdXQgb2JqZWN0XG5cdCAqIEBwYXJhbSB2aWV3cG9ydCBBIHJlZmVyZW5jZSB0byB0aGUgdmlld3BvcnQgb2YgdGhlIGdhbWVcblx0ICovXG5cdHN0YXRpYyBpbml0aWFsaXplKHZpZXdwb3J0OiBWaWV3cG9ydCwga2V5TWFwOiBBcnJheTxSZWNvcmQ8c3RyaW5nLCBhbnk+Pikge1xuXHRcdElucHV0LnZpZXdwb3J0ID0gdmlld3BvcnQ7XG5cdFx0SW5wdXQubW91c2VQcmVzc2VkID0gZmFsc2U7XG5cdFx0SW5wdXQubW91c2VKdXN0UHJlc3NlZCA9IGZhbHNlO1xuXHRcdElucHV0LnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XG5cdFx0SW5wdXQua2V5SnVzdFByZXNzZWQgPSBuZXcgTWFwPGJvb2xlYW4+KCk7XG5cdFx0SW5wdXQua2V5UHJlc3NlZCA9IG5ldyBNYXA8Ym9vbGVhbj4oKTtcblx0XHRJbnB1dC5tb3VzZVBvc2l0aW9uID0gbmV3IFZlYzIoMCwgMCk7XG5cdFx0SW5wdXQubW91c2VQcmVzc1Bvc2l0aW9uID0gbmV3IFZlYzIoMCwgMCk7XG5cdFx0SW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gMDtcblx0XHRJbnB1dC5qdXN0U2Nyb2xsZWQgPSBmYWxzZTtcblx0XHRJbnB1dC5rZXlzRGlzYWJsZWQgPSBmYWxzZTtcblx0XHRJbnB1dC5tb3VzZURpc2FibGVkID0gZmFsc2U7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBrZXltYXBcblx0XHRJbnB1dC5rZXlNYXAgPSBuZXcgTWFwKCk7XG5cblx0XHQvLyBBZGQgYWxsIGtleXMgdG8gdGhlIGtleW1hcFxuXHRcdGZvciAobGV0IGVudHJ5IGluIGtleU1hcCkge1xuXHRcdFx0bGV0IG5hbWUgPSBrZXlNYXBbZW50cnldLm5hbWU7XG5cdFx0XHRsZXQga2V5cyA9IGtleU1hcFtlbnRyeV0ua2V5cztcblx0XHRcdElucHV0LmtleU1hcC5hZGQobmFtZSwga2V5cyk7XG5cdFx0fVxuXG5cdFx0SW5wdXQuZXZlbnRRdWV1ZSA9IEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKTtcblx0XHQvLyBTdWJzY3JpYmUgdG8gYWxsIGlucHV0IGV2ZW50c1xuXHRcdElucHV0LmV2ZW50UXVldWUuc3Vic2NyaWJlKElucHV0LnJlY2VpdmVyLCBbR2FtZUV2ZW50VHlwZS5NT1VTRV9ET1dOLCBHYW1lRXZlbnRUeXBlLk1PVVNFX1VQLCBHYW1lRXZlbnRUeXBlLk1PVVNFX01PVkUsXG5cdFx0R2FtZUV2ZW50VHlwZS5LRVlfRE9XTiwgR2FtZUV2ZW50VHlwZS5LRVlfVVAsIEdhbWVFdmVudFR5cGUuQ0FOVkFTX0JMVVIsIEdhbWVFdmVudFR5cGUuV0hFRUxfVVAsIEdhbWVFdmVudFR5cGUuV0hFRUxfRE9XTl0pO1xuXHR9XG5cblx0c3RhdGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuXHRcdC8vIFJlc2V0IHRoZSBqdXN0UHJlc3NlZCB2YWx1ZXMgdG8gZmFsc2Vcblx0XHRJbnB1dC5tb3VzZUp1c3RQcmVzc2VkID0gZmFsc2U7XG5cdFx0SW5wdXQua2V5SnVzdFByZXNzZWQuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IElucHV0LmtleUp1c3RQcmVzc2VkLnNldChrZXksIGZhbHNlKSk7XG5cdFx0SW5wdXQuanVzdFNjcm9sbGVkID0gZmFsc2U7XG5cdFx0SW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gMDtcblxuXHRcdHdoaWxlIChJbnB1dC5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSkge1xuXHRcdFx0bGV0IGV2ZW50ID0gSW5wdXQucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XG5cblx0XHRcdC8vIEhhbmRsZSBlYWNoIGV2ZW50IHR5cGVcblx0XHRcdGlmIChldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLk1PVVNFX0RPV04pIHtcblx0XHRcdFx0SW5wdXQubW91c2VKdXN0UHJlc3NlZCA9IHRydWU7XG5cdFx0XHRcdElucHV0Lm1vdXNlUHJlc3NlZCA9IHRydWU7XG5cdFx0XHRcdElucHV0Lm1vdXNlUHJlc3NQb3NpdGlvbiA9IGV2ZW50LmRhdGEuZ2V0KFwicG9zaXRpb25cIik7XG5cdFx0XHRcdElucHV0Lm1vdXNlQnV0dG9uUHJlc3NlZCA9IGV2ZW50LmRhdGEuZ2V0KFwiYnV0dG9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5NT1VTRV9VUCkge1xuXHRcdFx0XHRJbnB1dC5tb3VzZVByZXNzZWQgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuTU9VU0VfTU9WRSkge1xuXHRcdFx0XHRJbnB1dC5tb3VzZVBvc2l0aW9uID0gZXZlbnQuZGF0YS5nZXQoXCJwb3NpdGlvblwiKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuS0VZX0RPV04pIHtcblx0XHRcdFx0bGV0IGtleSA9IGV2ZW50LmRhdGEuZ2V0KFwia2V5XCIpO1xuXHRcdFx0XHQvLyBIYW5kbGUgc3BhY2UgYmFyXG5cdFx0XHRcdGlmIChrZXkgPT09IFwiIFwiKSB7XG5cdFx0XHRcdFx0a2V5ID0gXCJzcGFjZVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghSW5wdXQua2V5UHJlc3NlZC5nZXQoa2V5KSkge1xuXHRcdFx0XHRcdElucHV0LmtleUp1c3RQcmVzc2VkLnNldChrZXksIHRydWUpO1xuXHRcdFx0XHRcdElucHV0LmtleVByZXNzZWQuc2V0KGtleSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuS0VZX1VQKSB7XG5cdFx0XHRcdGxldCBrZXkgPSBldmVudC5kYXRhLmdldChcImtleVwiKTtcblx0XHRcdFx0Ly8gSGFuZGxlIHNwYWNlIGJhclxuXHRcdFx0XHRpZiAoa2V5ID09PSBcIiBcIikge1xuXHRcdFx0XHRcdGtleSA9IFwic3BhY2VcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRJbnB1dC5rZXlQcmVzc2VkLnNldChrZXksIGZhbHNlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuQ0FOVkFTX0JMVVIpIHtcblx0XHRcdFx0SW5wdXQuY2xlYXJLZXlQcmVzc2VzKClcblx0XHRcdH1cblxuXHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuV0hFRUxfVVApIHtcblx0XHRcdFx0SW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gLTE7XG5cdFx0XHRcdElucHV0Lmp1c3RTY3JvbGxlZCA9IHRydWU7XG5cdFx0XHR9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuV0hFRUxfRE9XTikge1xuXHRcdFx0XHRJbnB1dC5zY3JvbGxEaXJlY3Rpb24gPSAxO1xuXHRcdFx0XHRJbnB1dC5qdXN0U2Nyb2xsZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGNsZWFyS2V5UHJlc3NlcygpOiB2b2lkIHtcblx0XHRJbnB1dC5rZXlKdXN0UHJlc3NlZC5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4gSW5wdXQua2V5SnVzdFByZXNzZWQuc2V0KGtleSwgZmFsc2UpKTtcblx0XHRJbnB1dC5rZXlQcmVzc2VkLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiBJbnB1dC5rZXlQcmVzc2VkLnNldChrZXksIGZhbHNlKSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIGtleSB3YXMgbmV3bHkgcHJlc3NlZCBJbnB1dCBmcmFtZS5cblx0ICogSWYgdGhlIGtleSBpcyBzdGlsbCBwcmVzc2VkIGZyb20gbGFzdCBmcmFtZSBhbmQgd2Fzbid0IHJlLXByZXNzZWQsIElucHV0IHdpbGwgcmV0dXJuIGZhbHNlLlxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXlcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUga2V5IHdhcyBqdXN0IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0c3RhdGljIGlzS2V5SnVzdFByZXNzZWQoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcblx0XHRpZiAoSW5wdXQua2V5c0Rpc2FibGVkKSByZXR1cm4gZmFsc2U7XG5cblx0XHRpZiAoSW5wdXQua2V5SnVzdFByZXNzZWQuaGFzKGtleSkpIHtcblx0XHRcdHJldHVybiBJbnB1dC5rZXlKdXN0UHJlc3NlZC5nZXQoa2V5KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIG9mIHRoZSBrZXlzIHRoYXQgYXJlIG5ld2x5IHByZXNzZWQgSW5wdXQgZnJhbWUuXG5cdCAqIElmIGEga2V5IGlzIHN0aWxsIHByZXNzZWQgZnJvbSBsYXN0IGZyYW1lIGFuZCB3YXNuJ3QgcmUtcHJlc3NlZCwgaXQgd2lsbCBub3QgYmUgaW4gSW5wdXQgbGlzdC5cblx0ICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIG9mIHRoZSBuZXdseSBwcmVzc2VkIGtleXMuXG5cdCAqL1xuXHRzdGF0aWMgZ2V0S2V5c0p1c3RQcmVzc2VkKCk6IEFycmF5PHN0cmluZz4ge1xuXHRcdGlmIChJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBbXTtcblxuXHRcdGxldCBrZXlzID0gQXJyYXk8c3RyaW5nPigpO1xuXHRcdElucHV0LmtleUp1c3RQcmVzc2VkLmZvckVhY2goa2V5ID0+IHtcblx0XHRcdGlmIChJbnB1dC5rZXlKdXN0UHJlc3NlZC5nZXQoa2V5KSkge1xuXHRcdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4ga2V5cztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEga2V5IGlzIGJlaW5nIHByZXNzZWQuXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleVxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBrZXkgaXMgY3VycmVudGx5IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0c3RhdGljIGlzS2V5UHJlc3NlZChrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRcdGlmIChJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBmYWxzZTtcblxuXHRcdGlmIChJbnB1dC5rZXlQcmVzc2VkLmhhcyhrZXkpKSB7XG5cdFx0XHRyZXR1cm4gSW5wdXQua2V5UHJlc3NlZC5nZXQoa2V5KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENoYW5nZXMgdGhlIGJpbmRpbmcgb2YgYW4gaW5wdXQgbmFtZSB0byBrZXlzXG5cdCAqIEBwYXJhbSBpbnB1dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGlucHV0XG5cdCAqIEBwYXJhbSBrZXlzIFRoZSBjb3JyZXNwb25kaW5nIGtleXNcblx0ICovXG5cdHN0YXRpYyBjaGFuZ2VLZXlCaW5kaW5nKGlucHV0TmFtZTogc3RyaW5nLCBrZXlzOiBBcnJheTxzdHJpbmc+KTogdm9pZCB7XG5cdFx0SW5wdXQua2V5TWFwLnNldChpbnB1dE5hbWUsIGtleXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFycyBhbGwga2V5IGJpbmRpbmdzXG5cdCAqL1xuXHRzdGF0aWMgY2xlYXJBbGxLZXlCaW5kaW5ncygpOiB2b2lkIHtcblx0XHRJbnB1dC5rZXlNYXAuY2xlYXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIGlucHV0IHdhcyBqdXN0IHByZXNzZWQgdGhpcyBmcmFtZVxuXHQgKiBAcGFyYW0gaW5wdXROYW1lIFRoZSBuYW1lIG9mIHRoZSBpbnB1dFxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBpbnB1dCB3YXMganVzdCBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdHN0YXRpYyBpc0p1c3RQcmVzc2VkKGlucHV0TmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG5cdFx0aWYgKElucHV0LmtleXNEaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0aWYgKElucHV0LmtleU1hcC5oYXMoaW5wdXROYW1lKSkge1xuXHRcdFx0Y29uc3Qga2V5cyA9IElucHV0LmtleU1hcC5nZXQoaW5wdXROYW1lKTtcblx0XHRcdGxldCBqdXN0UHJlc3NlZCA9IGZhbHNlO1xuXG5cdFx0XHRmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuXHRcdFx0XHRqdXN0UHJlc3NlZCA9IGp1c3RQcmVzc2VkIHx8IElucHV0LmlzS2V5SnVzdFByZXNzZWQoa2V5KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGp1c3RQcmVzc2VkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gaW5wdXQgaXMgY3VycmVudGx5IHByZXNzZWRcblx0ICogQHBhcmFtIGlucHV0TmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5wdXRcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgaW5wdXQgaXMgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRzdGF0aWMgaXNQcmVzc2VkKGlucHV0TmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG5cdFx0aWYgKElucHV0LmtleXNEaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0aWYgKElucHV0LmtleU1hcC5oYXMoaW5wdXROYW1lKSkge1xuXHRcdFx0Y29uc3Qga2V5cyA9IElucHV0LmtleU1hcC5nZXQoaW5wdXROYW1lKTtcblx0XHRcdGxldCBwcmVzc2VkID0gZmFsc2U7XG5cblx0XHRcdGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG5cdFx0XHRcdHByZXNzZWQgPSBwcmVzc2VkIHx8IElucHV0LmlzS2V5UHJlc3NlZChrZXkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJlc3NlZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXHQvKipcblx0ICogXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1vdXNlIHdhcyBuZXdseSBwcmVzc2VkIElucHV0IGZyYW1lLlxuXHQgKiBAcGFyYW0gbW91c2VCdXR0b24gT3B0aW9uYWxseSBzcGVjaWZ5IHdoaWNoIG1vdXNlIGNsaWNrIHlvdSB3YW50IHRvIGtub3cgd2FzIHByZXNzZWQuIFxuXHQgKiAwIGZvciBsZWZ0IGNsaWNrLCAxIGZvciBtaWRkbGUgY2xpY2ssIDIgZm9yIHJpZ2h0IGNsaWNrLlxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBtb3VzZSB3YXMganVzdCBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdHN0YXRpYyBpc01vdXNlSnVzdFByZXNzZWQobW91c2VCdXR0b24/OiBudW1iZXIpOiBib29sZWFuIHtcblx0XHRpZiAobW91c2VCdXR0b24gfHwgbW91c2VCdXR0b24gPT09IDApIHtcblx0XHRcdHJldHVybiBJbnB1dC5tb3VzZUp1c3RQcmVzc2VkICYmICFJbnB1dC5tb3VzZURpc2FibGVkICYmIG1vdXNlQnV0dG9uID09IHRoaXMubW91c2VCdXR0b25QcmVzc2VkO1xuXHRcdH1cblx0XHRyZXR1cm4gSW5wdXQubW91c2VKdXN0UHJlc3NlZCAmJiAhSW5wdXQubW91c2VEaXNhYmxlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtb3VzZSBpcyBjdXJyZW50bHkgcHJlc3NlZFxuXHQgKiBAcGFyYW0gbW91c2VCdXR0b24gT3B0aW9uYWxseSBzcGVjaWZ5IHdoaWNoIG1vdXNlIGNsaWNrIHlvdSB3YW50IHRvIGtub3cgd2FzIHByZXNzZWQuIFxuXHQgKiAwIGZvciBsZWZ0IGNsaWNrLCAxIGZvciBtaWRkbGUgY2xpY2ssIDIgZm9yIHJpZ2h0IGNsaWNrLlxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBtb3VzZSBpcyBjdXJyZW50bHkgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRzdGF0aWMgaXNNb3VzZVByZXNzZWQobW91c2VCdXR0b24/OiBudW1iZXIpOiBib29sZWFuIHtcblx0XHRpZiAobW91c2VCdXR0b24pIHtcblx0XHRcdHJldHVybiBJbnB1dC5tb3VzZVByZXNzZWQgJiYgIUlucHV0Lm1vdXNlRGlzYWJsZWQgJiYgbW91c2VCdXR0b24gPT0gdGhpcy5tb3VzZUJ1dHRvblByZXNzZWQ7XG5cdFx0fVxuXHRcdHJldHVybiBJbnB1dC5tb3VzZVByZXNzZWQgJiYgIUlucHV0Lm1vdXNlRGlzYWJsZWQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIHRoZSB1c2VyIHNjcm9sbGVkIG9yIG5vdFxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB1c2VyIGp1c3Qgc2Nyb2xsZWQgSW5wdXQgZnJhbWUsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0c3RhdGljIGRpZEp1c3RTY3JvbGwoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIElucHV0Lmp1c3RTY3JvbGxlZCAmJiAhSW5wdXQubW91c2VEaXNhYmxlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNjcm9sbFxuXHQgKiBAcmV0dXJucyAtMSBpZiB0aGUgdXNlciBzY3JvbGxlZCB1cCwgMSBpZiB0aGV5IHNjcm9sbGVkIGRvd25cblx0ICovXG5cdHN0YXRpYyBnZXRTY3JvbGxEaXJlY3Rpb24oKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gSW5wdXQuc2Nyb2xsRGlyZWN0aW9uO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwbGF5ZXIncyBtb3VzZVxuXHQgKiBAcmV0dXJucyBUaGUgbW91c2UgcG9zaXRpb24gc3RvcmVkIGFzIGEgVmVjMlxuXHQgKi9cblx0c3RhdGljIGdldE1vdXNlUG9zaXRpb24oKTogVmVjMiB7XG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlUG9zaXRpb24uc2NhbGVkKDEgLyB0aGlzLnZpZXdwb3J0LmdldFpvb21MZXZlbCgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcGxheWVyJ3MgbW91c2UgaW4gdGhlIGdhbWUgd29ybGQsXG5cdCAqIHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIHNjcm9sbGluZyBvZiB0aGUgdmlld3BvcnRcblx0ICogQHJldHVybnMgVGhlIG1vdXNlIHBvc2l0aW9uIHN0b3JlZCBhcyBhIFZlYzJcblx0ICovXG5cdHN0YXRpYyBnZXRHbG9iYWxNb3VzZVBvc2l0aW9uKCk6IFZlYzIge1xuXHRcdHJldHVybiBJbnB1dC5tb3VzZVBvc2l0aW9uLmNsb25lKCkuc2NhbGUoMSAvIHRoaXMudmlld3BvcnQuZ2V0Wm9vbUxldmVsKCkpLmFkZChJbnB1dC52aWV3cG9ydC5nZXRPcmlnaW4oKSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3QgbW91c2UgcHJlc3Ncblx0ICogQHJldHVybnMgVGhlIG1vdXNlIHBvc2l0aW9uIHN0b3JlZCBhcyBhIFZlYzJcblx0ICovXG5cdHN0YXRpYyBnZXRNb3VzZVByZXNzUG9zaXRpb24oKTogVmVjMiB7XG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlUHJlc3NQb3NpdGlvbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGFzdCBtb3VzZSBwcmVzcyBpbiB0aGUgZ2FtZSB3b3JsZCxcblx0ICogdGFraW5nIGludG8gY29uc2lkZXJhdGlvbiB0aGUgc2Nyb2xsaW5nIG9mIHRoZSB2aWV3cG9ydFxuXHQgKiBAcmV0dXJucyBUaGUgbW91c2UgcG9zaXRpb24gc3RvcmVkIGFzIGEgVmVjMlxuXHQgKi9cblx0c3RhdGljIGdldEdsb2JhbE1vdXNlUHJlc3NQb3NpdGlvbigpOiBWZWMyIHtcblx0XHRyZXR1cm4gSW5wdXQubW91c2VQcmVzc1Bvc2l0aW9uLmNsb25lKCkuYWRkKElucHV0LnZpZXdwb3J0LmdldE9yaWdpbigpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlcyBhbGwga2V5cHJlc3MgYW5kIG1vdXNlIGNsaWNrIGlucHV0c1xuXHQgKi9cblx0c3RhdGljIGRpc2FibGVJbnB1dCgpOiB2b2lkIHtcblx0XHRJbnB1dC5rZXlzRGlzYWJsZWQgPSB0cnVlO1xuXHRcdElucHV0Lm1vdXNlRGlzYWJsZWQgPSB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgYWxsIGtleXByZXNzIGFuZCBtb3VzZSBjbGljayBpbnB1dHNcblx0ICovXG5cdHN0YXRpYyBlbmFibGVJbnB1dCgpOiB2b2lkIHtcblx0XHRJbnB1dC5rZXlzRGlzYWJsZWQgPSBmYWxzZTtcblx0XHRJbnB1dC5tb3VzZURpc2FibGVkID0gZmFsc2U7XG5cdH1cbn0iLCJpbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi4vRXZlbnRzL0V2ZW50UXVldWVcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50VHlwZVwiO1xuXG4vKipcbiAqIEhhbmRsZXMgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSB3ZWIgYnJvd3NlciB0byByZWNlaXZlIGFzeW5jaHJvbm91cyBldmVudHMgYW5kIHNlbmQgdGhlbSB0byB0aGUgQHJlZmVyZW5jZVtFdmVudFF1ZXVlXVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dEhhbmRsZXIge1xuXHRwcml2YXRlIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XG4gICAgIFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5wdXRIYW5kbGVyXG4gICAgICogQHBhcmFtIGNhbnZhcyBUaGUgZ2FtZSBjYW52YXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KXtcblx0XHR0aGlzLmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XG5cdFx0XG4gICAgICAgIGNhbnZhcy5vbm1vdXNlZG93biA9IChldmVudCkgPT4gdGhpcy5oYW5kbGVNb3VzZURvd24oZXZlbnQsIGNhbnZhcyk7XG4gICAgICAgIGNhbnZhcy5vbm1vdXNldXAgPSAoZXZlbnQpID0+IHRoaXMuaGFuZGxlTW91c2VVcChldmVudCwgY2FudmFzKTtcbiAgICAgICAgY2FudmFzLm9uY29udGV4dG1lbnUgPSB0aGlzLmhhbmRsZUNvbnRleHRNZW51O1xuICAgICAgICBjYW52YXMub25tb3VzZW1vdmUgPSAoZXZlbnQpID0+IHRoaXMuaGFuZGxlTW91c2VNb3ZlKGV2ZW50LCBjYW52YXMpO1xuICAgICAgICBkb2N1bWVudC5vbmtleWRvd24gPSB0aGlzLmhhbmRsZUtleURvd247XG4gICAgICAgIGRvY3VtZW50Lm9ua2V5dXAgPSB0aGlzLmhhbmRsZUtleVVwO1xuICAgICAgICBkb2N1bWVudC5vbmJsdXIgPSB0aGlzLmhhbmRsZUJsdXI7XG4gICAgICAgIGRvY3VtZW50Lm9uY29udGV4dG1lbnUgPSB0aGlzLmhhbmRsZUJsdXI7XG4gICAgICAgIGRvY3VtZW50Lm9ud2hlZWwgPSB0aGlzLmhhbmRsZVdoZWVsO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlTW91c2VEb3duID0gKGV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCA9PiB7XG5cdFx0bGV0IHBvcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldmVudCwgY2FudmFzKTtcbiAgICAgICAgbGV0IGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcbiAgICAgICAgbGV0IGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5NT1VTRV9ET1dOLCB7cG9zaXRpb246IHBvcywgYnV0dG9uOiBidXR0b259KTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVNb3VzZVVwID0gKGV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuTU9VU0VfVVAsIHtwb3NpdGlvbjogcG9zfSk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlTW91c2VNb3ZlID0gKGV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuTU9VU0VfTU9WRSwge3Bvc2l0aW9uOiBwb3N9KTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVLZXlEb3duID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGxldCBrZXkgPSB0aGlzLmdldEtleShldmVudCk7XG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuS0VZX0RPV04sIHtrZXk6IGtleX0pO1xuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUtleVVwID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGxldCBrZXkgPSB0aGlzLmdldEtleShldmVudCk7XG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuS0VZX1VQLCB7a2V5OiBrZXl9KTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVCbHVyID0gKGV2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLkNBTlZBU19CTFVSLCB7fSk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlQ29udGV4dE1lbnUgPSAoZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlV2hlZWwgPSAoZXZlbnQ6IFdoZWVsRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIFxuICAgICAgICBsZXQgZ2FtZUV2ZW50OiBHYW1lRXZlbnQ7XG4gICAgICAgIGlmKGV2ZW50LmRlbHRhWSA8IDApe1xuICAgICAgICAgICAgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLldIRUVMX1VQLCB7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuV0hFRUxfRE9XTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0S2V5KGtleUV2ZW50OiBLZXlib2FyZEV2ZW50KXtcbiAgICAgICAgcmV0dXJuIGtleUV2ZW50LmtleS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0TW91c2VQb3NpdGlvbihtb3VzZUV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogVmVjMiB7XG4gICAgICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgeCA9IG1vdXNlRXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgICAgbGV0IHkgPSBtb3VzZUV2ZW50LmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHgsIHkpO1xuICAgIH1cbn0iLCJpbXBvcnQge30gZnJvbSBcIi4uLy4uL2luZGV4XCI7ICAvLyBUaGlzIGltcG9ydCBhbGxvd3MgdXMgdG8gbW9kaWZ5IHRoZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgdG8gYWRkIGV4dHJhIGZ1bmN0aW9uYWxpdHlcbi8vIEBpZ25vcmVQYWdlXG5cbi8qKlxuICogU2V0cyB1cCB0aGUgZW52aXJvbm1lbnQgb2YgdGhlIGdhbWUgZW5naW5lXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudmlyb25tZW50SW5pdGlhbGl6ZXIge1xuICAgIHN0YXRpYyBzZXR1cCgpe1xuICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLnJvdW5kZWRSZWN0ID0gZnVuY3Rpb24oeDogbnVtYmVyLCB5OiBudW1iZXIsIHc6IG51bWJlciwgaDogbnVtYmVyLCByOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgICAgIC8vIENsYW1wIHRoZSByYWRpdXMgYmV0d2VlbiAwIGFuZCB0aGUgbWluIG9mIHRoZSB3aWR0aCBvciBoZWlnaHRcbiAgICAgICAgICAgIGlmKHIgPCAwKSByID0gMDtcbiAgICAgICAgICAgIGlmKHIgPiBNYXRoLm1pbih3LCBoKSkgciA9IE1hdGgubWluKHcsIGgpO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIERyYXcgdGhlIHJvdW5kZWQgcmVjdFxuICAgICAgICAgICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBUb3BcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKHggKyByLCB5KTtcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHggKyB3IC0gciwgeSk7XG4gICAgICAgICAgICB0aGlzLmFyY1RvKHggKyB3LCB5LCB4ICsgdywgeSArIHIsIHIpO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIFJpZ2h0XG4gICAgICAgICAgICB0aGlzLmxpbmVUbyh4ICsgdywgeSArIGggLSByKTtcbiAgICAgICAgICAgIHRoaXMuYXJjVG8oeCArIHcsIHkgKyBoLCB4ICsgdyAtIHIsIHkgKyBoLCByKTtcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBCb3R0b21cbiAgICAgICAgICAgIHRoaXMubGluZVRvKHggKyByLCB5ICsgaCk7XG4gICAgICAgICAgICB0aGlzLmFyY1RvKHgsIHkgKyBoLCB4LCB5ICsgaCAtIHIsIHIpO1xuICAgICAgICBcbiAgICAgICAgICAgIC8vIExlZnRcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHgsIHkgKyByKTtcbiAgICAgICAgICAgIHRoaXMuYXJjVG8oeCwgeSwgeCArIHIsIHksIHIpXG4gICAgICAgIFxuICAgICAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5zdHJva2VSb3VuZGVkUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIHIpe1xuICAgICAgICAgICAgdGhpcy5yb3VuZGVkUmVjdCh4LCB5LCB3LCBoLCByKTtcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZmlsbFJvdW5kZWRSZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgcil7XG4gICAgICAgICAgICB0aGlzLnJvdW5kZWRSZWN0KHgsIHksIHcsIGgsIHIpO1xuICAgICAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IEdhbWVMb29wIGZyb20gXCIuL0dhbWVMb29wXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgU3RhdHMgZnJvbSBcIi4uL0RlYnVnL1N0YXRzXCI7XG5cbi8qKlxuICogQSBnYW1lIGxvb3Agd2l0aCBhIGZpeGVkIHVwZGF0ZSB0aW1lIGFuZCBhIHZhcmlhYmxlIHJlbmRlciB0aW1lLlxuICogRXZlcnkgZnJhbWUsIHRoZSBnYW1lIHVwZGF0ZXMgdW50aWwgYWxsIHRpbWUgc2luY2UgdGhlIGxhc3QgZnJhbWUgaGFzIGJlZW4gcHJvY2Vzc2VkLlxuICogSWYgdG9vIG11Y2ggdGltZSBoYXMgcGFzc2VkLCBzdWNoIGFzIGlmIHRoZSBsYXN0IHVwZGF0ZSB3YXMgdG9vIHNsb3csIFxuICogb3IgaWYgdGhlIGJyb3dzZXIgd2FzIHB1dCBpbnRvIHRoZSBiYWNrZ3JvdW5kLCB0aGUgbG9vcCB3aWxsIHBhbmljIGFuZCBkaXNjYXJkIHRpbWUuXG4gKiBBIHJlbmRlciBoYXBwZW5zIGF0IHRoZSBlbmQgb2YgZXZlcnkgZnJhbWUuIFRoaXMgaGFwcGVucyBhcyBmYXN0IGFzIHBvc3NpYmxlIHVubGVzcyBzcGVjaWZpZWQuXG4gKiBBIGxvb3Agb2YgdGhpcyB0eXBlIGFsbG93cyBmb3IgZGV0ZXJtaW5pc3RpYyBiZWhhdmlvciAtIE5vIG1hdHRlciB3aGF0IHRoZSBmcmFtZSByYXRlIGlzLCB0aGUgdXBkYXRlIHNob3VsZCBiZWhhdmUgdGhlIHNhbWUsIFxuICogYXMgaXQgaXMgb2NjdXJpbmcgaW4gYSBmaXhlZCBpbnRlcnZhbC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml4ZWRVcGRhdGVHYW1lTG9vcCBleHRlbmRzIEdhbWVMb29wIHtcblxuXHQvKiogVGhlIG1heCBhbGxvd2VkIHVwZGF0ZSBmcHMuKi9cbiAgICBwcml2YXRlIG1heFVwZGF0ZUZQUzogbnVtYmVyO1xuICAgIFxuICAgIC8qKiBUaGUgdGltZXN0ZXAgZm9yIGVhY2ggdXBkYXRlLiBUaGlzIGlzIHRoZSBkZWx0YVQgcGFzc2VkIHRvIHVwZGF0ZSBjYWxscy4gKi9cblx0cHJpdmF0ZSB1cGRhdGVUaW1lc3RlcDogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBhbW91bnQgb2YgdGltZSB3ZSBhcmUgeWV0IHRvIHNpbXVsYXRlLiAqL1xuICAgIHByaXZhdGUgZnJhbWVEZWx0YTogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSB0aW1lIHdoZW4gdGhlIGxhc3QgZnJhbWUgd2FzIGRyYXduLiAqL1xuICAgIHByaXZhdGUgbGFzdEZyYW1lVGltZTogbnVtYmVyO1xuICAgIFxuICAgIC8qKiBUaGUgbWluaW11bSB0aW1lIHdlIHdhbnQgdG8gd2FpdCBiZXR3ZWVuIGdhbWUgZnJhbWVzLiAqL1xuICAgIHByaXZhdGUgbWluRnJhbWVEZWxheTogbnVtYmVyO1xuXG5cdC8qKiBUaGUgY3VycmVudCBmcmFtZSBvZiB0aGUgZ2FtZS4gKi9cblx0cHJpdmF0ZSBmcmFtZTogbnVtYmVyO1xuXG5cdC8qKiBUaGUgYWN0dWFsIGZwcyBvZiB0aGUgZ2FtZS4gKi9cbiAgICBwcml2YXRlIGZwczogbnVtYmVyO1xuICAgIFxuICAgIC8qKiBUaGUgdGltZSBiZXR3ZWVuIGZwcyBtZWFzdXJlbWVudCB1cGRhdGVzLiAqL1xuICAgIHByaXZhdGUgZnBzVXBkYXRlSW50ZXJ2YWw6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgdGltZSBvZiB0aGUgbGFzdCBmcHMgdXBkYXRlLiAqL1xuICAgIHByaXZhdGUgbGFzdEZwc1VwZGF0ZTogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgZnJhbWVzIHNpbmNlIHRoZSBsYXN0IGZwcyB1cGRhdGUgd2FzIGRvbmUuICovXG4gICAgcHJpdmF0ZSBmcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGU6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgc3RhdHVzIG9mIHdoZXRoZXIgb3Igbm90IHRoZSBnYW1lIGxvb3AgaGFzIHN0YXJ0ZWQuICovXG4gICAgcHJpdmF0ZSBzdGFydGVkOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBzdGF0dXMgb2Ygd2hldGhlciBvciBub3QgdGhlIGdhbWUgbG9vcCBpcyBwYXVzZWQgKi9cbiAgICBwcml2YXRlIHBhdXNlZDogYm9vbGVhbjtcbiAgICBcbiAgICAvKiogVGhlIHN0YXR1cyBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgZ2FtZSBsb29wIGlzIGN1cnJlbnRseSBydW5uaW5nLiAqL1xuICAgIHByaXZhdGUgcnVubmluZzogYm9vbGVhbjtcblxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHVwZGF0ZSBzdGVwcyB0aGlzIGl0ZXJhdGlvbiBvZiB0aGUgZ2FtZSBsb29wLiAqL1xuICAgIHByaXZhdGUgbnVtVXBkYXRlU3RlcHM6IG51bWJlcjtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuICAgICAgICB0aGlzLm1heFVwZGF0ZUZQUyA9IDYwO1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWVzdGVwID0gTWF0aC5mbG9vcigxMDAwL3RoaXMubWF4VXBkYXRlRlBTKTtcbiAgICAgICAgdGhpcy5mcmFtZURlbHRhID0gMDtcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVUaW1lID0gMDtcbiAgICAgICAgdGhpcy5taW5GcmFtZURlbGF5ID0gMDtcbiAgICAgICAgdGhpcy5mcmFtZSA9IDA7XG4gICAgICAgIHRoaXMuZnBzID0gdGhpcy5tYXhVcGRhdGVGUFM7ICAgLy8gSW5pdGlhbGl6ZSB0aGUgZnBzIHRvIHRoZSBtYXggYWxsb3dlZCBmcHNcbiAgICAgICAgdGhpcy5mcHNVcGRhdGVJbnRlcnZhbCA9IDEwMDA7XG4gICAgICAgIHRoaXMubGFzdEZwc1VwZGF0ZSA9IDA7XG4gICAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlID0gMDtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm51bVVwZGF0ZVN0ZXBzID0gMDtcblx0fVxuXG5cdGdldEZQUygpOiBudW1iZXIge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0LyoqXG4gICAgICogVXBkYXRlcyB0aGUgZnJhbWUgY291bnQgYW5kIHN1bSBvZiB0aW1lIGZvciB0aGUgZnJhbWVyYXRlIG9mIHRoZSBnYW1lXG4gICAgICogQHBhcmFtIHRpbWVzdGVwIFRoZSBjdXJyZW50IHRpbWUgaW4gbXNcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlRlBTKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZnBzID0gMC45ICogdGhpcy5mcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGUgKiAxMDAwIC8gKHRpbWVzdGFtcCAtIHRoaXMubGFzdEZwc1VwZGF0ZSkgKygxIC0gMC45KSAqIHRoaXMuZnBzO1xuICAgICAgICB0aGlzLmxhc3RGcHNVcGRhdGUgPSB0aW1lc3RhbXA7XG4gICAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlID0gMDtcblxuICAgICAgICBEZWJ1Zy5sb2coXCJmcHNcIiwgXCJGUFM6IFwiICsgdGhpcy5mcHMudG9GaXhlZCgxKSk7XG4gICAgICAgIFN0YXRzLnVwZGF0ZUZQUyh0aGlzLmZwcyk7XG4gICAgfVxuXG5cdCAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBtYXhpbXVtIGFsbG93ZWQgcGh5c2ljcyBmcmFtZXJhdGUgb2YgdGhlIGdhbWVcbiAgICAgKiBAcGFyYW0gaW5pdE1heCBUaGUgbWF4IGZyYW1lcmF0ZVxuICAgICAqL1xuICAgIHNldE1heFVwZGF0ZUZQUyhpbml0TWF4OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tYXhVcGRhdGVGUFMgPSBpbml0TWF4O1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWVzdGVwID0gTWF0aC5mbG9vcigxMDAwL3RoaXMubWF4VXBkYXRlRlBTKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXhpbXVtIHJlbmRlcmluZyBmcmFtZXJhdGVcbiAgICAgKiBAcGFyYW0gbWF4RlBTIFRoZSBtYXggZnJhbWVyYXRlXG4gICAgICovXG4gICAgc2V0TWF4RlBTKG1heEZQUzogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMubWluRnJhbWVEZWxheSA9IDEwMDAvbWF4RlBTO1xuXHR9XG5cdFxuXHQvKipcblx0ICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB0aGUgZ2FtZSBsb29wIHBhbmljcywgaS5lLiBpdCB0cmllcyB0byBwcm9jZXNzIHRvbyBtdWNoIHRpbWUgaW4gYW4gZW50aXJlIGZyYW1lLlxuXHQgKiBUaGlzIHdpbGwgcmVzZXQgdGhlIGFtb3VudCBvZiB0aW1lIGJhY2sgdG8gemVyby5cblx0ICogQHJldHVybnMgVGhlIGFtb3VudCBvZiB0aW1lIHdlIGFyZSBkaXNjYXJkaW5nIGZyb20gcHJvY2Vzc2luZy5cblx0ICovXG5cdHJlc2V0RnJhbWVEZWx0YSgpIDogbnVtYmVyIHtcbiAgICAgICAgbGV0IG9sZEZyYW1lRGVsdGEgPSB0aGlzLmZyYW1lRGVsdGE7XG4gICAgICAgIHRoaXMuZnJhbWVEZWx0YSA9IDA7XG4gICAgICAgIHJldHVybiBvbGRGcmFtZURlbHRhO1xuICAgIH1cblxuXHQvKipcbiAgICAgKiBTdGFydHMgdXAgdGhlIGdhbWUgbG9vcCBhbmQgY2FsbHMgdGhlIGZpcnN0IHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAqL1xuXHRzdGFydCgpOiB2b2lkIHtcbiAgICAgICAgaWYoIXRoaXMuc3RhcnRlZCl7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0aW1lc3RhbXApID0+IHRoaXMuZG9GaXJzdEZyYW1lKHRpbWVzdGFtcCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGF1c2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXN1bWUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgfVxuXG5cdC8qKlxuICAgICAqIFRoZSBmaXJzdCBnYW1lIGZyYW1lIC0gaW5pdGlhbGl6ZXMgdGhlIGZpcnN0IGZyYW1lIHRpbWUgYW5kIGJlZ2lucyB0aGUgcmVuZGVyXG4gICAgICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgY3VycmVudCB0aW1lIGluIG1zXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRvRmlyc3RGcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQgIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9kb1JlbmRlcigpO1xuXG4gICAgICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IHRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5sYXN0RnBzVXBkYXRlID0gdGltZXN0YW1wO1xuICAgICAgICB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSA9IDA7XG5cbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgodCkgPT4gdGhpcy5kb0ZyYW1lKHQpKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgYW55IHByb2Nlc3NpbmcgdGhhdCBuZWVkcyB0byBiZSBkb25lIGF0IHRoZSBzdGFydCBvZiB0aGUgZnJhbWVcblx0ICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZSBvZiB0aGUgZnJhbWUgaW4gbXNcblx0ICovXG5cdHByb3RlY3RlZCBzdGFydEZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCB7XG5cdFx0Ly8gVXBkYXRlIHRoZSBhbW91bnQgb2YgdGltZSB3ZSBuZWVkIG91ciB1cGRhdGUgdG8gcHJvY2Vzc1xuXHRcdHRoaXMuZnJhbWVEZWx0YSArPSB0aW1lc3RhbXAgLSB0aGlzLmxhc3RGcmFtZVRpbWU7XG5cblx0XHQvLyBTZXQgdGhlIG5ldyB0aW1lIG9mIHRoZSBsYXN0IGZyYW1lXG4gICAgICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IHRpbWVzdGFtcDtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGVzdGltYXRlIG9mIHRoZSBmcmFtZXJhdGVcbiAgICAgICAgaWYodGltZXN0YW1wID4gdGhpcy5sYXN0RnBzVXBkYXRlICsgdGhpcy5mcHNVcGRhdGVJbnRlcnZhbCl7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZQUyh0aW1lc3RhbXApO1xuICAgICAgICB9XG5cblx0XHQvLyBJbmNyZW1lbnQgdGhlIG51bWJlciBvZiBmcmFtZXNcbiAgICAgICAgdGhpcy5mcmFtZSsrO1xuICAgICAgICB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSsrO1xuXHR9XG5cblx0LyoqXG4gICAgICogVGhlIG1haW4gbG9vcCBvZiB0aGUgZ2FtZS4gVXBkYXRlcyB1bnRpbCB0aGUgY3VycmVudCB0aW1lIGlzIHJlYWNoZWQuIFJlbmRlcnMgb25jZVxuICAgICAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIGN1cnJlbnQgdGltZSBpbiBtc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBkb0ZyYW1lID0gKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICAgIC8vIElmIGEgcGF1c2Ugd2FzIGV4ZWN1dGVkLCBzdG9wIGRvaW5nIHRoZSBsb29wLlxuICAgICAgICBpZih0aGlzLnBhdXNlZCl7IFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVxdWVzdCBhbmltYXRpb24gZnJhbWUgdG8gcHJlcGFyZSBmb3IgYW5vdGhlciB1cGRhdGUgb3IgcmVuZGVyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHQpID0+IHRoaXMuZG9GcmFtZSh0KSk7XG5cbiAgICAgICAgLy8gSWYgd2UgYXJlIHRyeWluZyB0byByZW5kZXIgdG9vIHNvb24sIGRvIG5vdGhpbmcuXG4gICAgICAgIGlmKHRpbWVzdGFtcCA8IHRoaXMubGFzdEZyYW1lVGltZSArIHRoaXMubWluRnJhbWVEZWxheSl7XG4gICAgICAgICAgICByZXR1cm47XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEEgZnJhbWUgaXMgYWN0dWFsbHkgaGFwcGVuaW5nXG5cdFx0dGhpcy5zdGFydEZyYW1lKHRpbWVzdGFtcCk7XG5cblx0XHQvLyBVcGRhdGUgd2hpbGUgdGhlcmUgaXMgc3RpbGwgdGltZSB0byBtYWtlIHVwLiBJZiB3ZSBkbyB0b28gbWFueSB1cGRhdGUgc3RlcHMsIHBhbmljIGFuZCBleGl0IHRoZSBsb29wLlxuXHRcdHRoaXMubnVtVXBkYXRlU3RlcHMgPSAwO1xuXHRcdGxldCBwYW5pYyA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlKHRoaXMuZnJhbWVEZWx0YSA+PSB0aGlzLnVwZGF0ZVRpbWVzdGVwKXtcblx0XHRcdC8vIERvIGFuIHVwZGF0ZVxuXHRcdFx0dGhpcy5fZG9VcGRhdGUodGhpcy51cGRhdGVUaW1lc3RlcC8xMDAwKTtcblx0XHRcdFxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSB1cGRhdGUgc3RlcCB0aW1lIGZyb20gdGhlIHRpbWUgd2UgaGF2ZSB0byBwcm9jZXNzXG4gICAgICAgICAgICB0aGlzLmZyYW1lRGVsdGEgLT0gdGhpcy51cGRhdGVUaW1lc3RlcDtcblxuXHRcdFx0Ly8gSW5jcmVtZW50IHN0ZXBzIGFuZCBjaGVjayBpZiB3ZSd2ZSBkb25lIHRvbyBtYW55XG4gICAgICAgICAgICB0aGlzLm51bVVwZGF0ZVN0ZXBzKys7XG4gICAgICAgICAgICBpZih0aGlzLm51bVVwZGF0ZVN0ZXBzID4gMTAwKXtcbiAgICAgICAgICAgICAgICBwYW5pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGVzIGFyZSBkb25lLCByZW5kZXJcbiAgICAgICAgdGhpcy5fZG9SZW5kZXIoKTtcblxuICAgICAgICAvLyBXcmFwIHVwIHRoZSBmcmFtZVxuICAgICAgICB0aGlzLmZpbmlzaEZyYW1lKHBhbmljKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIFdyYXBzIHVwIHRoZSBmcmFtZSBhbmQgaGFuZGxlcyB0aGUgcGFuaWMgc3RhdGUgaWYgdGhlcmUgaXMgb25lXG5cdCAqIEBwYXJhbSBwYW5pYyBXaGV0aGVyIG9yIG5vdCB0aGUgbG9vcCBwYW5pY2tlZFxuXHQgKi9cblx0cHJvdGVjdGVkIGZpbmlzaEZyYW1lKHBhbmljOiBib29sZWFuKTogdm9pZCB7XG5cdFx0aWYocGFuaWMpIHtcbiAgICAgICAgICAgIHZhciBkaXNjYXJkZWRUaW1lID0gTWF0aC5yb3VuZCh0aGlzLnJlc2V0RnJhbWVEZWx0YSgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTWFpbiBsb29wIHBhbmlja2VkLCBwcm9iYWJseSBiZWNhdXNlIHRoZSBicm93c2VyIHRhYiB3YXMgcHV0IGluIHRoZSBiYWNrZ3JvdW5kLiBEaXNjYXJkaW5nICcgKyBkaXNjYXJkZWRUaW1lICsgJ21zJyk7XG4gICAgICAgIH1cblx0fVxuXG59IiwiaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4uL0V2ZW50cy9FdmVudFF1ZXVlXCI7XG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uL0lucHV0L0lucHV0XCI7XG5pbXBvcnQgSW5wdXRIYW5kbGVyIGZyb20gXCIuLi9JbnB1dC9JbnB1dEhhbmRsZXJcIjtcbmltcG9ydCBSZWNvcmRlciBmcm9tIFwiLi4vUGxheWJhY2svUmVjb3JkZXJcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi4vU2NlbmVHcmFwaC9WaWV3cG9ydFwiO1xuaW1wb3J0IFNjZW5lTWFuYWdlciBmcm9tIFwiLi4vU2NlbmUvU2NlbmVNYW5hZ2VyXCI7XG5pbXBvcnQgQXVkaW9NYW5hZ2VyIGZyb20gXCIuLi9Tb3VuZC9BdWRpb01hbmFnZXJcIjtcbmltcG9ydCBTdGF0cyBmcm9tIFwiLi4vRGVidWcvU3RhdHNcIjtcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlclwiO1xuaW1wb3J0IENhbnZhc1JlbmRlcmVyIGZyb20gXCIuLi9SZW5kZXJpbmcvQ2FudmFzUmVuZGVyZXJcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBHYW1lT3B0aW9ucyBmcm9tIFwiLi9HYW1lT3B0aW9uc1wiO1xuaW1wb3J0IEdhbWVMb29wIGZyb20gXCIuL0dhbWVMb29wXCI7XG5pbXBvcnQgRml4ZWRVcGRhdGVHYW1lTG9vcCBmcm9tIFwiLi9GaXhlZFVwZGF0ZUdhbWVMb29wXCI7XG5pbXBvcnQgRW52aXJvbm1lbnRJbml0aWFsaXplciBmcm9tIFwiLi9FbnZpcm9ubWVudEluaXRpYWxpemVyXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBSZWdpc3RyeU1hbmFnZXIgZnJvbSBcIi4uL1JlZ2lzdHJ5L1JlZ2lzdHJ5TWFuYWdlclwiO1xuaW1wb3J0IFdlYkdMUmVuZGVyZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmVyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XG5cbi8qKlxuICogVGhlIG1haW4gbG9vcCBvZiB0aGUgZ2FtZSBlbmdpbmUuXG4gKiBIYW5kbGVzIHRoZSB1cGRhdGUgb3JkZXIsIGFuZCBpbml0aWFsaXplcyBhbGwgc3Vic3lzdGVtcy5cbiAqIFRoZSBHYW1lIG1hbmFnZXMgdGhlIHVwZGF0ZSBjeWNsZSwgYW5kIHJlcXVlc3RzIGFuaW1hdGlvbiBmcmFtZXMgdG8gcmVuZGVyIHRvIHRoZSBicm93c2VyLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lIHtcbiAgICBnYW1lT3B0aW9uczogR2FtZU9wdGlvbnM7XG4gICAgcHJpdmF0ZSBzaG93RGVidWc6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBzaG93U3RhdHM6IGJvb2xlYW47XG5cbiAgICAvLyBUaGUgZ2FtZSBsb29wXG4gICAgcHJpdmF0ZSBsb29wOiBHYW1lTG9vcDtcblxuICAgIC8vIEdhbWUgY2FudmFzIGFuZCBpdHMgd2lkdGggYW5kIGhlaWdodFxuICAgIHJlYWRvbmx5IEdBTUVfQ0FOVkFTOiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICByZWFkb25seSBERUJVR19DQU5WQVM6IEhUTUxDYW52YXNFbGVtZW50O1xuXHRyZWFkb25seSBXSURUSDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IEhFSUdIVDogbnVtYmVyO1xuICAgIHByaXZhdGUgdmlld3BvcnQ6IFZpZXdwb3J0O1xuICAgIHByaXZhdGUgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gICAgcHJpdmF0ZSBjbGVhckNvbG9yOiBDb2xvcjtcbiAgICBcbiAgICAvLyBBbGwgb2YgdGhlIG5lY2Vzc2FyeSBzdWJzeXN0ZW1zIHRoYXQgbmVlZCB0byBydW4gaGVyZVxuXHRwcml2YXRlIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XG5cdHByaXZhdGUgaW5wdXRIYW5kbGVyOiBJbnB1dEhhbmRsZXI7XG5cdHByaXZhdGUgcmVjb3JkZXI6IFJlY29yZGVyO1xuICAgIHByaXZhdGUgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XG4gICAgcHJpdmF0ZSBzY2VuZU1hbmFnZXI6IFNjZW5lTWFuYWdlcjtcbiAgICBwcml2YXRlIGF1ZGlvTWFuYWdlcjogQXVkaW9NYW5hZ2VyO1xuICAgIHByaXZhdGUgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlcjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgR2FtZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBHYW1lIGluaXRpYWxpemF0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pe1xuICAgICAgICAvLyBCZWZvcmUgYW55dGhpbmcgZWxzZSwgYnVpbGQgdGhlIGVudmlyb25tZW50XG4gICAgICAgIEVudmlyb25tZW50SW5pdGlhbGl6ZXIuc2V0dXAoKTtcblxuICAgICAgICAvLyBUeXBlY2FzdCB0aGUgY29uZmlnIG9iamVjdCB0byBhIEdhbWVDb25maWcgb2JqZWN0XG4gICAgICAgIHRoaXMuZ2FtZU9wdGlvbnMgPSBHYW1lT3B0aW9ucy5wYXJzZShvcHRpb25zKTtcblxuICAgICAgICB0aGlzLnNob3dEZWJ1ZyA9IHRoaXMuZ2FtZU9wdGlvbnMuc2hvd0RlYnVnO1xuICAgICAgICB0aGlzLnNob3dTdGF0cyA9IHRoaXMuZ2FtZU9wdGlvbnMuc2hvd1N0YXRzO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBhIGdhbWUgbG9vcFxuICAgICAgICB0aGlzLmxvb3AgPSBuZXcgRml4ZWRVcGRhdGVHYW1lTG9vcCgpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgZ2FtZSBjYW52YXMgYW5kIGdpdmUgaXQgYSBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgICAgIHRoaXMuR0FNRV9DQU5WQVMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnYW1lLWNhbnZhc1wiKTtcbiAgICAgICAgdGhpcy5ERUJVR19DQU5WQVMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkZWJ1Zy1jYW52YXNcIik7XG4gICAgXG4gICAgICAgIC8vIEdpdmUgdGhlIGNhbnZhcyBhIHNpemUgYW5kIGdldCB0aGUgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgICAgdGhpcy5XSURUSCA9IHRoaXMuZ2FtZU9wdGlvbnMuY2FudmFzU2l6ZS54O1xuICAgICAgICB0aGlzLkhFSUdIVCA9IHRoaXMuZ2FtZU9wdGlvbnMuY2FudmFzU2l6ZS55O1xuXG4gICAgICAgIC8vIFRoaXMgc3RlcCBNVVNUIGhhcHBlbiBiZWZvcmUgdGhlIHJlc291cmNlIG1hbmFnZXIgZG9lcyBhbnl0aGluZ1xuICAgICAgICBpZih0aGlzLmdhbWVPcHRpb25zLnVzZVdlYkdMKXtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlciA9IG5ldyBXZWJHTFJlbmRlcmVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmluZ01hbmFnZXIgPSBuZXcgQ2FudmFzUmVuZGVyZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemVHYW1lV2luZG93KCk7XG4gICAgICAgIHRoaXMuY3R4ID0gdGhpcy5yZW5kZXJpbmdNYW5hZ2VyLmluaXRpYWxpemVDYW52YXModGhpcy5HQU1FX0NBTlZBUywgdGhpcy5XSURUSCwgdGhpcy5IRUlHSFQpO1xuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSBuZXcgQ29sb3IodGhpcy5nYW1lT3B0aW9ucy5jbGVhckNvbG9yLnIsIHRoaXMuZ2FtZU9wdGlvbnMuY2xlYXJDb2xvci5nLCB0aGlzLmdhbWVPcHRpb25zLmNsZWFyQ29sb3IuYik7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBkZWJ1Z2dpbmcgYW5kIHN0YXRzXG4gICAgICAgIERlYnVnLmluaXRpYWxpemVEZWJ1Z0NhbnZhcyh0aGlzLkRFQlVHX0NBTlZBUywgdGhpcy5XSURUSCwgdGhpcy5IRUlHSFQpO1xuICAgICAgICBTdGF0cy5pbml0U3RhdHMoKTtcblxuICAgICAgICBpZih0aGlzLmdhbWVPcHRpb25zLnNob3dTdGF0cykge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgc3RhdHMgb3V0cHV0IGFuZCBtYWtlIGl0IG5vIGxvbmdlciBoaWRkZW5cbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhdHNcIikuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaXplIHRoZSB2aWV3cG9ydCB0byB0aGUgZ2FtZSBjYW52YXNcbiAgICAgICAgY29uc3QgY2FudmFzU2l6ZSA9IG5ldyBWZWMyKHRoaXMuV0lEVEgsIHRoaXMuSEVJR0hUKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChjYW52YXNTaXplLCB0aGlzLmdhbWVPcHRpb25zLnpvb21MZXZlbCk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhbGwgbmVjZXNzYXJ5IGdhbWUgc3Vic3lzdGVtc1xuICAgICAgICB0aGlzLmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHRoaXMuaW5wdXRIYW5kbGVyID0gbmV3IElucHV0SGFuZGxlcih0aGlzLkdBTUVfQ0FOVkFTKTtcbiAgICAgICAgSW5wdXQuaW5pdGlhbGl6ZSh0aGlzLnZpZXdwb3J0LCB0aGlzLmdhbWVPcHRpb25zLmlucHV0cyk7XG4gICAgICAgIHRoaXMucmVjb3JkZXIgPSBuZXcgUmVjb3JkZXIoKTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIgPSBuZXcgU2NlbmVNYW5hZ2VyKHRoaXMudmlld3BvcnQsIHRoaXMucmVuZGVyaW5nTWFuYWdlcik7XG4gICAgICAgIHRoaXMuYXVkaW9NYW5hZ2VyID0gQXVkaW9NYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHVwIHRoZSBnYW1lIHdpbmRvdyB0aGF0IGhvbGRzIHRoZSBjYW52YXNlc1xuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdGlhbGl6ZUdhbWVXaW5kb3coKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGdhbWVXaW5kb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdhbWUtd2luZG93XCIpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IHRoZSBoZWlnaHQgb2YgdGhlIGdhbWUgd2luZG93XG4gICAgICAgIGdhbWVXaW5kb3cuc3R5bGUud2lkdGggPSB0aGlzLldJRFRIICsgXCJweFwiO1xuICAgICAgICBnYW1lV2luZG93LnN0eWxlLmhlaWdodCA9IHRoaXMuSEVJR0hUICsgXCJweFwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJlaXZlcyB0aGUgU2NlbmVNYW5hZ2VyIGZyb20gdGhlIEdhbWVcbiAgICAgKiBAcmV0dXJucyBUaGUgU2NlbmVNYW5hZ2VyXG4gICAgICovXG4gICAgZ2V0U2NlbmVNYW5hZ2VyKCk6IFNjZW5lTWFuYWdlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjZW5lTWFuYWdlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIGdhbWVcbiAgICAgKi9cbiAgICBzdGFydChJbml0aWFsU2NlbmU6IG5ldyAoLi4uYXJnczogYW55KSA9PiBTY2VuZSwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICAvLyBTZXQgdGhlIHVwZGF0ZSBmdW5jdGlvbiBvZiB0aGUgbG9vcFxuICAgICAgICB0aGlzLmxvb3AuZG9VcGRhdGUgPSAoZGVsdGFUOiBudW1iZXIpID0+IHRoaXMudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSByZW5kZXIgZnVuY3Rpb24gb2YgdGhlIGxvb3BcbiAgICAgICAgdGhpcy5sb29wLmRvUmVuZGVyID0gKCkgPT4gdGhpcy5yZW5kZXIoKTtcblxuICAgICAgICAvLyBQcmVsb2FkIHJlZ2lzdHJ5IGl0ZW1zXG4gICAgICAgIFJlZ2lzdHJ5TWFuYWdlci5wcmVsb2FkKCk7XG5cbiAgICAgICAgLy8gTG9hZCB0aGUgaXRlbXMgd2l0aCB0aGUgcmVzb3VyY2UgbWFuYWdlclxuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlci5sb2FkUmVzb3VyY2VzRnJvbVF1ZXVlKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UncmUgZG9uZSBsb2FkaW5nLCBzdGFydCB0aGUgbG9vcFxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJGaW5pc2hlZCBQcmVsb2FkIC0gbG9hZGluZyBmaXJzdCBzY2VuZVwiKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoSW5pdGlhbFNjZW5lLCB7fSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmxvb3Auc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhbGwgbmVjZXNzYXJ5IHN1YnN5c3RlbXMgb2YgdGhlIGdhbWUuIERlZmVycyBzY2VuZSB1cGRhdGVzIHRvIHRoZSBzY2VuZU1hbmFnZXJcbiAgICAgKiBAcGFyYW0gZGVsdGFUIFRoZSB0aW1lIHNpbmUgdGhlIGxhc3QgdXBkYXRlXG4gICAgICovXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRyeXtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBhbGwgZXZlbnRzIHRoYXQgaGFwcGVuZWQgc2luY2UgdGhlIHN0YXJ0IG9mIHRoZSBsYXN0IGxvb3BcbiAgICAgICAgICAgIHRoaXMuZXZlbnRRdWV1ZS51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBkYXRhIHN0cnVjdHVyZXMgc28gZ2FtZSBvYmplY3RzIGNhbiBzZWUgdGhlIGlucHV0XG4gICAgICAgICAgICBJbnB1dC51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZWNvcmRpbmcgb2YgdGhlIGdhbWVcbiAgICAgICAgICAgIHRoaXMucmVjb3JkZXIudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgc2NlbmVzXG4gICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGFsbCBzb3VuZHNcbiAgICAgICAgICAgIHRoaXMuYXVkaW9NYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBMb2FkIG9yIHVubG9hZCBhbnkgcmVzb3VyY2VzIGlmIG5lZWRlZFxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIudXBkYXRlKGRlbHRhVCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICB0aGlzLmxvb3AucGF1c2UoKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuY2F1Z2h0IEVycm9yIGluIFVwZGF0ZSAtIENyYXNoaW5nIGdyYWNlZnVsbHlcIik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBjYW52YXMgYW5kIGRlZmVycyBzY2VuZSByZW5kZXJpbmcgdG8gdGhlIHNjZW5lTWFuYWdlci4gUmVuZGVycyB0aGUgZGVidWcgY2FudmFzXG4gICAgICovXG4gICAgcmVuZGVyKCk6IHZvaWQge1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgY2FudmFzZXNcbiAgICAgICAgICAgIERlYnVnLmNsZWFyQ2FudmFzKCk7XG5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlci5jbGVhcih0aGlzLmNsZWFyQ29sb3IpO1xuXG4gICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5yZW5kZXIoKTtcblxuICAgICAgICAgICAgLy8gSGFja3kgZGVidWcgbW9kZVxuICAgICAgICAgICAgaWYoSW5wdXQuaXNLZXlKdXN0UHJlc3NlZChcImdcIikpe1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0RlYnVnID0gIXRoaXMuc2hvd0RlYnVnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZWJ1ZyByZW5kZXJcbiAgICAgICAgICAgIGlmKHRoaXMuc2hvd0RlYnVnKXtcbiAgICAgICAgICAgICAgICBEZWJ1Zy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5zaG93U3RhdHMpe1xuICAgICAgICAgICAgICAgIFN0YXRzLnJlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgdGhpcy5sb29wLnBhdXNlKCk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmNhdWdodCBFcnJvciBpbiBSZW5kZXIgLSBDcmFzaGluZyBncmFjZWZ1bGx5XCIpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgTnVsbEZ1bmMgZnJvbSBcIi4uL0RhdGFUeXBlcy9GdW5jdGlvbnMvTnVsbEZ1bmNcIjtcblxuLyoqXG4gKiBUaGUgbWFpbiBnYW1lIGxvb3Agb2YgdGhlIGdhbWUuIEtlZXBzIHRyYWNrIG9mIGZwcyBhbmQgaGFuZGxlcyBzY2hlZHVsaW5nIG9mIHVwZGF0ZXMgYW5kIHJlbmRlcmluZy5cbiAqIFRoaXMgY2xhc3MgaXMgbGVmdCBhYnN0cmFjdCwgc28gdGhhdCBhIHN1YmNsYXNzIGNhbiBoYW5kbGUgZXhhY3RseSBob3cgdGhlIGxvb3AgaXMgc2NoZWR1bGVkLlxuICogRm9yIGFuIGV4YW1wbGUgb2YgZGlmZmVyZW50IHR5cGVzIG9mIGdhbWUgbG9vcCBzY2hlZHVsaW5nLCBjaGVjayBvdXQgQGxpbmsoR2FtZSBQcm9ncmFtbWluZyBQYXR0ZXJucykoaHR0cHM6Ly9nYW1lcHJvZ3JhbW1pbmdwYXR0ZXJucy5jb20vZ2FtZS1sb29wLmh0bWwpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIEdhbWVMb29wIHtcblxuXHQvKiogVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhbiB1cGRhdGUgb2NjdXJzICovXG5cdHByb3RlY3RlZCBfZG9VcGRhdGU6IEZ1bmN0aW9uID0gTnVsbEZ1bmM7XG5cblx0c2V0IGRvVXBkYXRlKHVwZGF0ZTogRnVuY3Rpb24pe1xuXHRcdHRoaXMuX2RvVXBkYXRlID0gdXBkYXRlO1xuXHR9XG5cblx0LyoqIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYSByZW5kZXIgb2NjdXJzICovXG5cdHByb3RlY3RlZCBfZG9SZW5kZXI6IEZ1bmN0aW9uID0gTnVsbEZ1bmM7XG5cblxuXHRzZXQgZG9SZW5kZXIocmVuZGVyOiBGdW5jdGlvbil7XG5cdFx0dGhpcy5fZG9SZW5kZXIgPSByZW5kZXI7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgRlBTIG9mIHRoZSBnYW1lXG5cdCAqL1xuXHRhYnN0cmFjdCBnZXRGUFMoKTogbnVtYmVyO1xuXG5cdC8qKlxuICAgICAqIFN0YXJ0cyB1cCB0aGUgZ2FtZSBsb29wXG4gICAgICovXG5cdGFic3RyYWN0IHN0YXJ0KCk6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFBhdXNlcyB0aGUgZ2FtZSBsb29wLCB1c3VhbGx5IGZvciBhbiBlcnJvciBjb25kaXRpb24uXG5cdCAqL1xuXHRhYnN0cmFjdCBwYXVzZSgpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBSZXN1bWVzIHRoZSBnYW1lIGxvb3AuXG5cdCAqL1xuXHRhYnN0cmFjdCByZXN1bWUoKTogdm9pZDtcblxuXHQvKipcblx0ICogUnVucyB0aGUgZmlyc3QgZnJhbWUgb2YgdGhlIGdhbWUuIE5vIHVwZGF0ZSBvY2N1cnMgaGVyZSwgb25seSBhIHJlbmRlci5cblx0ICogVGhpcyBpcyBuZWVkZWQgdG8gaW5pdGlhbGl6ZSBkZWx0YSB0aW1lIHZhbHVlc1xuXHQgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGZyYW1lLiBUaGlzIGlzIHJlY2VpdmVkIGZyb20gdGhlIGJyb3dzZXJcblx0ICovXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBkb0ZpcnN0RnJhbWUodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBSdW4gYmVmb3JlIGFueSB1cGRhdGVzIG9yIHRoZSByZW5kZXIgb2YgYSBmcmFtZS5cblx0ICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZXN0YW1wIG9mIHRoZSBmcmFtZS4gVGhpcyBpcyByZWNlaXZlZCBmcm9tIHRoZSBicm93c2VyXG5cdCAqL1xuXHRwcm90ZWN0ZWQgYWJzdHJhY3Qgc3RhcnRGcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFRoZSBjb3JlIG9mIHRoZSBmcmFtZSwgd2hlcmUgYW55IG5lY2Vzc2FyeSB1cGRhdGVzIG9jY3VyLCBhbmQgd2hlcmUgYSByZW5kZXIgaGFwcGVuc1xuXHQgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGZyYW1lLiBUaGlzIGlzIHJlY2VpdmVkIGZyb20gdGhlIGJyb3dzZXJcblx0ICovXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBkb0ZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZDtcblxuXHQvKipcblx0ICogV3JhcHMgdXAgdGhlIGZyYW1lXG5cdCAqIEBwYXJhbSBwYW5pYyBXaGV0aGVyIG9yIG5vdCB0aGUgdXBkYXRlIGN5Y2xlIHBhbmlja2VkLiBUaGlzIGhhcHBlbnMgd2hlbiB0b28gbWFueSB1cGRhdGVzIHRyeSB0byBoYXBwZW4gaW4gYSBzaW5nbGUgZnJhbWVcblx0ICovXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBmaW5pc2hGcmFtZShwYW5pYzogYm9vbGVhbik6IHZvaWQ7XG59IiwiLy8gQGlnbm9yZVBhZ2VcblxuLyoqIFRoZSBvcHRpb25zIGZvciBpbml0aWFsaXppbmcgdGhlIEByZWZlcmVuY2VbR2FtZUxvb3BdICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lT3B0aW9ucyB7XG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydCAqL1xuICAgIGNhbnZhc1NpemU6IHt4OiBudW1iZXIsIHk6IG51bWJlcn07XG5cbiAgICAvKiBUaGUgZGVmYXVsdCBsZXZlbCBvZiB6b29tICovXG4gICAgem9vbUxldmVsOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGNvbG9yIHRvIGNsZWFyIHRoZSBjYW52YXMgdG8gZWFjaCBmcmFtZSAqL1xuICAgIGNsZWFyQ29sb3I6IHtyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyfVxuXG4gICAgLyogQSBsaXN0IG9mIGlucHV0IGJpbmRpbmdzICovXG4gICAgaW5wdXRzOiBBcnJheTx7bmFtZTogc3RyaW5nLCBrZXlzOiBBcnJheTxzdHJpbmc+fT47XG5cbiAgICAvKiBXaGV0aGVyIG9yIG5vdCB0aGUgZGVidWcgcmVuZGVyaW5nIHNob3VsZCBvY2N1ciAqL1xuICAgIHNob3dEZWJ1ZzogYm9vbGVhbjtcblxuICAgIC8qIFdoZXRoZXIgb3Igbm90IHRoZSBzdGF0cyByZW5kZXJpbmcgc2hvdWxkIG9jY3VyICovXG4gICAgc2hvd1N0YXRzOiBib29sZWFuO1xuXG4gICAgLyogV2hldGhlciBvciBub3QgdG8gdXNlIHdlYkdMICovXG4gICAgdXNlV2ViR0w6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIGRhdGEgaW4gdGhlIHJhdyBvcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBnYW1lIG9wdGlvbnMgYXMgYSBSZWNvcmRcbiAgICAgKiBAcmV0dXJucyBBIHZlcnNpb24gb2YgdGhlIG9wdGlvbnMgY29udmVydGVkIHRvIGEgR2FtZU9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBHYW1lT3B0aW9ucyB7XG4gICAgICAgIGxldCBnT3B0ID0gbmV3IEdhbWVPcHRpb25zKCk7XG5cbiAgICAgICAgZ09wdC5jYW52YXNTaXplID0gb3B0aW9ucy5jYW52YXNTaXplID8gb3B0aW9ucy5jYW52YXNTaXplIDoge3g6IDgwMCwgeTogNjAwfTtcbiAgICAgICAgZ09wdC56b29tTGV2ZWwgPSBvcHRpb25zLnpvb21MZXZlbCA/IG9wdGlvbnMuem9vbUxldmVsIDogMTtcbiAgICAgICAgZ09wdC5jbGVhckNvbG9yID0gb3B0aW9ucy5jbGVhckNvbG9yID8gb3B0aW9ucy5jbGVhckNvbG9yIDoge3I6IDI1NSwgZzogMjU1LCBiOiAyNTV9O1xuICAgICAgICBnT3B0LmlucHV0cyA9IG9wdGlvbnMuaW5wdXRzID8gb3B0aW9ucy5pbnB1dHMgOiBbXTtcbiAgICAgICAgZ09wdC5zaG93RGVidWcgPSAhIW9wdGlvbnMuc2hvd0RlYnVnO1xuICAgICAgICBnT3B0LnNob3dTdGF0cyA9ICEhb3B0aW9ucy5zaG93U3RhdHM7XG4gICAgICAgIGdPcHQudXNlV2ViR0wgPSAhIW9wdGlvbnMudXNlV2ViR0w7XG5cbiAgICAgICAgcmV0dXJuIGdPcHQ7XG4gICAgfVxufSIsImltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi9HYW1lTm9kZVwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgUmVnaW9uIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9SZWdpb25cIjtcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcblxuLyoqXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGluIHRoZSBnYW1lIHdvcmxkIHRoYXQgY2FuIGJlIGRyYXduIHRvIHRoZSBzY3JlZW5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgQ2FudmFzTm9kZSBleHRlbmRzIEdhbWVOb2RlIGltcGxlbWVudHMgUmVnaW9uIHtcblx0cHJpdmF0ZSBfc2l6ZTogVmVjMjtcblx0cHJpdmF0ZSBfc2NhbGU6IFZlYzI7XG5cdHByaXZhdGUgX2JvdW5kYXJ5OiBBQUJCO1xuXHRwcml2YXRlIF9oYXNDdXN0b21TaGFkZXI6IGJvb2xlYW47XG5cdHByaXZhdGUgX2N1c3RvbVNoYWRlcktleTogc3RyaW5nO1xuXHRwcml2YXRlIF9hbHBoYTogbnVtYmVyO1xuXG5cdC8qKiBBIGZsYWcgZm9yIHdoZXRoZXIgb3Igbm90IHRoZSBDYW52YXNOb2RlIGlzIHZpc2libGUgKi9cblx0dmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG5cdFxuXHRjb25zdHJ1Y3Rvcigpe1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5fc2l6ZSA9IG5ldyBWZWMyKDAsIDApO1xuXHRcdHRoaXMuX3NpemUuc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5zaXplQ2hhbmdlZCgpKTtcblx0XHR0aGlzLl9zY2FsZSA9IG5ldyBWZWMyKDEsIDEpO1xuXHRcdHRoaXMuX3NjYWxlLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMuc2NhbGVDaGFuZ2VkKCkpO1xuXHRcdHRoaXMuX2JvdW5kYXJ5ID0gbmV3IEFBQkIoKTtcblx0XHR0aGlzLnVwZGF0ZUJvdW5kYXJ5KCk7XG5cblx0XHR0aGlzLl9oYXNDdXN0b21TaGFkZXIgPSBmYWxzZTtcblx0fVxuXG5cdGdldCBhbHBoYSgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLl9hbHBoYTtcblx0fVxuXG5cdHNldCBhbHBoYShhOiBudW1iZXIpIHtcblx0XHR0aGlzLl9hbHBoYSA9IGE7XG5cdH1cblxuXHRnZXQgc2l6ZSgpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZTtcblx0fVxuXG5cdHNldCBzaXplKHNpemU6IFZlYzIpe1xuXHRcdHRoaXMuX3NpemUgPSBzaXplO1xuXHRcdC8vIEVudGVyIGFzIGEgbGFtYmRhIHRvIGJpbmQgXCJ0aGlzXCJcblx0XHR0aGlzLl9zaXplLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMuc2l6ZUNoYW5nZWQoKSk7XG5cdFx0dGhpcy5zaXplQ2hhbmdlZCgpO1xuXHR9XG5cblx0Z2V0IHNjYWxlKCk6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLl9zY2FsZTtcblx0fVxuXG5cdHNldCBzY2FsZShzY2FsZTogVmVjMil7XG5cdFx0dGhpcy5fc2NhbGUgPSBzY2FsZTtcblx0XHQvLyBFbnRlciBhcyBhIGxhbWJkYSB0byBiaW5kIFwidGhpc1wiXG5cdFx0dGhpcy5fc2NhbGUuc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5zY2FsZUNoYW5nZWQoKSk7XG5cdFx0dGhpcy5zY2FsZUNoYW5nZWQoKTtcblx0fVxuXG5cdHNldCBzY2FsZVgodmFsdWU6IG51bWJlcikge1xuXHRcdHRoaXMuc2NhbGUueCA9IHZhbHVlO1xuXHR9XG5cblx0c2V0IHNjYWxlWSh2YWx1ZTogbnVtYmVyKSB7XG5cdFx0dGhpcy5zY2FsZS55ID0gdmFsdWU7XG5cdH1cblxuXHRnZXQgaGFzQ3VzdG9tU2hhZGVyKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9oYXNDdXN0b21TaGFkZXI7XG5cdH1cblxuXHRnZXQgY3VzdG9tU2hhZGVyS2V5KCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuX2N1c3RvbVNoYWRlcktleTtcblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRwcm90ZWN0ZWQgcG9zaXRpb25DaGFuZ2VkKCk6IHZvaWQge1xuXHRcdHN1cGVyLnBvc2l0aW9uQ2hhbmdlZCgpO1xuXHRcdHRoaXMudXBkYXRlQm91bmRhcnkoKTtcblx0fVxuXG5cdC8qKiBDYWxsZWQgaWYgdGhlIHNpemUgdmVjdG9yIGlzIGNoYW5nZWQgb3IgcmVwbGFjZWQuICovXG5cdHByb3RlY3RlZCBzaXplQ2hhbmdlZCgpOiB2b2lkIHtcblx0XHR0aGlzLnVwZGF0ZUJvdW5kYXJ5KCk7XG5cdH1cblxuXHQvKiogQ2FsbGVkIGlmIHRoZSBzY2FsZSB2ZWN0b3IgaXMgY2hhbmdlZCBvciByZXBsYWNlZCAqL1xuXHRwcm90ZWN0ZWQgc2NhbGVDaGFuZ2VkKCk6IHZvaWQge1xuXHRcdHRoaXMudXBkYXRlQm91bmRhcnkoKTtcblx0fVxuXG5cdC8vIEBkb2NJZ25vcmVcblx0LyoqIENhbGxlZCBpZiB0aGUgcG9zaXRpb24sIHNpemUsIG9yIHNjYWxlIG9mIHRoZSBDYW52YXNOb2RlIGlzIGNoYW5nZWQuIFVwZGF0ZXMgdGhlIGJvdW5kYXJ5LiAqL1xuXHRwcml2YXRlIHVwZGF0ZUJvdW5kYXJ5KCk6IHZvaWQge1xuXHRcdHRoaXMuX2JvdW5kYXJ5LmNlbnRlci5zZXQodGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnkpO1xuXHRcdHRoaXMuX2JvdW5kYXJ5LmhhbGZTaXplLnNldCh0aGlzLnNpemUueCp0aGlzLnNjYWxlLngvMiwgdGhpcy5zaXplLnkqdGhpcy5zY2FsZS55LzIpO1xuXHR9XG5cblx0Z2V0IGJvdW5kYXJ5KCk6IEFBQkIge1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZGFyeTtcblx0fVxuXG5cdGdldCBzaXplV2l0aFpvb20oKTogVmVjMiB7XG5cdFx0bGV0IHpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuYm91bmRhcnkuaGFsZlNpemUuY2xvbmUoKS5zY2FsZWQoem9vbSwgem9vbSk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIGN1c3RvbSBzaGFkZXIgdG8gdGhpcyBDYW52YXNOb2RlXG5cdCAqIEBwYXJhbSBrZXkgVGhlIHJlZ2lzdHJ5IGtleSBvZiB0aGUgU2hhZGVyVHlwZVxuXHQgKi9cblx0dXNlQ3VzdG9tU2hhZGVyKGtleTogc3RyaW5nKTogdm9pZCB7XG5cdFx0dGhpcy5faGFzQ3VzdG9tU2hhZGVyID0gdHJ1ZTtcblx0XHR0aGlzLl9jdXN0b21TaGFkZXJLZXkgPSBrZXk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCAoeCwgeSkgaXMgaW5zaWRlIG9mIHRoaXMgY2FudmFzIG9iamVjdFxuXHQgKiBAcGFyYW0geCBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRcblx0ICogQHBhcmFtIHkgVGhlIHkgcG9zaXRpb24gb2YgdGhlIHBvaW50XG5cdCAqIEByZXR1cm5zIEEgZmxhZyByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhpcyBub2RlIGNvbnRhaW5zIHRoZSBwb2ludC5cblx0ICovXG5cdGNvbnRhaW5zKHg6IG51bWJlciwgeTogbnVtYmVyKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kYXJ5LmNvbnRhaW5zUG9pbnQobmV3IFZlYzIoeCwgeSkpO1xuXHR9XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdGRlYnVnUmVuZGVyKCk6IHZvaWQge1xuXHRcdERlYnVnLmRyYXdCb3godGhpcy5yZWxhdGl2ZVBvc2l0aW9uLCB0aGlzLnNpemVXaXRoWm9vbSwgZmFsc2UsIENvbG9yLkJMVUUpO1xuXHRcdHN1cGVyLmRlYnVnUmVuZGVyKCk7XG5cdH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vRXZlbnRzL0VtaXR0ZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJcIjtcbmltcG9ydCBBSSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQUlcIjtcbmltcG9ydCBQaHlzaWNhbCBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUGh5c2ljYWxcIjtcbmltcG9ydCBQb3NpdGlvbmVkIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9Qb3NpdGlvbmVkXCI7XG5pbXBvcnQgeyBpc1JlZ2lvbiB9IGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9SZWdpb25cIjtcbmltcG9ydCBVbmlxdWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VuaXF1ZVwiO1xuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBEZWJ1Z1JlbmRlcmFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0RlYnVnUmVuZGVyYWJsZVwiO1xuaW1wb3J0IEFjdG9yIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BY3RvclwiO1xuaW1wb3J0IFNoYXBlIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL1NoYXBlXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4uL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoXCI7XG5pbXBvcnQgVHdlZW5Db250cm9sbGVyIGZyb20gXCIuLi9SZW5kZXJpbmcvQW5pbWF0aW9ucy9Ud2VlbkNvbnRyb2xsZXJcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBDaXJjbGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQ2lyY2xlXCI7XG5pbXBvcnQgR29hcEFJIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9Hb2FwQUlcIjtcblxuLyoqXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGluIHRoZSBnYW1lIHdvcmxkLlxuICogVG8gY29uc3RydWN0IEdhbWVOb2Rlcywgc2VlIHRoZSBAcmVmZXJlbmNlW1NjZW5lXSBkb2N1bWVudGF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBHYW1lTm9kZSBpbXBsZW1lbnRzIFBvc2l0aW9uZWQsIFVuaXF1ZSwgVXBkYXRlYWJsZSwgUGh5c2ljYWwsIEFjdG9yLCBEZWJ1Z1JlbmRlcmFibGUge1xuXHQvKi0tLS0tLS0tLS0gUE9TSVRJT05FRCAtLS0tLS0tLS0tKi9cblx0cHJpdmF0ZSBfcG9zaXRpb246IFZlYzI7XG5cblx0LyotLS0tLS0tLS0tIFVOSVFVRSAtLS0tLS0tLS0tKi9cblx0cHJpdmF0ZSBfaWQ6IG51bWJlcjtcblxuXHQvKi0tLS0tLS0tLS0gUEhZU0lDQUwgLS0tLS0tLS0tLSovXG5cdGhhc1BoeXNpY3M6IGJvb2xlYW4gPSBmYWxzZTtcblx0bW92aW5nOiBib29sZWFuID0gZmFsc2U7XG5cdGZyb3plbjogYm9vbGVhbiA9IGZhbHNlO1xuXHRvbkdyb3VuZDogYm9vbGVhbiA9IGZhbHNlO1xuXHRvbldhbGw6IGJvb2xlYW4gPSBmYWxzZTtcblx0b25DZWlsaW5nOiBib29sZWFuID0gZmFsc2U7XG5cdGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuXHRjb2xsaXNpb25TaGFwZTogU2hhcGU7XG5cdGNvbGxpZGVyT2Zmc2V0OiBWZWMyO1xuXHRpc1N0YXRpYzogYm9vbGVhbjtcblx0aXNDb2xsaWRhYmxlOiBib29sZWFuO1xuXHRpc1RyaWdnZXI6IGJvb2xlYW47XG5cdHRyaWdnZXJNYXNrOiBudW1iZXI7XG5cdHRyaWdnZXJFbnRlcnM6IEFycmF5PHN0cmluZz47XG5cdHRyaWdnZXJFeGl0czogQXJyYXk8c3RyaW5nPjtcblx0X3ZlbG9jaXR5OiBWZWMyO1xuXHRzd2VwdFJlY3Q6IEFBQkI7XG5cdGNvbGxpZGVkV2l0aFRpbGVtYXA6IGJvb2xlYW47XG5cdGdyb3VwOiBudW1iZXI7XG5cdGlzUGxheWVyOiBib29sZWFuO1xuXHRpc0NvbGxpZGluZzogYm9vbGVhbiA9IGZhbHNlO1xuXG5cdC8qLS0tLS0tLS0tLSBBQ1RPUiAtLS0tLS0tLS0tKi9cblx0X2FpOiBBSSB8IEdvYXBBSTtcblx0YWlBY3RpdmU6IGJvb2xlYW47XG5cdHBhdGg6IE5hdmlnYXRpb25QYXRoO1xuXHRwYXRoZmluZGluZzogYm9vbGVhbiA9IGZhbHNlO1xuXG5cdC8qLS0tLS0tLS0tLSBHRU5FUkFMIC0tLS0tLS0tLS0qL1xuXHQvKiogQW4gZXZlbnQgcmVjZWl2ZXIuICovXG5cdHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XG5cdC8qKiBBbiBldmVudCBlbWl0dGVyLiAqL1xuXHRwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcblx0LyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBzY2VuZSB0aGlzIEdhbWVOb2RlIGlzIGEgcGFydCBvZi4gKi9cblx0cHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcblx0LyoqIFRoZSB2aXN1YWwgbGF5ZXIgdGhpcyBHYW1lTm9kZSByZXNpZGVzIGluLiAqL1xuXHRwcm90ZWN0ZWQgbGF5ZXI6IExheWVyO1xuXHQvKiogQSB1dGlsaXR5IHRoYXQgYWxsb3dzIHRoZSB1c2Ugb2YgdHdlZW5zIG9uIHRoaXMgR2FtZU5vZGUgKi9cblx0dHdlZW5zOiBUd2VlbkNvbnRyb2xsZXI7XG5cdC8qKiBBIHR3ZWVuYWJsZSBwcm9wZXJ0eSBmb3Igcm90YXRpb24uIERvZXMgbm90IGFmZmVjdCB0aGUgYm91bmRpbmcgYm94IG9mIHRoaXMgR2FtZU5vZGUgLSBPbmx5IHJlbmRlcmluZy4gKi9cblx0cm90YXRpb246IG51bWJlcjtcblx0LyoqIFRoZSBvcGFjaXR5IHZhbHVlIG9mIHRoaXMgR2FtZU5vZGUgKi9cblx0YWJzdHJhY3Qgc2V0IGFscGhhKGE6IG51bWJlcik7XG5cblx0YWJzdHJhY3QgZ2V0IGFscGhhKCk6IG51bWJlcjtcblxuXHQvLyBDb25zdHJ1Y3RvciBkb2NzIGFyZSBpZ25vcmVkLCBhcyB0aGUgdXNlciBzaG91bGQgTk9UIGNyZWF0ZSBuZXcgR2FtZU5vZGVzIHdpdGggYSByYXcgY29uc3RydWN0b3Jcblx0Y29uc3RydWN0b3IoKXtcblx0XHR0aGlzLl9wb3NpdGlvbiA9IG5ldyBWZWMyKDAsIDApO1xuXHRcdHRoaXMuX3Bvc2l0aW9uLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMucG9zaXRpb25DaGFuZ2VkKCkpO1xuXHRcdHRoaXMucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcblx0XHR0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuXHRcdHRoaXMudHdlZW5zID0gbmV3IFR3ZWVuQ29udHJvbGxlcih0aGlzKTtcblx0XHR0aGlzLnJvdGF0aW9uID0gMDtcblx0fVxuXG5cdGRlc3Ryb3koKXtcblx0XHR0aGlzLnR3ZWVucy5kZXN0cm95KCk7XG5cdFx0dGhpcy5yZWNlaXZlci5kZXN0cm95KCk7XG5cblx0XHRpZih0aGlzLmhhc1BoeXNpY3Mpe1xuXHRcdFx0dGhpcy5yZW1vdmVQaHlzaWNzKCk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5fYWkpe1xuXHRcdFx0dGhpcy5fYWkuZGVzdHJveSgpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2FpO1xuXHRcdFx0dGhpcy5zY2VuZS5nZXRBSU1hbmFnZXIoKS5yZW1vdmVBY3Rvcih0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLnNjZW5lLnJlbW92ZSh0aGlzKTtcblxuXHRcdHRoaXMubGF5ZXIucmVtb3ZlTm9kZSh0aGlzKTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLSBQT1NJVElPTkVEIC0tLS0tLS0tLS0qL1xuXHRnZXQgcG9zaXRpb24oKTogVmVjMiB7XG5cdFx0cmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xuXHR9XG5cblx0c2V0IHBvc2l0aW9uKHBvczogVmVjMikge1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gcG9zO1xuXHRcdHRoaXMuX3Bvc2l0aW9uLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMucG9zaXRpb25DaGFuZ2VkKCkpO1xuXHRcdHRoaXMucG9zaXRpb25DaGFuZ2VkKCk7XG5cdH1cblxuXHRnZXQgcmVsYXRpdmVQb3NpdGlvbigpOiBWZWMyIHtcblx0XHRyZXR1cm4gdGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXModGhpcy5wb3NpdGlvbik7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBwb2ludCB0byBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGUgem9vbSBhbmQgb3JpZ2luIG9mIHRoaXMgbm9kZVxuXHQgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNvbnZlclxuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHJlcHJlc2VudGluZyB0aGUgcG9pbnQgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcblx0ICovXG5cdGluUmVsYXRpdmVDb29yZGluYXRlcyhwb2ludDogVmVjMik6IFZlYzIge1xuXHRcdGxldCBvcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbih0aGlzKTtcblx0XHRsZXQgem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XG5cdFx0cmV0dXJuIHBvaW50LmNsb25lKCkuc3ViKG9yaWdpbikuc2NhbGUoem9vbSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0gVU5JUVVFIC0tLS0tLS0tLS0qL1xuXHRnZXQgaWQoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5faWQ7XG5cdH1cblxuXHRzZXQgaWQoaWQ6IG51bWJlcikge1xuXHRcdC8vIGlkIGNhbiBvbmx5IGJlIHNldCBvbmNlXG5cdFx0aWYodGhpcy5faWQgPT09IHVuZGVmaW5lZCl7XG5cdFx0XHR0aGlzLl9pZCA9IGlkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBcIkF0dGVtcHRlZCB0byBhc3NpZ24gaWQgdG8gb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgaWQuXCJcblx0XHR9XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0gUEhZU0lDQUwgLS0tLS0tLS0tLSovXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHQvKipcbiAgICAgKiBAcGFyYW0gdmVsb2NpdHkgVGhlIHZlbG9jaXR5IHdpdGggd2hpY2ggdG8gbW92ZSB0aGUgb2JqZWN0LlxuICAgICAqL1xuXHRtb3ZlKHZlbG9jaXR5OiBWZWMyKTogdm9pZCB7XG5cdFx0aWYodGhpcy5mcm96ZW4pIHJldHVybjtcblx0XHR0aGlzLm1vdmluZyA9IHRydWU7XG5cdFx0dGhpcy5fdmVsb2NpdHkgPSB2ZWxvY2l0eTtcblx0fTtcblxuXHRtb3ZlT25QYXRoKHNwZWVkOiBudW1iZXIsIHBhdGg6IE5hdmlnYXRpb25QYXRoKTogdm9pZCB7XG5cdFx0aWYodGhpcy5mcm96ZW4pIHJldHVybjtcblx0XHR0aGlzLnBhdGggPSBwYXRoO1xuXHRcdGxldCBkaXIgPSBwYXRoLmdldE1vdmVEaXJlY3Rpb24odGhpcyk7XG5cdFx0dGhpcy5tb3ZpbmcgPSB0cnVlO1xuXHRcdHRoaXMucGF0aGZpbmRpbmcgPSB0cnVlO1xuXHRcdHRoaXMuX3ZlbG9jaXR5ID0gZGlyLnNjYWxlKHNwZWVkKTtcblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2ZWxvY2l0eSBUaGUgdmVsb2NpdHkgd2l0aCB3aGljaCB0aGUgb2JqZWN0IHdpbGwgbW92ZS5cbiAgICAgKi9cblx0ZmluaXNoTW92ZSgpOiB2b2lkIHtcblx0XHR0aGlzLm1vdmluZyA9IGZhbHNlO1xuXHRcdHRoaXMucG9zaXRpb24uYWRkKHRoaXMuX3ZlbG9jaXR5KTtcblx0XHRpZih0aGlzLnBhdGhmaW5kaW5nKXtcblx0XHRcdHRoaXMucGF0aC5oYW5kbGVQYXRoUHJvZ3Jlc3ModGhpcyk7XG5cdFx0XHR0aGlzLnBhdGggPSBudWxsO1xuXHRcdFx0dGhpcy5wYXRoZmluZGluZyA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHQvKipcblx0ICogQHBhcmFtIGNvbGxpc2lvblNoYXBlIFRoZSBjb2xsaWRlciBmb3IgdGhpcyBvYmplY3QuIElmIHRoaXMgaGFzIGEgcmVnaW9uIChpbXBsZW1lbnRzIFJlZ2lvbiksXG5cdCAqIGl0IHdpbGwgYmUgdXNlZCB3aGVuIG5vIGNvbGxpc2lvbiBzaGFwZSBpcyBzcGVjaWZpZWQgKG9yIGlmIGNvbGxpc2lvbiBzaGFwZSBpcyBudWxsKS5cblx0ICogQHBhcmFtIGlzQ29sbGlkYWJsZSBXaGV0aGVyIHRoaXMgaXMgY29sbGlkYWJsZSBvciBub3QuIFRydWUgYnkgZGVmYXVsdC5cblx0ICogQHBhcmFtIGlzU3RhdGljIFdoZXRoZXIgdGhpcyBpcyBzdGF0aWMgb3Igbm90LiBGYWxzZSBieSBkZWZhdWx0XG5cdCAqL1xuXHRhZGRQaHlzaWNzKGNvbGxpc2lvblNoYXBlPzogU2hhcGUsIGNvbGxpZGVyT2Zmc2V0PzogVmVjMiwgaXNDb2xsaWRhYmxlOiBib29sZWFuID0gdHJ1ZSwgaXNTdGF0aWM6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuXHRcdC8vIEluaXRpYWxpemUgdGhlIHBoeXNpY3MgdmFyaWFibGVzXG5cdFx0dGhpcy5oYXNQaHlzaWNzID0gdHJ1ZTtcblx0XHR0aGlzLm1vdmluZyA9IGZhbHNlO1xuXHRcdHRoaXMub25Hcm91bmQgPSBmYWxzZTtcblx0XHR0aGlzLm9uV2FsbCA9IGZhbHNlO1xuXHRcdHRoaXMub25DZWlsaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5hY3RpdmUgPSB0cnVlO1xuXHRcdHRoaXMuaXNDb2xsaWRhYmxlID0gaXNDb2xsaWRhYmxlO1xuXHRcdHRoaXMuaXNTdGF0aWMgPSBpc1N0YXRpYztcblx0XHR0aGlzLmlzVHJpZ2dlciA9IGZhbHNlO1xuXHRcdHRoaXMudHJpZ2dlck1hc2sgPSAwO1xuXHRcdHRoaXMudHJpZ2dlckVudGVycyA9IG5ldyBBcnJheSgzMik7XG5cdFx0dGhpcy50cmlnZ2VyRXhpdHMgPSBuZXcgQXJyYXkoMzIpO1xuXHRcdHRoaXMuX3ZlbG9jaXR5ID0gVmVjMi5aRVJPO1xuXHRcdHRoaXMuc3dlcHRSZWN0ID0gbmV3IEFBQkIoKTtcblx0XHR0aGlzLmNvbGxpZGVkV2l0aFRpbGVtYXAgPSBmYWxzZTtcblx0XHR0aGlzLmdyb3VwID0gLTE7XHRcdFx0XHRcdC8vIFRoZSBkZWZhdWx0IGdyb3VwLCBjb2xsaWRlcyB3aXRoIGV2ZXJ5dGhpbmdcblxuXHRcdC8vIFNldCB0aGUgY29sbGlzaW9uIHNoYXBlIGlmIHByb3ZpZGVkLCBvciBzaW1wbHkgdXNlIHRoZSB0aGUgcmVnaW9uIGlmIHRoZXJlIGlzIG9uZS5cblx0XHRpZihjb2xsaXNpb25TaGFwZSl7XG5cdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gY29sbGlzaW9uU2hhcGU7XG5cdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciA9IHRoaXMucG9zaXRpb247XG5cdFx0fSBlbHNlIGlmIChpc1JlZ2lvbih0aGlzKSkge1xuXHRcdFx0Ly8gSWYgdGhlIGdhbWVub2RlIGhhcyBhIHJlZ2lvbiBhbmQgbm8gb3RoZXIgaXMgc3BlY2lmaWVkLCB1c2UgdGhhdFxuXHRcdFx0dGhpcy5jb2xsaXNpb25TaGFwZSA9ICg8YW55PnRoaXMpLmJvdW5kYXJ5LmNsb25lKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IFwiTm8gY29sbGlzaW9uIHNoYXBlIHNwZWNpZmllZCBmb3IgcGh5c2ljcyBvYmplY3QuXCJcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSB3ZXJlIHByb3ZpZGVkIHdpdGggYSBjb2xsaWRlciBvZmZzZXQsIHNldCBpdC4gT3RoZXJ3aXNlIHRoZXJlIGlzIG5vIG9mZnNldCwgc28gdXNlIHRoZSB6ZXJvIHZlY3RvclxuXHRcdGlmKGNvbGxpZGVyT2Zmc2V0KXtcblx0XHRcdHRoaXMuY29sbGlkZXJPZmZzZXQgPSBjb2xsaWRlck9mZnNldDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jb2xsaWRlck9mZnNldCA9IFZlYzIuWkVSTztcblx0XHR9XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzd2VwdCByZWN0XG5cdFx0dGhpcy5zd2VwdFJlY3QgPSB0aGlzLmNvbGxpc2lvblNoYXBlLmdldEJvdW5kaW5nUmVjdCgpO1xuXG5cdFx0Ly8gUmVnaXN0ZXIgdGhlIG9iamVjdCB3aXRoIHBoeXNpY3Ncblx0XHR0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkucmVnaXN0ZXJPYmplY3QodGhpcyk7XG5cdH1cblxuXHQvKiogUmVtb3ZlcyB0aGlzIG9iamVjdCBmcm9tIHRoZSBwaHlzaWNzIHN5c3RlbSAqL1xuICAgIHJlbW92ZVBoeXNpY3MoKTogdm9pZCB7XG5cdFx0Ly8gUmVtb3ZlIHRoaXMgZnJvbSB0aGUgcGh5c2ljcyBtYW5hZ2VyXG5cdFx0dGhpcy5zY2VuZS5nZXRQaHlzaWNzTWFuYWdlcigpLmRlcmVnaXN0ZXJPYmplY3QodGhpcyk7XG5cblx0XHQvLyBOdWxsaWZ5IGFsbCBwaHlzaWNzIGZpZWxkc1xuXHRcdHRoaXMuaGFzUGh5c2ljcyA9IGZhbHNlO1xuXHRcdHRoaXMubW92aW5nID0gZmFsc2U7XG5cdFx0dGhpcy5vbkdyb3VuZCA9IGZhbHNlO1xuXHRcdHRoaXMub25XYWxsID0gZmFsc2U7XG5cdFx0dGhpcy5vbkNlaWxpbmcgPSBmYWxzZTtcblx0XHR0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHRcdHRoaXMuaXNDb2xsaWRhYmxlID0gZmFsc2U7XG5cdFx0dGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuXHRcdHRoaXMuaXNUcmlnZ2VyID0gZmFsc2U7XG5cdFx0dGhpcy50cmlnZ2VyTWFzayA9IDA7XG5cdFx0dGhpcy50cmlnZ2VyRW50ZXJzID0gbnVsbDtcblx0XHR0aGlzLnRyaWdnZXJFeGl0cyA9IG51bGw7XG5cdFx0dGhpcy5fdmVsb2NpdHkgPSBWZWMyLlpFUk87XG5cdFx0dGhpcy5zd2VwdFJlY3QgPSBudWxsO1xuXHRcdHRoaXMuY29sbGlkZWRXaXRoVGlsZW1hcCA9IGZhbHNlO1xuXHRcdHRoaXMuZ3JvdXAgPSAtMTtcblx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gbnVsbDtcblx0XHR0aGlzLmNvbGxpZGVyT2Zmc2V0ID0gVmVjMi5aRVJPO1xuXHRcdHRoaXMuc3dlcHRSZWN0ID0gbnVsbDtcblx0fVxuXG5cdC8qKiBEaXNhYmxlcyBwaHlzaWNzIG1vdmVtZW50IGZvciB0aGlzIG5vZGUgKi9cblx0ZnJlZXplKCk6IHZvaWQge1xuXHRcdHRoaXMuZnJvemVuID0gdHJ1ZTtcblx0fVxuXG5cdC8qKiBSZWVuYWJsZXMgcGh5c2ljcyBtb3ZlbWVudCBmb3IgdGhpcyBub2RlICovXG5cdHVuZnJlZXplKCk6IHZvaWQge1xuXHRcdHRoaXMuZnJvemVuID0gZmFsc2U7XG5cdH1cblxuICAgIC8qKiBQcmV2ZW50cyB0aGlzIG9iamVjdCBmcm9tIHBhcnRpY2lwYXRpbmcgaW4gYWxsIGNvbGxpc2lvbnMgYW5kIHRyaWdnZXJzLiBJdCBjYW4gc3RpbGwgbW92ZS4gKi9cbiAgICBkaXNhYmxlUGh5c2ljcygpOiB2b2lkIHtcblx0XHR0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHR9XG5cbiAgICAvKiogRW5hYmxlcyB0aGlzIG9iamVjdCB0byBwYXJ0aWNpcGF0ZSBpbiBjb2xsaXNpb25zIGFuZCB0cmlnZ2Vycy4gVGhpcyBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBkaXNhYmxlUGh5c2ljcyB3YXMgY2FsbGVkICovXG4gICAgZW5hYmxlUGh5c2ljcygpOiB2b2lkIHtcblx0XHR0aGlzLmFjdGl2ZSA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgY29sbGlkZXIgZm9yIHRoaXMgR2FtZU5vZGVcblx0ICogQHBhcmFtIGNvbGxpZGVyIFRoZSBuZXcgY29sbGlkZXIgdG8gdXNlXG5cdCAqL1xuXHRzZXRDb2xsaXNpb25TaGFwZShjb2xsaWRlcjogU2hhcGUpOiB2b2lkIHtcblx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gY29sbGlkZXI7XG5cdFx0dGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIuY29weSh0aGlzLnBvc2l0aW9uKTtcblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHQvKipcbiAgICAgKiBTZXRzIHRoaXMgb2JqZWN0IHRvIGJlIGEgdHJpZ2dlciBmb3IgYSBzcGVjaWZpYyBncm91cFxuICAgICAqIEBwYXJhbSBncm91cCBUaGUgbmFtZSBvZiB0aGUgZ3JvdXAgdGhhdCBhY3RpdmF0ZXMgdGhlIHRyaWdnZXJcbiAgICAgKiBAcGFyYW0gb25FbnRlciBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc2VuZCB3aGVuIHRoaXMgdHJpZ2dlciBpcyBhY3RpdmF0ZWRcbiAgICAgKiBAcGFyYW0gb25FeGl0IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kIHdoZW4gdGhpcyB0cmlnZ2VyIHN0b3BzIGJlaW5nIGFjdGl2YXRlZFxuICAgICAqL1xuICAgIHNldFRyaWdnZXIoZ3JvdXA6IHN0cmluZywgb25FbnRlcjogc3RyaW5nLCBvbkV4aXQ6IHN0cmluZyk6IHZvaWQge1xuXHRcdC8vIE1ha2UgdGhpcyBvYmplY3QgYSB0cmlnZ2VyXG5cdFx0dGhpcy5pc1RyaWdnZXIgPSB0cnVlO1xuXG5cdFx0Ly8gR2V0IHRoZSBudW1iZXIgb2YgdGhlIHBoeXNpY3MgbGF5ZXJcblx0XHRsZXQgbGF5ZXJOdW1iZXIgPSB0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkuZ2V0R3JvdXBOdW1iZXIoZ3JvdXApO1xuXG5cdFx0aWYobGF5ZXJOdW1iZXIgPT09IDApe1xuXHRcdFx0Y29uc29sZS53YXJuKGBUcmlnZ2VyIGZvciBHYW1lTm9kZSAke3RoaXMuaWR9IG5vdCBzZXQgLSBncm91cCBcIiR7Z3JvdXB9XCIgd2FzIG5vdCByZWNvZ25pemVkIGJ5IHRoZSBwaHlzaWNzIG1hbmFnZXIuYCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoaXMgdG8gdGhlIHRyaWdnZXIgbWFza1xuXHRcdHRoaXMudHJpZ2dlck1hc2sgfD0gbGF5ZXJOdW1iZXI7XG5cblx0XHQvLyBMYXllciBudW1iZXJzIGFyZSBiaXRzLCBzbyBnZXQgd2hpY2ggYml0IGl0IGlzXG5cdFx0bGV0IGluZGV4ID0gTWF0aC5sb2cyKGxheWVyTnVtYmVyKTtcblxuXHRcdC8vIFNldCB0aGUgZXZlbnQgbmFtZXNcblx0XHR0aGlzLnRyaWdnZXJFbnRlcnNbaW5kZXhdID0gb25FbnRlcjtcblx0XHR0aGlzLnRyaWdnZXJFeGl0c1tpbmRleF0gPSBvbkV4aXQ7XG5cdH07XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdC8qKlxuXHQgKiBAcGFyYW0gZ3JvdXAgVGhlIHBoeXNpY3MgZ3JvdXAgdGhpcyBub2RlIHNob3VsZCBiZWxvbmcgdG9cblx0ICovXG5cdHNldEdyb3VwKGdyb3VwOiBzdHJpbmcpOiB2b2lkIHtcblx0XHR0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkuc2V0R3JvdXAodGhpcywgZ3JvdXApO1xuXHR9XG5cblx0Ly8gQGltcGxlbWVuZWRcblx0Z2V0TGFzdFZlbG9jaXR5KCk6IFZlYzIge1xuXHRcdHJldHVybiB0aGlzLl92ZWxvY2l0eTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLSBBQ1RPUiAtLS0tLS0tLS0tKi9cblx0Z2V0IGFpKCk6IEFJIHwgR29hcEFJIHtcblx0XHRyZXR1cm4gdGhpcy5fYWk7XG5cdH1cblxuXHRzZXQgYWkoYWk6IEFJIHwgR29hcEFJKSB7XG5cdFx0aWYoIXRoaXMuX2FpKXtcblx0XHRcdC8vIElmIHdlIGhhdmVuJ3QgYmVlbiBwcmV2aW91c2x5IGhhZCBhbiBhaSwgcmVnaXN0ZXIgdXMgd2l0aCB0aGUgYWkgbWFuYWdlclxuXHRcdFx0dGhpcy5zY2VuZS5nZXRBSU1hbmFnZXIoKS5yZWdpc3RlckFjdG9yKHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2FpID0gYWk7XG5cdFx0dGhpcy5haUFjdGl2ZSA9IHRydWU7XG5cdH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0YWRkQUk8VCBleHRlbmRzIEFJIHwgR29hcEFJPihhaTogc3RyaW5nIHwgKG5ldyAoKSA9PiBUKSwgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4sIHR5cGU/OiBudW1iZXIpOiB2b2lkIHtcblx0XHRpZighdGhpcy5fYWkpe1xuXHRcdFx0dGhpcy5zY2VuZS5nZXRBSU1hbmFnZXIoKS5yZWdpc3RlckFjdG9yKHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmKHR5cGVvZiBhaSA9PT0gXCJzdHJpbmdcIil7XG5cdFx0XHR0aGlzLl9haSA9IHRoaXMuc2NlbmUuZ2V0QUlNYW5hZ2VyKCkuZ2VuZXJhdGVBSShhaSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2FpID0gbmV3IGFpKCk7XG5cdFx0fVxuXG5cdFx0Ly8gUXVlc3Rpb24sIGhvdyBtdWNoIGRvIHdlIHdhbnQgZGlmZmVyZW50IHR5cGUgb2YgQUkgdG8gYmUgaGFuZGxlZCB0aGUgc2FtZSwgaS5lLiBzaG91bGQgR29hcEFJIGFuZCBBSSBzaW1pbGFyIG1ldGhvZHMgYW5kIHNpZ25hdHVyZXMgZm9yIHRoZSBzYWtlIG9mIHVuaXR5XG5cdFx0dGhpcy5fYWkuaW5pdGlhbGl6ZUFJKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0dGhpcy5haUFjdGl2ZSA9IHRydWU7XG5cdH1cblxuXHQvLyBAaW1wbGVtZW50ZWRcblx0c2V0QUlBY3RpdmUoYWN0aXZlOiBib29sZWFuLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG5cdFx0dGhpcy5haUFjdGl2ZSA9IGFjdGl2ZTtcblx0XHRpZih0aGlzLmFpQWN0aXZlKXtcblx0XHRcdHRoaXMuYWkuYWN0aXZhdGUob3B0aW9ucyk7XG5cdFx0fVxuXHR9XG5cblx0LyotLS0tLS0tLS0tIFRXRUVOQUJMRSBQUk9QRVJUSUVTIC0tLS0tLS0tLS0qL1xuXHRzZXQgcG9zaXRpb25YKHZhbHVlOiBudW1iZXIpIHtcblx0XHR0aGlzLnBvc2l0aW9uLnggPSB2YWx1ZTtcblx0fVxuXG5cdHNldCBwb3NpdGlvblkodmFsdWU6IG51bWJlcikge1xuXHRcdHRoaXMucG9zaXRpb24ueSA9IHZhbHVlO1xuXHR9XG5cblx0YWJzdHJhY3Qgc2V0IHNjYWxlWCh2YWx1ZTogbnVtYmVyKTtcblxuXHRhYnN0cmFjdCBzZXQgc2NhbGVZKHZhbHVlOiBudW1iZXIpO1xuXG5cdC8qLS0tLS0tLS0tLSBHQU1FIE5PREUgLS0tLS0tLS0tLSovXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzY2VuZSBmb3IgdGhpcyBvYmplY3QuXG5cdCAqIEBwYXJhbSBzY2VuZSBUaGUgc2NlbmUgdGhpcyBvYmplY3QgYmVsb25ncyB0by5cblx0ICovXG5cdHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xuXHRcdHRoaXMuc2NlbmUgPSBzY2VuZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBzY2VuZSB0aGlzIG9iamVjdCBpcyBpbi4gXG5cdCAqIEByZXR1cm5zIFRoZSBzY2VuZSB0aGlzIG9iamVjdCBiZWxvbmdzIHRvXG5cdCovXG5cdGdldFNjZW5lKCk6IFNjZW5lIHtcblx0XHRyZXR1cm4gdGhpcy5zY2VuZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBsYXllciBvZiB0aGlzIG9iamVjdC5cblx0ICogQHBhcmFtIGxheWVyIFRoZSBsYXllciB0aGlzIG9iamVjdCB3aWxsIGJlIG9uLlxuXHQgKi9cblx0c2V0TGF5ZXIobGF5ZXI6IExheWVyKTogdm9pZCB7XG5cdFx0dGhpcy5sYXllciA9IGxheWVyO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxheWVyIHRoaXMgb2JqZWN0IGlzIG9uLlxuXHQgKiBAcmV0dXJucyBUaGlzIGxheWVyIHRoaXMgb2JqZWN0IGlzIG9uLlxuXHQqL1xuXHRnZXRMYXllcigpOiBMYXllciB7XG5cdFx0cmV0dXJuIHRoaXMubGF5ZXI7XG5cdH1cblxuXHQvKiogQ2FsbGVkIGlmIHRoZSBwb3NpdGlvbiB2ZWN0b3IgaXMgbW9kaWZpZWQgb3IgcmVwbGFjZWQgKi9cblx0cHJvdGVjdGVkIHBvc2l0aW9uQ2hhbmdlZCgpOiB2b2lkIHtcblx0XHRpZih0aGlzLmNvbGxpc2lvblNoYXBlKXtcblx0XHRcdGlmKHRoaXMuY29sbGlkZXJPZmZzZXQpe1xuXHRcdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciA9IHRoaXMucG9zaXRpb24uY2xvbmUoKS5hZGQodGhpcy5jb2xsaWRlck9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciA9IHRoaXMucG9zaXRpb24uY2xvbmUoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGlzIEdhbWVOb2RlXG5cdCAqIEBwYXJhbSBkZWx0YVQgVGhlIHRpbWVzdGVwIG9mIHRoZSB1cGRhdGUuXG5cdCAqL1xuXHR1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcblx0XHQvLyBEZWZlciBldmVudCBoYW5kbGluZyB0byBBSS5cblx0XHR3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKXtcblx0XHRcdHRoaXMuX2FpLmhhbmRsZUV2ZW50KHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCkpO1xuXHRcdH1cblx0fVxuXG5cdC8vIEBpbXBsZW1lbnRlZFxuXHRkZWJ1Z1JlbmRlcigpOiB2b2lkIHtcblx0XHQvLyBEcmF3IHRoZSBwb3NpdGlvbiBvZiB0aGlzIEdhbWVOb2RlXG5cdFx0RGVidWcuZHJhd1BvaW50KHRoaXMucmVsYXRpdmVQb3NpdGlvbiwgQ29sb3IuQkxVRSk7XG5cblx0XHQvLyBJZiB2ZWxvY2l0eSBpcyBub3QgemVybywgZHJhdyBhIHZlY3RvciBmb3IgaXRcblx0XHRpZih0aGlzLl92ZWxvY2l0eSAmJiAhdGhpcy5fdmVsb2NpdHkuaXNaZXJvKCkpe1xuXHRcdFx0RGVidWcuZHJhd1JheSh0aGlzLnJlbGF0aXZlUG9zaXRpb24sIHRoaXMuX3ZlbG9jaXR5LmNsb25lKCkuc2NhbGVUbygyMCkuYWRkKHRoaXMucmVsYXRpdmVQb3NpdGlvbiksIENvbG9yLkJMVUUpO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoaXMgaGFzIGEgY29sbGlkZXIsIGRyYXcgaXRcblx0XHRpZih0aGlzLmNvbGxpc2lvblNoYXBlKXtcblx0XHRcdGxldCBjb2xvciA9IHRoaXMuaXNDb2xsaWRpbmcgPyBDb2xvci5SRUQgOiBDb2xvci5HUkVFTjtcblxuXHRcdFx0aWYodGhpcy5pc1RyaWdnZXIpe1xuXHRcdFx0XHRjb2xvciA9IENvbG9yLk1BR0VOVEE7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGNvbG9yLmEgPSAwLjI7XG5cblx0XHRcdGlmKHRoaXMuY29sbGlzaW9uU2hhcGUgaW5zdGFuY2VvZiBBQUJCKXtcblx0XHRcdFx0RGVidWcuZHJhd0JveCh0aGlzLmluUmVsYXRpdmVDb29yZGluYXRlcyh0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciksIHRoaXMuY29sbGlzaW9uU2hhcGUuaGFsZlNpemUuc2NhbGVkKHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCkpLCB0cnVlLCBjb2xvcik7XG5cdFx0XHR9IGVsc2UgaWYodGhpcy5jb2xsaXNpb25TaGFwZSBpbnN0YW5jZW9mIENpcmNsZSl7XG5cdFx0XHRcdERlYnVnLmRyYXdDaXJjbGUodGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXModGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIpLCB0aGlzLmNvbGxpc2lvblNoYXBlLmh3KnRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCksIHRydWUsIGNvbG9yKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGVudW0gVHdlZW5hYmxlUHJvcGVydGllc3tcblx0cG9zWCA9IFwicG9zaXRpb25YXCIsXG5cdHBvc1kgPSBcInBvc2l0aW9uWVwiLFxuXHRzY2FsZVggPSBcInNjYWxlWFwiLFxuXHRzY2FsZVkgPSBcInNjYWxlWVwiLFxuXHRyb3RhdGlvbiA9IFwicm90YXRpb25cIixcblx0YWxwaGEgPSBcImFscGhhXCJcbn0iLCJpbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi9DYW52YXNOb2RlXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XG5cbi8qKlxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgZ2FtZSBvYmplY3QgdGhhdCBkb2Vzbid0IHJlbHkgb24gYW55IHJlc291cmNlcyB0byByZW5kZXIgLSBpdCBpcyBkcmF3biB0byB0aGUgc2NyZWVuIGJ5IHRoZSBjYW52YXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgR3JhcGhpYyBleHRlbmRzIENhbnZhc05vZGUge1xuICAgIC8qKiBUaGUgY29sb3Igb2YgdGhlIEdyYXBoaWMgKi9cbiAgICBjb2xvcjogQ29sb3I7XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbG9yID0gQ29sb3IuUkVEO1xuICAgIH1cblxuICAgIGdldCBhbHBoYSgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLmNvbG9yLmE7XG5cdH1cblxuXHRzZXQgYWxwaGEoYTogbnVtYmVyKSB7XG5cdFx0dGhpcy5jb2xvci5hID0gYTtcblx0fVxuXG4gICAgLy8gQGRlcHJlY2F0ZWRcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2xvciBvZiB0aGUgR3JhcGhpYy4gREVQUkVDQVRFRFxuICAgICAqIEBwYXJhbSBjb2xvciBUaGUgbmV3IGNvbG9yIG9mIHRoZSBHcmFwaGljLlxuICAgICAqL1xuICAgIHNldENvbG9yKGNvbG9yOiBDb2xvcil7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JSKHI6IG51bWJlcil7XG4gICAgICAgIHRoaXMuY29sb3IuciA9IHI7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yUigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvci5yO1xuICAgIH1cblxuICAgIHNldCBjb2xvckcoZzogbnVtYmVyKXtcbiAgICAgICAgdGhpcy5jb2xvci5nID0gZztcbiAgICB9XG5cbiAgICBnZXQgY29sb3JHKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yLmc7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yQihiOiBudW1iZXIpe1xuICAgICAgICB0aGlzLmNvbG9yLmIgPSBiO1xuICAgIH1cblxuICAgIGdldCBjb2xvckIoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3IuYjtcbiAgICB9XG59IiwiZXhwb3J0IGVudW0gR3JhcGhpY1R5cGUge1xuXHRQT0lOVCA9IFwiUE9JTlRcIixcblx0UkVDVCA9IFwiUkVDVFwiLFxuXHRMSU5FID0gXCJMSU5FXCIsXG5cdFBBUlRJQ0xFID0gXCJQQVJUSUNMRVwiXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vR3JhcGhpY1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lIGV4dGVuZHMgR3JhcGhpYyB7XG4gICAgcHJvdGVjdGVkIF9lbmQ6IFZlYzI7XG4gICAgdGhpY2tuZXNzOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFydDogVmVjMiwgZW5kOiBWZWMyKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy50aGlja25lc3MgPSAyO1xuXG4gICAgICAgIC8vIERvZXMgdGhpcyByZWFsbHkgaGF2ZSBhIG1lYW5pbmcgZm9yIGxpbmVzP1xuICAgICAgICB0aGlzLnNpemUuc2V0KDUsIDUpO1xuICAgIH1cblxuICAgIHNldCBzdGFydChwb3M6IFZlYzIpe1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zO1xuICAgIH1cblxuICAgIGdldCBzdGFydCgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG4gICAgfVxuXG4gICAgc2V0IGVuZChwb3M6IFZlYzIpe1xuICAgICAgICB0aGlzLl9lbmQgPSBwb3M7XG4gICAgfVxuXG4gICAgZ2V0IGVuZCgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZDtcbiAgICB9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4vUG9pbnRcIjtcblxuLyoqXG4gKiAtIFBvc2l0aW9uIFhcbi0gVmVsb2NpdHkgKHNwZWVkIGFuZCBkaXJlY3Rpb24pIFhcbi0gQ29sb3IgWFxuLSBMaWZldGltZSBcbi0gQWdlIGNhbiBiZSBoYW5kbGVkIGFzIGxpZmV0aW1lXG4tIFNoYXBlIFhcbi0gU2l6ZSBYXG4tIFRyYW5zcGFyZW5jeSBYXG4gKi9cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJ0aWNsZSBleHRlbmRzIFBvaW50IHtcbiAgICBhZ2U6IG51bWJlcjtcblxuICAgIGluVXNlOiBib29sZWFuO1xuXG4gICAgdmVsOiBWZWMyO1xuXG4gICAgbWFzczogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHNpemU6IFZlYzIsIG1hc3M6IG51bWJlcikge1xuICAgICAgICAvLyBBcmUgd2UgbWFraW5nIHRoaXMgYSBjaXJjbGU/XG4gICAgICAgIHN1cGVyKHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5pblVzZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hc3MgPSBtYXNzO1xuICAgIH1cblxuICAgIHNldFBhcnRpY2xlQWN0aXZlKGxpZmV0aW1lOiBudW1iZXIsIHBvc2l0aW9uOiBWZWMyKSB7XG4gICAgICAgIHRoaXMuYWdlID0gbGlmZXRpbWU7XG4gICAgICAgIHRoaXMuaW5Vc2UgPSB0cnVlO1xuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgZGVjcmVtZW50QWdlKGRlY2F5OiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5hZ2UgLT0gZGVjYXk7XG4gICAgfVxuXG4gICAgc2V0UGFydGljbGVJbmFjdGl2ZSgpe1xuICAgICAgICB0aGlzLmluVXNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHNldCB2ZWxZKHk6IG51bWJlcil7XG4gICAgICAgIHRoaXMudmVsLnkgPSB5O1xuICAgIH1cblxuICAgIGdldCB2ZWxZKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlbC55O1xuICAgIH1cblxuXG59IiwiaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL0dyYXBoaWNcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuXG4vKiogQSBiYXNpYyBwb2ludCB0byBiZSBkcmF3biBvbiB0aGUgc2NyZWVuLiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnQgZXh0ZW5kcyBHcmFwaGljIHtcblxuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyKSB7XG4gICAgICAgIC8vIEFyZSB3ZSBtYWtpbmcgdGhpcyBhIGNpcmNsZT9cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLnNpemUuc2V0KDUsIDUpO1xuICAgIH1cbn0iLCJpbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vR3JhcGhpY1wiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XG5cbi8qKiBBIGJhc2ljIHJlY3RhbmdsZSB0byBiZSBkcmF3biBvbiB0aGUgc2NyZWVuLiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjdCBleHRlbmRzIEdyYXBoaWMge1xuXG4gICAgLyoqIFRoZSBib3JkZXIgY29sb3Igb2YgdGhlIFJlY3QgKi9cbiAgICBib3JkZXJDb2xvcjogQ29sb3I7XG5cbiAgICAvKiogVGhlIHdpZHRoIG9mIHRoZSBib3JkZXIgKi9cbiAgICBib3JkZXJXaWR0aDogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHNpemU6IFZlYzIpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcbiAgICAgICAgdGhpcy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm9yZGVyIGNvbG9yIG9mIHRoaXMgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIGNvbG9yIFRoZSBib3JkZXIgY29sb3JcbiAgICAgKi9cbiAgICBzZXRCb3JkZXJDb2xvcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IGNvbG9yO1xuICAgIH1cblxuICAgIC8vIEBkZXByZWNhdGVkXG4gICAgZ2V0Qm9yZGVyQ29sb3IoKTogQ29sb3Ige1xuICAgICAgICByZXR1cm4gdGhpcy5ib3JkZXJDb2xvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBib3JkZXIgd2lkdGggb2YgdGhpcyByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgaW4gcGl4ZWxzXG4gICAgICovXG4gICAgc2V0Qm9yZGVyV2lkdGgod2lkdGg6IG51bWJlcil7XG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGggPSB3aWR0aDtcbiAgICB9XG5cbiAgICBnZXRCb3JkZXJXaWR0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3JkZXJXaWR0aDtcbiAgICB9XG59IiwiaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi9TcHJpdGVcIjtcbmltcG9ydCBBbmltYXRpb25NYW5hZ2VyIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvQW5pbWF0aW9ucy9BbmltYXRpb25NYW5hZ2VyXCI7XG5pbXBvcnQgU3ByaXRlc2hlZXQgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9TcHJpdGVzaGVldFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5cbi8qKiBBbiBzcHJpdGUgd2l0aCBzcGVjaWZpZWQgYW5pbWF0aW9uIGZyYW1lcy4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGVkU3ByaXRlIGV4dGVuZHMgU3ByaXRlIHtcbiAgICAvKiogVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoaXMgc3ByaXRlIHNoZWV0ICovXG4gICAgcHJvdGVjdGVkIG51bUNvbHM6IG51bWJlcjtcblxuICAgIGdldCBjb2xzKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bUNvbHM7XG4gICAgfVxuXG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGlzIHNwcml0ZSBzaGVldCAqL1xuICAgIHByb3RlY3RlZCBudW1Sb3dzOiBudW1iZXI7XG5cbiAgICBnZXQgcm93cygpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1Sb3dzO1xuICAgIH1cblxuICAgIC8qKiBUaGUgYW5pbWF0aW9uTWFuYWdlciBmb3IgdGhpcyBzcHJpdGUgKi9cbiAgICBhbmltYXRpb246IEFuaW1hdGlvbk1hbmFnZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihzcHJpdGVzaGVldDogU3ByaXRlc2hlZXQpe1xuICAgICAgICBzdXBlcihzcHJpdGVzaGVldC5uYW1lKTtcbiAgICAgICAgdGhpcy5udW1Db2xzID0gc3ByaXRlc2hlZXQuY29sdW1ucztcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gc3ByaXRlc2hlZXQucm93cztcblxuICAgICAgICAvLyBTZXQgdGhlIHNpemUgb2YgdGhlIHNwcml0ZSB0byB0aGUgc3ByaXRlIHNpemUgc3BlY2lmaWVkIGJ5IHRoZSBzcHJpdGVzaGVldFxuICAgICAgICB0aGlzLnNpemUuc2V0KHNwcml0ZXNoZWV0LnNwcml0ZVdpZHRoLCBzcHJpdGVzaGVldC5zcHJpdGVIZWlnaHQpO1xuXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbk1hbmFnZXIodGhpcyk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBhbmltYXRpb25zIHRvIHRoZSBhbmltYXRlZCBzcHJpdGVcbiAgICAgICAgZm9yKGxldCBhbmltYXRpb24gb2Ygc3ByaXRlc2hlZXQuYW5pbWF0aW9ucyl7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGQoYW5pbWF0aW9uLm5hbWUsIGFuaW1hdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbWFnZSBvZmZzZXQgZm9yIHRoZSBjdXJyZW50IGluZGV4IG9mIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggd2UncmUgYXQgaW4gdGhlIGFuaW1hdGlvblxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSBpbWFnZSBvZmZzZXRcbiAgICAgKi9cbiAgICBnZXRBbmltYXRpb25PZmZzZXQoaW5kZXg6IG51bWJlcik6IFZlYzIge1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIoKGluZGV4ICUgdGhpcy5udW1Db2xzKSAqIHRoaXMuc2l6ZS54LCBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKSAqIHRoaXMuc2l6ZS55KTtcbiAgICB9XG59IiwiaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL0NhbnZhc05vZGVcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuXG4vKipcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhIHNwcml0ZSAtIGFuIGluLWdhbWUgaW1hZ2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ByaXRlIGV4dGVuZHMgQ2FudmFzTm9kZSB7XG4gICAgLyoqIFRoZSBpZCBvZiB0aGUgaW1hZ2UgZnJvbSB0aGUgcmVzb3VyY2VNYW5hZ2VyICovXG4gICAgaW1hZ2VJZDogc3RyaW5nO1xuICAgIC8qKiBUaGUgb2Zmc2V0IG9mIHRoZSBzcHJpdGUgaW4gYW4gYXRsYXMgaW1hZ2UgKi9cbiAgICBpbWFnZU9mZnNldDogVmVjMjtcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhlIHgtYXhpcyBzaG91bGQgYmUgaW52ZXJ0ZWQgb24gcmVuZGVyICovXG4gICAgaW52ZXJ0WDogYm9vbGVhbjtcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhlIHktYXhpcyBzaG91bGQgYmUgaW52ZXJ0ZWQgb24gcmVuZGVyICovXG4gICAgaW52ZXJ0WTogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKGltYWdlSWQ6IHN0cmluZyl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaW1hZ2VJZCA9IGltYWdlSWQ7XG4gICAgICAgIGxldCBpbWFnZSA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldEltYWdlKHRoaXMuaW1hZ2VJZCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ldyBWZWMyKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuICAgICAgICB0aGlzLmltYWdlT2Zmc2V0ID0gVmVjMi5aRVJPO1xuICAgICAgICB0aGlzLmludmVydFggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbnZlcnRZID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb2Zmc2V0IG9mIHRoZSBzcHJpdGUgZnJvbSAoMCwgMCkgaW4gdGhlIGltYWdlJ3MgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgb2YgdGhlIHNwcml0ZSBmcm9tICgwLCAwKSBpbiBpbWFnZSBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIHNldEltYWdlT2Zmc2V0KG9mZnNldDogVmVjMik6IHZvaWQge1xuICAgICAgICB0aGlzLmltYWdlT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBUaWxlc2V0IGZyb20gXCIuLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZXNldFwiO1xuaW1wb3J0IHsgVGlsZWRUaWxlbWFwRGF0YSwgVGlsZWRMYXllckRhdGEgfSBmcm9tIFwiLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi9DYW52YXNOb2RlXCI7XG5pbXBvcnQgUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4uL1BoeXNpY3MvUGh5c2ljc01hbmFnZXJcIjtcblxuLyoqXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYSB0aWxlbWFwIC0gdGhpcyBjYW4gY29uc2lzdCBvZiBhIGNvbWJpbmF0aW9uIG9mIHRpbGVzZXRzIGluIG9uZSBsYXllclxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBUaWxlbWFwIGV4dGVuZHMgQ2FudmFzTm9kZSB7XG4gICAgLyoqIEFuIGFycmF5IG9mIHRoZSB0aWxlc2V0cyB0aGF0IHRoaXMgdGlsZW1hcCB1c2VzICovXG4gICAgcHJvdGVjdGVkIHRpbGVzZXRzOiBBcnJheTxUaWxlc2V0PjtcblxuICAgIC8qKiBUaGUgc2l6ZSBvZiBhIHRpbGUgaW4gdGhpcyB0aWxlbWFwICovXG4gICAgcHJvdGVjdGVkIHRpbGVTaXplOiBWZWMyO1xuXG4gICAgLyoqIEFuIGFycmF5IG9mIHRpbGUgZGF0YSAqL1xuICAgIHByb3RlY3RlZCBkYXRhOiBBcnJheTxudW1iZXI+O1xuXG4gICAgLyoqIEFuIGFycmF5IG9mIHRpbGUgY29sbGlzaW9uIGRhdGEgKi9cbiAgICBwcm90ZWN0ZWQgY29sbGlzaW9uTWFwOiBBcnJheTxib29sZWFuPjtcblxuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgdGlsZW1hcCAqL1xuICAgIG5hbWU6IHN0cmluZztcblxuICAgIC8vIFRPRE86IE1ha2UgdGhpcyBubyBsb25nZXIgYmUgc3BlY2lmaWMgdG8gVGlsZWRcbiAgICBjb25zdHJ1Y3Rvcih0aWxlbWFwRGF0YTogVGlsZWRUaWxlbWFwRGF0YSwgbGF5ZXI6IFRpbGVkTGF5ZXJEYXRhLCB0aWxlc2V0czogQXJyYXk8VGlsZXNldD4sIHNjYWxlOiBWZWMyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGlsZXNldHMgPSB0aWxlc2V0cztcbiAgICAgICAgdGhpcy50aWxlU2l6ZSA9IG5ldyBWZWMyKDAsIDApO1xuICAgICAgICB0aGlzLm5hbWUgPSBsYXllci5uYW1lO1xuXG4gICAgICAgIGxldCB0aWxlY291bnQgPSAwO1xuICAgICAgICBmb3IobGV0IHRpbGVzZXQgb2YgdGlsZXNldHMpe1xuICAgICAgICAgICAgdGlsZWNvdW50ICs9IHRpbGVzZXQuZ2V0VGlsZUNvdW50KCkgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2xsaXNpb25NYXAgPSBuZXcgQXJyYXkodGlsZWNvdW50KTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuY29sbGlzaW9uTWFwLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uTWFwW2ldID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZlciBwYXJzaW5nIG9mIHRoZSBkYXRhIHRvIGNoaWxkIGNsYXNzZXMgLSB0aGlzIGFsbG93cyBmb3IgaXNvbWV0cmljIHZzLiBvcnRob2dyYXBoaWMgdGlsZW1hcHMgYW5kIGhhbmRsaW5nIG9mIFRpbGVkIGRhdGEgb3Igb3RoZXIgZGF0YVxuICAgICAgICB0aGlzLnBhcnNlVGlsZW1hcERhdGEodGlsZW1hcERhdGEsIGxheWVyKTtcbiAgICAgICAgdGhpcy5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgdGlsZXNldHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGlsZW1hcFxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFsbCBvZiB0aGUgdGlsZXNldHMgYXNzb2NhaXRlZCB3aXRoIHRoaXMgdGlsZW1hcC5cbiAgICAgKi9cbiAgICBnZXRUaWxlc2V0cygpOiBUaWxlc2V0W10ge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlc2V0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRpbGVzIGluIHRoaXMgdGlsZW1hcCBhcyB0aGV5IGFwcGVhciBpbiB0aGUgZ2FtZSB3b3JsZCBhZnRlciBzY2FsaW5nXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgY29udGFpbmluZyB0aGUgc2l6ZSBvZiB0aWxlcyBpbiB0aGlzIHRpbGVtYXAgYXMgdGhleSBhcHBlYXIgaW4gdGhlIGdhbWUgd29ybGQgYWZ0ZXIgc2NhbGluZy5cbiAgICAgKi9cbiAgICBnZXRUaWxlU2l6ZSgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemUuc2NhbGVkKHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0aWxlIHNpemUgdGFraW5nIHpvb20gaW50byBhY2NvdW50XG4gICAgICogQHJldHVybnMgVGhlIHRpbGUgc2l6ZSB3aXRoIHpvb21cbiAgICAqL1xuICAgIGdldFRpbGVTaXplV2l0aFpvb20oKTogVmVjMiB7XG4gICAgICAgIGxldCB6b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUaWxlU2l6ZSgpLnNjYWxlKHpvb20pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhpcyB0aWxlbWFwIHRvIHRoZSBwaHlzaWNzIHN5c3RlbVxuICAgICovXG4gICAgYWRkUGh5c2ljcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5oYXNQaHlzaWNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmdyb3VwID0gLTE7XG4gICAgICAgIHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5yZWdpc3RlclRpbGVtYXAodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB3b3JsZENvb3JkcyBUaGUgcG9zaXRpb24gaW4gd29ybGQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcmV0dXJucyBBIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCB3b3JsZCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXRUaWxlQXRXb3JsZFBvc2l0aW9uKHdvcmxkQ29vcmRzOiBWZWMyKTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZURhdGEgYXJyYXlcbiAgICAgKiBAcmV0dXJucyBUaGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqL1xuICAgIGFic3RyYWN0IGdldFRpbGVXb3JsZFBvc2l0aW9uKGluZGV4OiBudW1iZXIpOiBWZWMyO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVEYXRhIGFycmF5XG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSB0aWxlIGluIHRoZSB0aWxlRGF0YSBhcnJheVxuICAgICAqL1xuICAgIGFic3RyYWN0IGdldFRpbGUoaW5kZXg6IG51bWJlcik6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGVcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgbmV3IGRhdGEgdmFsdWUgb2YgdGhlIHRpbGVcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBzZXRUaWxlKGluZGV4OiBudW1iZXIsIHR5cGU6IG51bWJlcik6IHZvaWQ7XG5cbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZG4ndCB1c2UgdGlsZWQgZGF0YSBzcGVjaWZpY2FsbHkgLSBpdCBzaG91bGQgYmUgbW9yZSBnZW5lcmFsXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgdGlsZXNldCB1c2luZyB0aGUgZGF0YSBsb2FkZWQgZnJvbSBmaWxlXG4gICAgICogQHBhcmFtIHRpbGVtYXBEYXRhIFRoZSB0aWxlbWFwIGRhdGEgZnJvbSBmaWxlXG4gICAgICogQHBhcmFtIGxheWVyIFRoZSBsYXllciBkYXRhIGZyb20gZmlsZVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBwYXJzZVRpbGVtYXBEYXRhKHRpbGVtYXBEYXRhOiBUaWxlZFRpbGVtYXBEYXRhLCBsYXllcjogVGlsZWRMYXllckRhdGEpOiB2b2lkO1xufSIsImltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9UaWxlbWFwXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCB7IFRpbGVkVGlsZW1hcERhdGEsIFRpbGVkTGF5ZXJEYXRhIH0gZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vLi4vRGVidWcvRGVidWdcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcblxuLyoqXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYW4gb3J0aG9nb25hbCB0aWxlbWFwIC0gaS5lLiBhIHRvcCBkb3duIG9yIHBsYXRmb3JtZXIgdGlsZW1hcFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcnRob2dvbmFsVGlsZW1hcCBleHRlbmRzIFRpbGVtYXAge1xuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRpbGVtYXAgKi9cbiAgICBwcm90ZWN0ZWQgbnVtQ29sczogbnVtYmVyO1xuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRpbGVtYXAgKi9cbiAgICBwcm90ZWN0ZWQgbnVtUm93czogbnVtYmVyO1xuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcHJvdGVjdGVkIHBhcnNlVGlsZW1hcERhdGEodGlsZW1hcERhdGE6IFRpbGVkVGlsZW1hcERhdGEsIGxheWVyOiBUaWxlZExheWVyRGF0YSk6IHZvaWQge1xuICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgdGlsZW1hcCBpbiBsb2NhbCBzcGFjZVxuICAgICAgICB0aGlzLm51bUNvbHMgPSB0aWxlbWFwRGF0YS53aWR0aDtcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gdGlsZW1hcERhdGEuaGVpZ2h0O1xuXG4gICAgICAgIC8vIFRoZSBzaXplIG9mIHRpbGVzXG4gICAgICAgIHRoaXMudGlsZVNpemUuc2V0KHRpbGVtYXBEYXRhLnRpbGV3aWR0aCwgdGlsZW1hcERhdGEudGlsZWhlaWdodCk7XG5cbiAgICAgICAgLy8gVGhlIHNpemUgb2YgdGhlIHRpbGVtYXAgb24gdGhlIGNhbnZhc1xuICAgICAgICB0aGlzLnNpemUuc2V0KHRoaXMubnVtQ29scyAqIHRoaXMudGlsZVNpemUueCwgdGhpcy5udW1Sb3dzICogdGhpcy50aWxlU2l6ZS55KTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KHRoaXMuc2l6ZS5zY2FsZWQoMC41KSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGxheWVyLmRhdGE7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGxheWVyLnZpc2libGU7XG5cbiAgICAgICAgLy8gV2hldGhlciB0aGUgdGlsZW1hcCBpcyBjb2xsaWRhYmxlIG9yIG5vdFxuICAgICAgICB0aGlzLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xuICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgIGZvcihsZXQgaXRlbSBvZiBsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICBpZihpdGVtLm5hbWUgPT09IFwiQ29sbGlkYWJsZVwiKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0NvbGxpZGFibGUgPSBpdGVtLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhbGwgdGlsZXMgYmVzaWRlcyBcImVtcHR5OiAwXCIgdG8gYmUgY29sbGlkYWJsZVxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgdGhpcy5jb2xsaXNpb25NYXAubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25NYXBbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGlsZW1hcFxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSBudW1iZXIgb2YgY29sdW1ucyBhbmQgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSB0aWxlbWFwLlxuICAgICAqL1xuICAgIGdldERpbWVuc2lvbnMoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLm51bUNvbHMsIHRoaXMubnVtUm93cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHdvcmxkIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHdvcmxkQ29vcmRzIFRoZSBjb29yZGluYXRlcyBpbiB3b3JsZCBzcGFjZVxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlXG4gICAgICovXG4gICAgZ2V0VGlsZUF0V29ybGRQb3NpdGlvbih3b3JsZENvb3JkczogVmVjMik6IG51bWJlciB7XG4gICAgICAgIGxldCBsb2NhbENvb3JkcyA9IHRoaXMuZ2V0Q29sUm93QXQod29ybGRDb29yZHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUaWxlQXRSb3dDb2wobG9jYWxDb29yZHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHJvdyBhbmQgY29sdW1uXG4gICAgICogQHBhcmFtIHJvd0NvbCBUaGUgY29vcmRpbmF0ZXMgaW4gdGlsZW1hcCBzcGFjZVxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlXG4gICAgICovXG4gICAgZ2V0VGlsZUF0Um93Q29sKHJvd0NvbDogVmVjMik6IG51bWJlciB7XG4gICAgICAgIGlmKHJvd0NvbC54IDwgMCB8fCByb3dDb2wueCA+PSB0aGlzLm51bUNvbHMgfHwgcm93Q29sLnkgPCAwIHx8IHJvd0NvbC55ID49IHRoaXMubnVtUm93cyl7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3Jvd0NvbC55ICogdGhpcy5udW1Db2xzICsgcm93Q29sLnhdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB0aWxlXG4gICAgICovXG4gICAgZ2V0VGlsZVdvcmxkUG9zaXRpb24oaW5kZXg6IG51bWJlcik6IFZlYzIge1xuICAgICAgICAvLyBHZXQgdGhlIGxvY2FsIHBvc2l0aW9uXG4gICAgICAgIGxldCBjb2wgPSBpbmRleCAlIHRoaXMubnVtQ29scztcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLm51bUNvbHMpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgd29ybGQgcG9zaXRpb25cbiAgICAgICAgbGV0IHggPSBjb2wgKiB0aGlzLnRpbGVTaXplLng7XG4gICAgICAgIGxldCB5ID0gcm93ICogdGhpcy50aWxlU2l6ZS55O1xuXG4gICAgICAgIHJldHVybiBuZXcgVmVjMih4LCB5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGVcbiAgICAgKi9cbiAgICBnZXRUaWxlKGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2luZGV4XTtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBzZXRUaWxlKGluZGV4OiBudW1iZXIsIHR5cGU6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmRhdGFbaW5kZXhdID0gdHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgcm93IGFuZCBjb2x1bW5cbiAgICAgKiBAcGFyYW0gcm93Q29sIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGlsZSBpbiB0aWxlbWFwIHNwYWNlXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIG5ldyBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlXG4gICAgICovXG4gICAgc2V0VGlsZUF0Um93Q29sKHJvd0NvbDogVmVjMiwgdHlwZTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGxldCBpbmRleCA9IHJvd0NvbC55ICogdGhpcy5udW1Db2xzICsgcm93Q29sLng7XG4gICAgICAgIHRoaXMuc2V0VGlsZShpbmRleCwgdHlwZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgcm93IGFuZCBjb2x1bW4gb2YgdGhlIHRpbGVtYXAgaXMgY29sbGlkYWJsZVxuICAgICAqIEBwYXJhbSBpbmRleE9yQ29sIFRoZSBpbmRleCBvZiB0aGUgdGlsZSBvciB0aGUgY29sdW1uIGl0IGlzIGluXG4gICAgICogQHBhcmFtIHJvdyBUaGUgcm93IHRoZSB0aWxlIGlzIGluXG4gICAgICogQHJldHVybnMgQSBmbGFnIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgdGlsZSBpcyBjb2xsaWRhYmxlLlxuICAgICAqL1xuICAgIGlzVGlsZUNvbGxpZGFibGUoaW5kZXhPckNvbDogbnVtYmVyLCByb3c/OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgLy8gVGhlIHZhbHVlIG9mIHRoZSB0aWxlXG4gICAgICAgIGxldCB0aWxlID0gMDtcblxuICAgICAgICBpZihyb3cpe1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIGNvbHVtbiBhbmQgYSByb3dcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLmdldFRpbGVBdFJvd0NvbChuZXcgVmVjMihpbmRleE9yQ29sLCByb3cpKTtcblxuICAgICAgICAgICAgaWYodGlsZSA8IDApe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKGluZGV4T3JDb2wgPCAwIHx8IGluZGV4T3JDb2wgPj0gdGhpcy5kYXRhLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgLy8gVGlsZXMgdGhhdCBkb24ndCBleGlzdCBhcmVuJ3QgY29sbGlkYWJsZVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYW4gaW5kZXhcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLmdldFRpbGUoaW5kZXhPckNvbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaXNpb25NYXBbdGlsZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgaW4gd29ybGQgY29vcmRpbmF0ZXMgYW5kIHJldHVybnMgdGhlIHJvdyBhbmQgY29sdW1uIG9mIHRoZSB0aWxlIGF0IHRoYXQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gd29ybGRDb29yZHMgVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb3RlbnRpYWwgdGlsZSBpbiB3b3JsZCBzcGFjZVxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG90ZW50aWFsIHRpbGUgaW4gdGlsZW1hcCBzcGFjZVxuICAgICAqL1xuICAgIGdldENvbFJvd0F0KHdvcmxkQ29vcmRzOiBWZWMyKTogVmVjMiB7XG4gICAgICAgIGxldCBjb2wgPSBNYXRoLmZsb29yKHdvcmxkQ29vcmRzLnggLyB0aGlzLnRpbGVTaXplLnggLyB0aGlzLnNjYWxlLngpO1xuICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcih3b3JsZENvb3Jkcy55IC8gdGhpcy50aWxlU2l6ZS55IC8gdGhpcy5zY2FsZS55KTtcblxuICAgICAgICByZXR1cm4gbmV3IFZlYzIoY29sLCByb3cpO1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge31cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIGRlYnVnUmVuZGVyKCl7XG4gICAgICAgIC8vIEhhbGYgb2YgdGhlIHRpbGUgc2l6ZVxuICAgICAgICBsZXQgem9vbWVkSGFsZlRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZVdpdGhab29tKCkuc2NhbGVkKDAuNSk7XG4gICAgICAgIGxldCBoYWxmVGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCkuc2NhbGVkKDAuNSk7XG5cbiAgICAgICAgLy8gVGhlIGNlbnRlciBvZiB0aGUgdG9wIGxlZnQgdGlsZVxuICAgICAgICBsZXQgdG9wTGVmdCA9IHRoaXMucG9zaXRpb24uY2xvbmUoKS5zdWIodGhpcy5zaXplLnNjYWxlZCgwLjUpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEEgdmVjIHRvIHN0b3JlIHRoZSBjZW50ZXJcbiAgICAgICAgbGV0IGNlbnRlciA9IFZlYzIuWkVSTztcblxuICAgICAgICBmb3IobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMubnVtQ29sczsgY29sKyspe1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB4LXBvc2l0aW9uXG4gICAgICAgICAgICBjZW50ZXIueCA9IHRvcExlZnQueCArIGNvbCoyKmhhbGZUaWxlU2l6ZS54ICsgaGFsZlRpbGVTaXplLng7XG5cbiAgICAgICAgICAgIGZvcihsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5udW1Sb3dzOyByb3crKyl7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5pc0NvbGxpZGFibGUgJiYgdGhpcy5pc1RpbGVDb2xsaWRhYmxlKGNvbCwgcm93KSl7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgeS1wb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBjZW50ZXIueSA9IHRvcExlZnQueSArIHJvdyoyKmhhbGZUaWxlU2l6ZS55ICsgaGFsZlRpbGVTaXplLnk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRHJhdyBhIGJveCBmb3IgdGhpcyB0aWxlXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLmRyYXdCb3godGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXMoY2VudGVyKSwgem9vbWVkSGFsZlRpbGVTaXplLCBmYWxzZSwgQ29sb3IuQkxVRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuL0NhbnZhc05vZGVcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuLi9JbnB1dC9JbnB1dFwiO1xuXG4vKipcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhIFVJRWxlbWVudCAtIHRoZSBwYXJlbnQgY2xhc3Mgb2YgdGhpbmdzIGxpa2UgYnV0dG9uc1xuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBVSUVsZW1lbnQgZXh0ZW5kcyBDYW52YXNOb2RlIHtcblx0Ly8gU3R5bGUgYXR0cmlidXRlcyAtIFRPRE8gLSBhYnN0cmFjdCB0aGlzIGludG8gYSBzdHlsZSBvYmplY3QvaW50ZXJmYWNlXG5cdC8qKiBUaGUgYmFja2dvdW5kIGNvbG9yICovXG5cdGJhY2tncm91bmRDb2xvcjogQ29sb3I7XG5cdC8qKiBUaGUgYm9yZGVyIGNvbG9yICovXG5cdGJvcmRlckNvbG9yOiBDb2xvcjtcblx0LyoqIFRoZSBib3JkZXIgcmFkaXVzICovXG5cdGJvcmRlclJhZGl1czogbnVtYmVyO1xuXHQvKiogVGhlIGJvcmRlciB3aWR0aCAqL1xuXHRib3JkZXJXaWR0aDogbnVtYmVyO1xuXHQvKiogVGhlIHBhZGRpbmcgKi9cblx0cGFkZGluZzogVmVjMjtcblxuXHQvLyBFdmVudEF0dHJpYnV0ZXNcblx0LyoqIFRoZSByZWFjdGlvbiBvZiB0aGlzIFVJRWxlbWVudCBvbiBhIGNsaWNrICovXG5cdG9uQ2xpY2s6IEZ1bmN0aW9uO1xuXHQvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgb24gY2xpY2sgKi9cblx0b25DbGlja0V2ZW50SWQ6IHN0cmluZztcblx0LyoqIFRoZSByZWFjdGlvbiB0byB0aGUgcmVsZWFzZSBvZiBhIGNsaWNrICovXG5cdG9uUmVsZWFzZTogRnVuY3Rpb247XG5cdC8qKiBUaGUgZXZlbnQgcHJvcGFnYXRlZCBvbiB0aGUgcmVsZWFzZSBvZiBhIGNsaWNrICovXG5cdG9uUmVsZWFzZUV2ZW50SWQ6IHN0cmluZztcblx0LyoqIFRoZSByZWFjdGlvbiB3aGVuIGEgbW91c2UgZW50ZXJzIHRoaXMgVUlFbGVtZW50ICovXG5cdG9uRW50ZXI6IEZ1bmN0aW9uO1xuXHQvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgd2hlbiBhIG1vdXNlIGVudGVycyB0aGlzIFVJRWxlbWVudCAqL1xuXHRvbkVudGVyRXZlbnRJZDogc3RyaW5nO1xuXHQvKiogVGhlIHJlYWN0aW9uIHdoZW4gYSBtb3VzZSBsZWF2ZXMgdGhpcyBVSUVsZW1lbnQgKi9cblx0b25MZWF2ZTogRnVuY3Rpb247XG5cdC8qKiBUaGUgZXZlbnQgcHJvcG9nYXRlZCB3aGVuIGEgbW91c2UgbGVhdmVzIHRoaXMgVUlFbGVtZW50ICovXG5cdG9uTGVhdmVFdmVudElkOiBzdHJpbmc7XG5cblx0LyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgVUlFbGVtZW50IGlzIGN1cnJlbnRseSBjbGlja2VkIG9uICovXG5cdHByb3RlY3RlZCBpc0NsaWNrZWQ6IGJvb2xlYW47XG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIFVJRWxlbWVudCBpcyBjdXJyZW50bHkgaG92ZXJlZCBvdmVyICovXG5cdHByb3RlY3RlZCBpc0VudGVyZWQ6IGJvb2xlYW47XG5cblx0Y29uc3RydWN0b3IocG9zaXRpb246IFZlYzIpe1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuXHRcdFxuXHRcdHRoaXMuYmFja2dyb3VuZENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xuXHRcdHRoaXMuYm9yZGVyQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMCk7XG5cdFx0dGhpcy5ib3JkZXJSYWRpdXMgPSA1O1xuXHRcdHRoaXMuYm9yZGVyV2lkdGggPSAxO1xuXHRcdHRoaXMucGFkZGluZyA9IFZlYzIuWkVSTztcblxuXHRcdHRoaXMub25DbGljayA9IG51bGw7XG5cdFx0dGhpcy5vbkNsaWNrRXZlbnRJZCA9IG51bGw7XG5cdFx0dGhpcy5vblJlbGVhc2UgPSBudWxsO1xuXHRcdHRoaXMub25SZWxlYXNlRXZlbnRJZCA9IG51bGw7XG5cblx0XHR0aGlzLm9uRW50ZXIgPSBudWxsO1xuXHRcdHRoaXMub25FbnRlckV2ZW50SWQgPSBudWxsO1xuXHRcdHRoaXMub25MZWF2ZSA9IG51bGw7XG5cdFx0dGhpcy5vbkxlYXZlRXZlbnRJZCA9IG51bGw7XG5cblx0XHR0aGlzLmlzQ2xpY2tlZCA9IGZhbHNlO1xuXHRcdHRoaXMuaXNFbnRlcmVkID0gZmFsc2U7XG5cdH1cblxuXHQvLyBAZGVwcmVjYXRlZFxuXHRzZXRCYWNrZ3JvdW5kQ29sb3IoY29sb3I6IENvbG9yKTogdm9pZCB7XG5cdFx0dGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcblx0fVxuXG5cdC8vIEBkZXByZWNhdGVkXG5cdHNldFBhZGRpbmcocGFkZGluZzogVmVjMik6IHZvaWQge1xuXHRcdHRoaXMucGFkZGluZy5jb3B5KHBhZGRpbmcpO1xuXHR9XG5cblx0dXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG5cdFx0c3VwZXIudXBkYXRlKGRlbHRhVCk7XG5cblx0XHQvLyBTZWUgb2YgdGhpcyBvYmplY3Qgd2FzIGp1c3QgY2xpY2tlZFxuXHRcdGlmKElucHV0LmlzTW91c2VKdXN0UHJlc3NlZCgpKXtcblx0XHRcdGxldCBjbGlja1BvcyA9IElucHV0LmdldE1vdXNlUHJlc3NQb3NpdGlvbigpO1xuXHRcdFx0aWYodGhpcy5jb250YWlucyhjbGlja1Bvcy54LCBjbGlja1Bvcy55KSAmJiB0aGlzLnZpc2libGUgJiYgIXRoaXMubGF5ZXIuaXNIaWRkZW4oKSl7XG5cdFx0XHRcdHRoaXMuaXNDbGlja2VkID0gdHJ1ZTtcblxuXHRcdFx0XHRpZih0aGlzLm9uQ2xpY2sgIT09IG51bGwpe1xuXHRcdFx0XHRcdHRoaXMub25DbGljaygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHRoaXMub25DbGlja0V2ZW50SWQgIT09IG51bGwpe1xuXHRcdFx0XHRcdGxldCBkYXRhID0ge307XG5cdFx0XHRcdFx0dGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uQ2xpY2tFdmVudElkLCBkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBtb3VzZSB3YXNuJ3QganVzdCBwcmVzc2VkLCB0aGVuIHdlIGRlZmluaXRlbHkgd2VyZW4ndCBjbGlja2VkXG5cdFx0aWYoIUlucHV0LmlzTW91c2VQcmVzc2VkKCkpe1xuXHRcdFx0aWYodGhpcy5pc0NsaWNrZWQpe1xuXHRcdFx0XHR0aGlzLmlzQ2xpY2tlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIHRoZSBtb3VzZSBpcyBob3ZlcmluZyBvdmVyIHRoaXMgZWxlbWVudFxuXHRcdGxldCBtb3VzZVBvcyA9IElucHV0LmdldE1vdXNlUG9zaXRpb24oKTtcblx0XHRpZihtb3VzZVBvcyAmJiB0aGlzLmNvbnRhaW5zKG1vdXNlUG9zLngsIG1vdXNlUG9zLnkpKXtcblx0XHRcdHRoaXMuaXNFbnRlcmVkID0gdHJ1ZTtcblxuXHRcdFx0aWYodGhpcy5vbkVudGVyICE9PSBudWxsKXtcblx0XHRcdFx0dGhpcy5vbkVudGVyKCk7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLm9uRW50ZXJFdmVudElkICE9PSBudWxsKXtcblx0XHRcdFx0bGV0IGRhdGEgPSB7fTtcblx0XHRcdFx0dGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uRW50ZXJFdmVudElkLCBkYXRhKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZih0aGlzLmlzRW50ZXJlZCkge1xuXHRcdFx0dGhpcy5pc0VudGVyZWQgPSBmYWxzZTtcblxuXHRcdFx0aWYodGhpcy5vbkxlYXZlICE9PSBudWxsKXtcblx0XHRcdFx0dGhpcy5vbkxlYXZlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZih0aGlzLm9uTGVhdmVFdmVudElkICE9PSBudWxsKXtcblx0XHRcdFx0bGV0IGRhdGEgPSB7fTtcblx0XHRcdFx0dGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uTGVhdmVFdmVudElkLCBkYXRhKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYodGhpcy5pc0NsaWNrZWQpIHtcblx0XHRcdC8vIElmIG1vdXNlIGlzIGRyYWdnZWQgb2ZmIG9mIGVsZW1lbnQgd2hpbGUgZG93biwgaXQgaXMgbm90IGNsaWNrZWQgYW55bW9yZVxuXHRcdFx0dGhpcy5pc0NsaWNrZWQgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciBjYWxjdWxhdGluZyBiYWNrZ3JvdW5kIGNvbG9yIC0gdXNlZnVsIGZvciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gYmUgY29sb3JlZCBvbiBkaWZmZXJlbnQgYWZ0ZXIgY2VydGFpbiBldmVudHNcblx0ICogQHJldHVybnMgVGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIFVJRWxlbWVudFxuXHQgKi9cblx0Y2FsY3VsYXRlQmFja2dyb3VuZENvbG9yKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG5cdH1cblxuXHQvKipcblx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciBjYWxjdWxhdGluZyBib3JkZXIgY29sb3IgLSB1c2VmdWwgZm9yIGVsZW1lbnRzIHRoYXQgd2FudCB0byBiZSBjb2xvcmVkIG9uIGRpZmZlcmVudCBhZnRlciBjZXJ0YWluIGV2ZW50c1xuXHQgKiBAcmV0dXJucyBUaGUgYm9yZGVyIGNvbG9yIG9mIHRoZSBVSUVsZW1lbnRcblx0ICovXG5cdGNhbGN1bGF0ZUJvcmRlckNvbG9yKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gdGhpcy5ib3JkZXJDb2xvcjtcblx0fVxufSIsImltcG9ydCBMYWJlbCBmcm9tIFwiLi9MYWJlbFwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5cbi8qKiBBIGNsaWNrYWJsZSBidXR0b24gVUlFbGVtZW50ICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b24gZXh0ZW5kcyBMYWJlbCB7XG5cblx0Y29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHRleHQ6IHN0cmluZyl7XG5cdFx0c3VwZXIocG9zaXRpb24sIHRleHQpO1xuXHRcdFxuXHRcdHRoaXMuYmFja2dyb3VuZENvbG9yID0gbmV3IENvbG9yKDE1MCwgNzUsIDIwMyk7XG5cdFx0dGhpcy5ib3JkZXJDb2xvciA9IG5ldyBDb2xvcig0MSwgNDYsIDMwKTtcblx0XHR0aGlzLnRleHRDb2xvciA9IG5ldyBDb2xvcigyNTUsIDI1NSwgMjU1KTtcblx0fVxuXG5cdC8vIEBvdmVycmlkZVxuXHRjYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3IoKTogQ29sb3Ige1xuXHRcdC8vIENoYW5nZSB0aGUgYmFja2dyb3VuZCBjb2xvciBpZiBjbGlja2VkIG9yIGhvdmVyZWRcblx0XHRpZih0aGlzLmlzRW50ZXJlZCAmJiAhdGhpcy5pc0NsaWNrZWQpe1xuXHRcdFx0cmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yLmxpZ2h0ZW4oKTtcblx0XHR9IGVsc2UgaWYodGhpcy5pc0NsaWNrZWQpe1xuXHRcdFx0cmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yLmRhcmtlbigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0fVxuXHR9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9VSUVsZW1lbnRcIjtcblxuLyoqIEEgYmFzaWMgdGV4dC1jb250YWluaW5nIGxhYmVsICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbCBleHRlbmRzIFVJRWxlbWVudHtcblx0LyoqIFRoZSBjb2xvciBvZiB0aGUgdGV4dCBvZiB0aGlzIFVJRWxlbWVudCAqL1xuXHR0ZXh0Q29sb3I6IENvbG9yO1xuXHQvKiogVGhlIHZhbHVlIG9mIHRoZSB0ZXh0IG9mIHRoaXMgVUlFbGVtZW50ICovXG5cdHRleHQ6IHN0cmluZztcblx0LyoqIFRoZSBuYW1lIG9mIHRoZSBmb250ICovXG5cdGZvbnQ6IHN0cmluZztcblx0LyoqIFRoZSBzaXplIG9mIHRoZSBmb250ICovXG5cdGZvbnRTaXplOiBudW1iZXI7XG5cdC8qKiBUaGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgdGhlIHRleHQgd2l0aGluIHRoZSBsYWJlbCAqL1xuXHRwcm90ZWN0ZWQgaEFsaWduOiBzdHJpbmc7XG5cdC8qKiBUaGUgdmVydGljYWwgYWxpZ25tZW50IG9mIHRleHQgd2l0aGluIHRoZSBsYWJlbCAqL1xuXHRwcm90ZWN0ZWQgdkFsaWduOiBzdHJpbmc7XG5cblx0LyoqIEEgZmxhZyBmb3IgaWYgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0IGhhcyBiZWVuIG1lYXN1cmVkIG9uIHRoZSBjYW52YXMgZm9yIGF1dG8gd2lkdGggYXNzaWdubWVudCAqL1xuXHRwcm90ZWN0ZWQgc2l6ZUFzc2lnbmVkOiBib29sZWFuO1xuXG5cdGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyLCB0ZXh0OiBzdHJpbmcpe1xuXHRcdHN1cGVyKHBvc2l0aW9uKTtcblx0XHR0aGlzLnRleHQgPSB0ZXh0O1xuXHRcdHRoaXMudGV4dENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDEpO1xuXHRcdHRoaXMuZm9udCA9IFwiQXJpYWxcIjtcblx0XHR0aGlzLmZvbnRTaXplID0gMzA7XG5cdFx0dGhpcy5oQWxpZ24gPSBcImNlbnRlclwiO1xuXHRcdHRoaXMudkFsaWduID0gXCJjZW50ZXJcIjtcblxuXHRcdHRoaXMuc2l6ZUFzc2lnbmVkID0gZmFsc2U7XG5cdH1cblxuXHQvLyBAZGVwcmVjYXRlZFxuXHRzZXRUZXh0KHRleHQ6IHN0cmluZyk6IHZvaWQge1xuXHRcdHRoaXMudGV4dCA9IHRleHQ7XG5cdH1cblxuXHQvLyBAZGVwcmVjYXRlZFxuXHRzZXRUZXh0Q29sb3IoY29sb3I6IENvbG9yKTogdm9pZCB7XG5cdFx0dGhpcy50ZXh0Q29sb3IgPSBjb2xvcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIGEgc3RyaW5nIGNvbnRhaW5nIHRoZSBmb250IGRldGFpbHMgZm9yIHJlbmRlcmluZ1xuXHQgKiBAcmV0dXJucyBBIHN0cmluZyBjb250YWluaW5nIHRoZSBmb250IGRldGFpbHNcblx0ICovXG5cdGdldEZvbnRTdHJpbmcoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5mb250U2l6ZSArIFwicHggXCIgKyB0aGlzLmZvbnQ7XG5cdH1cblxuXHQvKipcblx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciBjYWxjdWxhdGluZyB0ZXh0IGNvbG9yIC0gdXNlZnVsIGZvciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gYmUgY29sb3JlZCBvbiBkaWZmZXJlbnQgYWZ0ZXIgY2VydGFpbiBldmVudHNcblx0ICogQHJldHVybnMgYSBzdHJpbmcgY29udGFpbmcgdGhlIHRleHQgY29sb3Jcblx0ICovXG5cdGNhbGN1bGF0ZVRleHRDb2xvcigpOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLnRleHRDb2xvci50b1N0cmluZ1JHQkEoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVc2VzIHRoZSBjYW52YXMgdG8gY2FsY3VsYXRlIHRoZSB3aWR0aCBvZiB0aGUgdGV4dFxuXHQgKiBAcGFyYW0gY3R4IFRoZSByZW5kZXJpbmcgY29udGV4dFxuXHQgKiBAcmV0dXJucyBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHJlbmRlcmVkIHRleHQgd2lkdGhcblx0ICovXG5cdHByb3RlY3RlZCBjYWxjdWxhdGVUZXh0V2lkdGgoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiBudW1iZXIge1xuXHRcdGN0eC5mb250ID0gdGhpcy5mb250U2l6ZSArIFwicHggXCIgKyB0aGlzLmZvbnQ7XG5cdFx0cmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0aGlzLnRleHQpLndpZHRoO1xuXHR9XG5cblx0c2V0SEFsaWduKGFsaWduOiBzdHJpbmcpOiB2b2lkIHtcblx0XHR0aGlzLmhBbGlnbiA9IGFsaWduO1xuXHR9XG5cblx0c2V0VkFsaWduKGFsaWduOiBzdHJpbmcpOiB2b2lkIHtcblx0XHR0aGlzLnZBbGlnbiA9IGFsaWduO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSB0aGUgb2Zmc2V0IG9mIHRoZSB0ZXh0IC0gdGhpcyBpcyB1c2VkIGZvciByZW5kZXJpbmcgdGV4dCB3aXRoIGRpZmZlcmVudCBhbGlnbm1lbnRzXG5cdCAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqIEByZXR1cm5zIFRoZSBvZmZzZXQgb2YgdGhlIHRleHQgaW4gYSBWZWMyXG5cdCAqL1xuXHRjYWxjdWxhdGVUZXh0T2Zmc2V0KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogVmVjMiB7XG5cdFx0bGV0IHRleHRXaWR0aCA9IHRoaXMuY2FsY3VsYXRlVGV4dFdpZHRoKGN0eCk7XG5cblx0XHRsZXQgb2Zmc2V0ID0gbmV3IFZlYzIoMCwgMCk7XG5cblx0XHRsZXQgaERpZmYgPSB0aGlzLnNpemUueCAtIHRleHRXaWR0aDtcblx0XHRpZih0aGlzLmhBbGlnbiA9PT0gSEFsaWduLkNFTlRFUil7XG5cdFx0XHRvZmZzZXQueCA9IGhEaWZmLzI7XG5cdFx0fSBlbHNlIGlmICh0aGlzLmhBbGlnbiA9PT0gSEFsaWduLlJJR0hUKXtcblx0XHRcdG9mZnNldC54ID0gaERpZmY7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy52QWxpZ24gPT09IFZBbGlnbi5UT1Ape1xuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG5cdFx0XHRvZmZzZXQueSA9IDA7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnZBbGlnbiA9PT0gVkFsaWduLkJPVFRPTSl7XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcblx0XHRcdG9mZnNldC55ID0gdGhpcy5zaXplLnk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuXHRcdFx0b2Zmc2V0LnkgPSB0aGlzLnNpemUueS8yO1xuXHRcdH1cblxuXHRcdHJldHVybiBvZmZzZXQ7XG5cdH1cblxuXHRwcm90ZWN0ZWQgc2l6ZUNoYW5nZWQoKTogdm9pZCB7XG5cdFx0c3VwZXIuc2l6ZUNoYW5nZWQoKTtcblx0XHR0aGlzLnNpemVBc3NpZ25lZCA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQXV0b21hdGljYWxseSBzaXplcyB0aGUgZWxlbWVudCB0byB0aGUgdGV4dCB3aXRoaW4gaXRcblx0ICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdHByb3RlY3RlZCBhdXRvU2l6ZShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQge1xuXHRcdGxldCB3aWR0aCA9IHRoaXMuY2FsY3VsYXRlVGV4dFdpZHRoKGN0eCk7XG5cdFx0bGV0IGhlaWdodCA9IHRoaXMuZm9udFNpemU7XG5cdFx0dGhpcy5zaXplLnNldCh3aWR0aCArIHRoaXMucGFkZGluZy54KjIsIGhlaWdodCArIHRoaXMucGFkZGluZy55KjIpO1xuXHRcdHRoaXMuc2l6ZUFzc2lnbmVkID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsbHkgYXNzaWducyBhIHNpemUgdG8gdGhlIFVJRWxlbWVudCBpZiBub25lIGlzIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XG5cdCAqL1xuXHRoYW5kbGVJbml0aWFsU2l6aW5nKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZCB7XG5cdFx0aWYoIXRoaXMuc2l6ZUFzc2lnbmVkKXtcblx0XHRcdHRoaXMuYXV0b1NpemUoY3R4KTtcblx0XHR9XG5cdH1cblxuXHQvKiogT24gdGhlIG5leHQgcmVuZGVyLCBzaXplIHRoaXMgZWxlbWVudCB0byBpdCdzIGN1cnJlbnQgdGV4dCB1c2luZyBpdHMgY3VycmVudCBmb250IHNpemUgKi9cblx0c2l6ZVRvVGV4dCgpOiB2b2lkIHtcblx0XHR0aGlzLnNpemVBc3NpZ25lZCA9IGZhbHNlO1xuXHR9XG59XG5cbmV4cG9ydCBlbnVtIFZBbGlnbiB7XG5cdFRPUCA9IFwidG9wXCIsXG5cdENFTlRFUiA9IFwiY2VudGVyXCIsXG5cdEJPVFRPTSA9IFwiYm90dG9tXCJcbn1cblxuZXhwb3J0IGVudW0gSEFsaWduIHtcblx0TEVGVCA9IFwibGVmdFwiLFxuXHRDRU5URVIgPSBcImNlbnRlclwiLFxuXHRSSUdIVCA9IFwicmlnaHRcIlxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi9JbnB1dC9JbnB1dFwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9VSUVsZW1lbnRcIjtcblxuLyoqIEEgc2xpZGVyIFVJRWxlbWVudCAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2xpZGVyIGV4dGVuZHMgVUlFbGVtZW50IHtcbiAgICAvKiogVGhlIHZhbHVlIG9mIHRoZSBzbGlkZXIgZnJvbSBbMCwgMV0gKi9cbiAgICBwcm90ZWN0ZWQgdmFsdWU6IG51bWJlcjtcbiAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSBzbGlkZXIgbmliICovXG4gICAgcHVibGljIG5pYkNvbG9yOiBDb2xvcjtcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIG5pYiAqL1xuICAgIHB1YmxpYyBuaWJTaXplOiBWZWMyO1xuICAgIC8qKiBUaGUgY29sb3Igb2YgdGhlIHNsaWRlciB0cmFjayAqL1xuICAgIHB1YmxpYyBzbGlkZXJDb2xvcjogQ29sb3I7XG4gICAgLyoqIFRoZSByZWFjdGlvbiBvZiB0aGlzIFVJRWxlbWVudCB0byBhIHZhbHVlIGNoYW5nZSAqL1xuICAgIHB1YmxpYyBvblZhbHVlQ2hhbmdlOiBGdW5jdGlvbjtcbiAgICAvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgYnkgdGhpcyBVSUVsZW1lbnQgd2hlbiB2YWx1ZSBjaGFuZ2VzICovXG4gICAgcHVibGljIG9uVmFsdWVDaGFuZ2VFdmVudElkOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMiwgaW5pdFZhbHVlOiBudW1iZXIpe1xuICAgICAgICBzdXBlcihwb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGluaXRWYWx1ZTtcbiAgICAgICAgdGhpcy5uaWJDb2xvciA9IENvbG9yLlJFRDtcbiAgICAgICAgdGhpcy5zbGlkZXJDb2xvciA9IENvbG9yLkJMQUNLO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xuICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XG4gICAgICAgIHRoaXMubmliU2l6ZSA9IG5ldyBWZWMyKDEwLCAyMCk7XG5cbiAgICAgICAgLy8gU2V0IGEgZGVmYXVsdCBzaXplXG4gICAgICAgIHRoaXMuc2l6ZS5zZXQoMjAwLCAyMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBzbGlkZXJcbiAgICAgKi9cbiAgICBnZXRWYWx1ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICAvKiogQSBtZXRob2QgY2FsbGVkIGluIHJlc3BvbnNlIHRvIHRoZSB2YWx1ZSBjaGFuZ2luZyAqL1xuICAgIHByb3RlY3RlZCB2YWx1ZUNoYW5nZWQoKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMub25WYWx1ZUNoYW5nZSl7XG4gICAgICAgICAgICB0aGlzLm9uVmFsdWVDaGFuZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLm9uVmFsdWVDaGFuZ2VFdmVudElkKXtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5vblZhbHVlQ2hhbmdlRXZlbnRJZCwge3RhcmdldDogdGhpcywgdmFsdWU6IHRoaXMudmFsdWV9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICBpZih0aGlzLmlzQ2xpY2tlZCl7XG4gICAgICAgICAgICBsZXQgdmFsID0gTWF0aFV0aWxzLmludkxlcnAodGhpcy5wb3NpdGlvbi54IC0gdGhpcy5zaXplLngvMiwgdGhpcy5wb3NpdGlvbi54ICsgdGhpcy5zaXplLngvMiwgSW5wdXQuZ2V0TW91c2VQb3NpdGlvbigpLngpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IE1hdGhVdGlscy5jbGFtcDAxKHZhbCk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuL0xhYmVsXCI7XG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uLy4uL0lucHV0L0lucHV0XCI7XG5cbi8qKiBBIHRleHQgaW5wdXQgVUlFbGVtZW50ICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0SW5wdXQgZXh0ZW5kcyBMYWJlbCB7XG4gICAgLyoqIEEgZmxhZyB0aGUgcmVwcmVzZW50cyB3aGV0aGVyIHRoZSB1c2VyIGNhbiB0eXBlIGluIHRoaXMgVGV4dElucHV0ICovXG4gICAgZm9jdXNlZDogYm9vbGVhbjtcbiAgICAvKiogVGhlIHBvc2l0aW9uIG9mIHRoZSBjdXJzb3IgaW4gdGhpcyBUZXh0SW5wdXQgKi9cbiAgICBjdXJzb3JDb3VudGVyOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMil7XG4gICAgICAgIHN1cGVyKHBvc2l0aW9uLCBcIlwiKTtcblxuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3JDb3VudGVyID0gMDtcblxuICAgICAgICAvLyBHaXZlIGEgZGVmYXVsdCBzaXplIHRvIHRoZSB4IG9ubHlcbiAgICAgICAgdGhpcy5zaXplLnNldCgyMDAsIHRoaXMuZm9udFNpemUpO1xuICAgICAgICB0aGlzLmhBbGlnbiA9IFwibGVmdFwiO1xuXG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBDb2xvci5CTEFDSztcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5XSElURTtcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgaWYoSW5wdXQuaXNNb3VzZUp1c3RQcmVzc2VkKCkpe1xuXHRcdFx0bGV0IGNsaWNrUG9zID0gSW5wdXQuZ2V0TW91c2VQcmVzc1Bvc2l0aW9uKCk7XG5cdFx0XHRpZih0aGlzLmNvbnRhaW5zKGNsaWNrUG9zLngsIGNsaWNrUG9zLnkpKXtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yQ291bnRlciA9IDMwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuZm9jdXNlZCl7XG4gICAgICAgICAgICBsZXQga2V5cyA9IElucHV0LmdldEtleXNKdXN0UHJlc3NlZCgpO1xuICAgICAgICAgICAgbGV0IG51bXMgPSBcIjEyMzQ1Njc4OTBcIjtcbiAgICAgICAgICAgIGxldCBzcGVjaWFsQ2hhcnMgPSBcImB+IUAjJCVeJiooKS1fPStbe119XFxcXHw7OidcXFwiLDwuPi8/XCI7XG4gICAgICAgICAgICBsZXQgbGV0dGVycyA9IFwicXdlcnR5dWlvcGFzZGZnaGprbHp4Y3Zibm1cIjtcbiAgICAgICAgICAgIGxldCBtYXNrID0gbnVtcyArIHNwZWNpYWxDaGFycyArIGxldHRlcnM7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5maWx0ZXIoa2V5ID0+IG1hc2suaW5jbHVkZXMoa2V5KSk7XG4gICAgICAgICAgICBsZXQgc2hpZnRQcmVzc2VkID0gSW5wdXQuaXNLZXlQcmVzc2VkKFwic2hpZnRcIik7XG4gICAgICAgICAgICBsZXQgYmFja3NwYWNlUHJlc3NlZCA9IElucHV0LmlzS2V5SnVzdFByZXNzZWQoXCJiYWNrc3BhY2VcIik7XG4gICAgICAgICAgICBsZXQgc3BhY2VQcmVzc2VkID0gSW5wdXQuaXNLZXlKdXN0UHJlc3NlZChcInNwYWNlXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihiYWNrc3BhY2VQcmVzc2VkKXtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc3Vic3RyaW5nKDAsIHRoaXMudGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihzcGFjZVByZXNzZWQpe1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dCArPSBcIiBcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZihrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZihzaGlmdFByZXNzZWQpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0ga2V5c1swXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dCArPSBrZXlzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0iLCJleHBvcnQgZW51bSBVSUVsZW1lbnRUeXBlIHtcblx0QlVUVE9OID0gXCJCVVRUT05cIixcblx0TEFCRUwgPSBcIkxBQkVMXCIsXG5cdFNMSURFUiA9IFwiU0xJREVSXCIsXG5cdFRFWFRfSU5QVVQgPSBcIlRFWFRJTlBVVFwiXG59IiwiaW1wb3J0IE5hdmlnYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvTmF2aWdhYmxlXCI7XG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi9OYXZpZ2F0aW9uUGF0aFwiO1xuXG4vKipcbiAqIFRoZSBtYW5hZ2VyIGNsYXNzIGZvciBuYXZpZ2F0aW9uLlxuICogSGFuZGxlcyBhbGwgbmF2aWdhYmxlIGVudGl0aWVzLCBzdWNoIGFuZCBhbGxvd3MgdGhlbSB0byBiZSBhY2Nlc3NlZCBieSBvdXRzaWRlIHN5c3RlbXMgYnkgcmVxdWVzdGluZyBhIHBhdGhcbiAqIGZyb20gb25lIHBvc2l0aW9uIHRvIGFub3RoZXIuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRpb25NYW5hZ2VyIHtcblx0LyoqIFRoZSBsaXN0IG9mIGFsbCBuYXZpZ2FibGUgZW50aXRpZXMgKi9cblx0cHJvdGVjdGVkIG5hdmlnYWJsZUVudGl0aWVzOiBNYXA8TmF2aWdhYmxlPjtcblxuXHRjb25zdHJ1Y3Rvcigpe1xuXHRcdHRoaXMubmF2aWdhYmxlRW50aXRpZXMgPSBuZXcgTWFwKCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIG5hdmlnYWJsZSBlbnRpdHkgdG8gdGhlIE5hdmlnYXRpb25NYW5hZ2VyXG5cdCAqIEBwYXJhbSBuYXZOYW1lIFRoZSBuYW1lIG9mIHRoZSBuYXZpZ2FibGUgZW50aXRyeVxuXHQgKiBAcGFyYW0gbmF2IFRoZSBhY3R1YWwgTmF2aWdhYmxlIGluc3RhbmNlXG5cdCAqL1xuXHRhZGROYXZpZ2FibGVFbnRpdHkobmF2TmFtZTogc3RyaW5nLCBuYXY6IE5hdmlnYWJsZSk6IHZvaWQge1xuXHRcdHRoaXMubmF2aWdhYmxlRW50aXRpZXMuYWRkKG5hdk5hbWUsIG5hdik7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhIHBhdGggZnJvbWUgb25lIHBvaW50IHRvIGFub3RoZXIgdXNpbmcgYSBzcGVjaWZpZWQgTmF2aWdhYmxlIG9iamVjdFxuXHQgKiBAcGFyYW0gbmF2TmFtZSBUaGUgbmFtZSBvZiB0aGUgcmVnaXN0ZXJlZCBOYXZpZ2FibGUgb2JqZWN0XG5cdCAqIEBwYXJhbSBmcm9tUG9zaXRpb24gVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIG5hdmlnYXRpb25cblx0ICogQHBhcmFtIHRvUG9zaXRpb24gVGhlIGVuZGluZyBwb3NpdGlvbiBvZiBOYXZpZ2F0aW9uXG5cdCAqIEBwYXJhbSBkaXJlY3QgSWYgdHJ1ZSwgZ28gZGlyZWN0IGZyb20gZnJvbVBvc2l0aW9uIHRvIHRvUG9zaXRpb24sIGRvbid0IHVzZSBOYXZNZXNoXG5cdCAqIEByZXR1cm5zIEEgTmF2aWdhdGlvblBhdGggY29udGFpbmluZyB0aGUgcm91dGUgdG8gdGFrZSBvdmVyIHRoZSBOYXZpZ2FibGUgZW50aXR5IHRvIGdldCBiZXR3ZWVuIHRoZSBwcm92aWRlZCBwb3NpdGlvbnMuXG5cdCAqL1xuXHRnZXRQYXRoKG5hdk5hbWU6IHN0cmluZywgZnJvbVBvc2l0aW9uOiBWZWMyLCB0b1Bvc2l0aW9uOiBWZWMyLCBkaXJlY3Q/OiBib29sZWFuKTogTmF2aWdhdGlvblBhdGgge1xuXHRcdGxldCBuYXYgPSB0aGlzLm5hdmlnYWJsZUVudGl0aWVzLmdldChuYXZOYW1lKTtcblx0XHRyZXR1cm4gbmF2LmdldE5hdmlnYXRpb25QYXRoKGZyb21Qb3NpdGlvbi5jbG9uZSgpLCB0b1Bvc2l0aW9uLmNsb25lKCksIGRpcmVjdCk7XG5cdH1cbn0iLCJpbXBvcnQgU3RhY2sgZnJvbSBcIi4uL0RhdGFUeXBlcy9TdGFja1wiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XG5cbi8qKlxuICogQSBwYXRoIHRoYXQgQUlzIGNhbiBmb2xsb3cuIFVzZXMgZmluaXNoTW92ZSgpIGluIFBoeXNpY2FsIHRvIGRldGVybWluZSBwcm9ncmVzcyBvbiB0aGUgcm91dGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdGlvblBhdGgge1xuXHQvKiogVGhlIG5hdmlnYXRpb24gcGF0aCwgc3RvcmVkIGFzIGEgc3RhY2sgb2YgbmV4dCBwb3NpdGlvbnMgKi9cblx0cHJvdGVjdGVkIHBhdGg6IFN0YWNrPFZlYzI+O1xuXHQvKiogVGhlIGN1cnJlbnQgZGlyZWN0aW9uIG9mIG1vdmVtZW50ICovXG5cdHByb3RlY3RlZCBjdXJyZW50TW92ZURpcmVjdGlvbjogVmVjMjtcblx0LyoqIFRoZSBkaXN0YW5jZSBhIG5vZGUgbXVzdCBiZSB0byBhIHBvaW50IHRvIGNvbnNpZGVyIGl0IGFzIGhhdmluZyBhcnJpdmVkICovXG5cdHByb3RlY3RlZCBkaXN0YW5jZVRocmVzaG9sZDogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IE5hdmlnYXRpb25QYXRoXG5cdCAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIG9mIG5vZGVzIHRvIHRha2Vcblx0ICovXG5cdGNvbnN0cnVjdG9yKHBhdGg6IFN0YWNrPFZlYzI+KXtcblx0XHR0aGlzLnBhdGggPSBwYXRoO1xuXHRcdHRoaXMuY3VycmVudE1vdmVEaXJlY3Rpb24gPSBWZWMyLlpFUk87XG5cdFx0dGhpcy5kaXN0YW5jZVRocmVzaG9sZCA9IDQ7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc3RhdHVzIG9mIG5hdmlnYXRpb24gYWxvbmcgdGhpcyBOYXZpZ2F0aW9uUGF0aFxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBub2RlIGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHBhdGgsIGZhbHNlIG90aGVyd2lzZVxuXHQgKi9cblx0aXNEb25lKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLnBhdGguaXNFbXB0eSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIG1vdmVtZW50IGRpcmVjdGlvbiBpbiB0aGUgY3VycmVudCBwb3NpdGlvbiBhbG9uZyB0aGUgcGF0aFxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBtb3ZlIGFsb25nIHRoZSBwYXRoXG5cdCAqIEByZXR1cm5zIFRoZSBtb3ZlbWVudCBkaXJlY3Rpb24gYXMgYSBWZWMyXG5cdCAqL1xuXHRnZXRNb3ZlRGlyZWN0aW9uKG5vZGU6IEdhbWVOb2RlKTogVmVjMiB7XG5cdFx0Ly8gUmV0dXJuIGRpcmVjdGlvbiB0byBuZXh0IHBvaW50IGluIHRoZSBuYXZcblx0XHRyZXR1cm4gbm9kZS5wb3NpdGlvbi5kaXJUbyh0aGlzLnBhdGgucGVlaygpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoaXMgTmF2aWdhdGlvblBhdGggdG8gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIEdhbWVOb2RlXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIG1vdmluZyBhbG9uZyB0aGUgcGF0aFxuXHQgKi9cblx0aGFuZGxlUGF0aFByb2dyZXNzKG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XG5cdFx0aWYobm9kZS5wb3NpdGlvbi5kaXN0YW5jZVNxVG8odGhpcy5wYXRoLnBlZWsoKSkgPCB0aGlzLmRpc3RhbmNlVGhyZXNob2xkKnRoaXMuZGlzdGFuY2VUaHJlc2hvbGQpe1xuXHRcdFx0Ly8gV2UndmUgcmVhY2hlZCBvdXIgbm9kZSwgbW92ZSBvbiB0byB0aGUgbmV4dCBkZXN0aW5hdGlvblxuXHRcdFx0dGhpcy5wYXRoLnBvcCgpO1xuXHRcdH1cblx0fVxuXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMucGF0aC50b1N0cmluZygpXG5cdH1cbn0iLCJpbXBvcnQgUG9zaXRpb25HcmFwaCBmcm9tIFwiLi4vRGF0YVR5cGVzL0dyYXBocy9Qb3NpdGlvbkdyYXBoXCI7XG5pbXBvcnQgTmF2aWdhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9OYXZpZ2FibGVcIjtcbmltcG9ydCBTdGFjayBmcm9tIFwiLi4vRGF0YVR5cGVzL1N0YWNrXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBHcmFwaFV0aWxzIGZyb20gXCIuLi9VdGlscy9HcmFwaFV0aWxzXCI7XG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4vTmF2aWdhdGlvblBhdGhcIjtcblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBhIE5hdm1lc2guIE5hdm1lc2hlcyBhcmUgZ3JhcGhzIGluIHRoZSBnYW1lIHdvcmxkIGFsb25nIHdoaWNoIG5vZGVzIGNhbiBtb3ZlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZtZXNoIGltcGxlbWVudHMgTmF2aWdhYmxlIHtcblx0LyoqIFRoZSBncmFwaCBvZiBwb2ludHMgaW4gdGhlIE5hdk1lc2ggKi9cblx0cHJvdGVjdGVkIGdyYXBoOiBQb3NpdGlvbkdyYXBoO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IE5hdm1lc2ggZnJvbSB0aGUgcG9pbnRzIGluIHRoZSBzcGVlY2lmaWVkIGdyYXBoXG5cdCAqIEBwYXJhbSBncmFwaCBUaGUgZ3JhcGggdG8gY29uc3RydWN0IGEgbmF2bWVzaCBmcm9tXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihncmFwaDogUG9zaXRpb25HcmFwaCl7XG5cdFx0dGhpcy5ncmFwaCA9IGdyYXBoO1xuXHR9XG5cblx0Ly8gQGltcGxlbWVudGVkXG5cdGdldE5hdmlnYXRpb25QYXRoKGZyb21Qb3NpdGlvbjogVmVjMiwgdG9Qb3NpdGlvbjogVmVjMiwgZGlyZWN0OiBib29sZWFuKTogTmF2aWdhdGlvblBhdGgge1xuXHRcdGxldCBzdGFydCA9IHRoaXMuZ2V0Q2xvc2VzdE5vZGUoZnJvbVBvc2l0aW9uKTtcblx0XHRsZXQgZW5kID0gdGhpcy5nZXRDbG9zZXN0Tm9kZSh0b1Bvc2l0aW9uKTtcblxuXHRcdGxldCBwYXRoU3RhY2sgPSBuZXcgU3RhY2s8VmVjMj4odGhpcy5ncmFwaC5udW1WZXJ0aWNlcyk7XG5cdFx0XG5cdFx0Ly8gUHVzaCB0aGUgZmluYWwgcG9zaXRpb24gYW5kIHRoZSBmaW5hbCBwb3NpdGlvbiBpbiB0aGUgZ3JhcGhcblx0XHRwYXRoU3RhY2sucHVzaCh0b1Bvc2l0aW9uLmNsb25lKCkpO1xuXG5cdFx0aWYgKGRpcmVjdCkge1xuXHRcdFx0cmV0dXJuIG5ldyBOYXZpZ2F0aW9uUGF0aChwYXRoU3RhY2spO1xuXHRcdH1cblxuXHRcdHBhdGhTdGFjay5wdXNoKHRoaXMuZ3JhcGgucG9zaXRpb25zW2VuZF0pO1xuXG5cdFx0bGV0IHBhcmVudCA9IEdyYXBoVXRpbHMuZGppa3N0cmEodGhpcy5ncmFwaCwgc3RhcnQpO1xuXG5cdFx0Ly8gQWRkIGFsbCBwYXJlbnRzIGFsb25nIHRoZSBwYXRoXG5cdFx0bGV0IGkgPSBlbmQ7XG5cdFx0d2hpbGUocGFyZW50W2ldICE9PSAtMSl7XG5cdFx0XHRwYXRoU3RhY2sucHVzaCh0aGlzLmdyYXBoLnBvc2l0aW9uc1twYXJlbnRbaV1dKTtcblx0XHRcdGkgPSBwYXJlbnRbaV07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBOYXZpZ2F0aW9uUGF0aChwYXRoU3RhY2spO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGNsb3Nlc3Qgbm9kZSBpbiB0aGlzIE5hdm1lc2ggdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuXHQgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIHF1ZXJ5XG5cdCAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBub2RlIGluIHRoZSBOYXZtZXNoIHRvIHRoZSBwb3NpdGlvblxuXHQgKi9cblx0cHJvdGVjdGVkIGdldENsb3Nlc3ROb2RlKHBvc2l0aW9uOiBWZWMyKTogbnVtYmVyIHtcblx0XHRsZXQgbiA9IHRoaXMuZ3JhcGgubnVtVmVydGljZXM7XG5cdFx0bGV0IGkgPSAxO1xuXHRcdGxldCBpbmRleCA9IDA7XG5cdFx0bGV0IGRpc3QgPSBwb3NpdGlvbi5kaXN0YW5jZVNxVG8odGhpcy5ncmFwaC5wb3NpdGlvbnNbMF0pO1xuXHRcdHdoaWxlKGkgPCBuKXtcblx0XHRcdGxldCBkID0gcG9zaXRpb24uZGlzdGFuY2VTcVRvKHRoaXMuZ3JhcGgucG9zaXRpb25zW2ldKTtcblx0XHRcdGlmKGQgPCBkaXN0KXtcblx0XHRcdFx0ZGlzdCA9IGQ7XG5cdFx0XHRcdGluZGV4ID0gaTtcblx0XHRcdH1cblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaW5kZXg7XG5cdH1cbn0iLCJpbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgUGh5c2ljYWwgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1BoeXNpY2FsXCI7XG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xuaW1wb3J0IFBoeXNpY3NNYW5hZ2VyIGZyb20gXCIuL1BoeXNpY3NNYW5hZ2VyXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcbmltcG9ydCBBcmVhQ29sbGlzaW9uIGZyb20gXCIuLi9EYXRhVHlwZXMvUGh5c2ljcy9BcmVhQ29sbGlzaW9uXCI7XG5pbXBvcnQgVW5pcXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VbmlxdWVcIjtcblxuLyoqXG4gKiBBTEdPUklUSE06XG4gKiBcdEluIGFuIGVmZm9ydCB0byBrZWVwIHRoaW5ncyBzaW1wbGUgYW5kIHdvcmtpbmcgZWZmZWN0aXZlbHksIGVhY2ggZHluYW1pYyBub2RlIHdpbGwgcmVzb2x2ZSBpdHNcbiAqIFx0Y29sbGlzaW9ucyBjb25zaWRlcmluZyB0aGUgcmVzdCBvZiB0aGUgd29ybGQgYXMgc3RhdGljLlxuICogXG4gKiBcdENvbGxpc2lvbiBkZXRlY3Rpbmcgd2lsbCBoYXBwZW4gZmlyc3QuIFRoaXMgY2FuIGJlIGNvbnNpZGVyZWQgYSBicm9hZCBwaGFzZSwgYnV0IGl0IGlzIG5vdCBlc3BlY2lhbGx5XG4gKiBcdGVmZmljaWVudCwgYXMgaXQgZG9lcyBub3QgbmVlZCB0byBiZSBmb3IgdGhpcyBnYW1lIGVuZ2luZS4gRXZlcnkgZHluYW1pYyBub2RlIGlzIGNoZWNrZWQgYWdhaW5zdCBldmVyeVxuICogXHRvdGhlciBub2RlIGZvciBjb2xsaXNpb24gYXJlYS4gSWYgY29sbGlzaW9uIGFyZWEgaXMgbm9uLXplcm8gKG1lYW5pbmcgdGhlIGN1cnJlbnQgbm9kZSBzd2VlcHMgaW50byBhbm90aGVyKSxcbiAqIFx0aXQgaXMgYWRkZWQgdG8gYSBsaXN0IG9mIGhpdHMuXG4gKiBcbiAqIFx0SU5JVElBTElaQVRJT046XG4gKiBcdFx0LSBQaHlzaWNzIGNvbnN0YW50cyBhcmUgcmVzZXRcbiAqIFx0XHQtIFN3ZXB0IHNoYXBlcyBhcmUgcmVjYWxjdWxhdGVkLiBJZiBhIG5vZGUgaXNuJ3QgbW92aW5nLCBpdCBpcyBza2lwcGVkLlxuICogXG4gKiBcdENPTExJU0lPTiBERVRFQ1RJT046XG4gKiBcdFx0LSBGb3IgYSBub2RlLCBjb2xsaXNpb24gYXJlYSB3aWxsIGJlIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIHN3ZXB0IEFBQkIgb2YgdGhlIG5vZGUgYWdhaW5zdCBldmVyeSBvdGhlciBBQUJCIGluIGEgc3RhdGljIHN0YXRlXG4gKiBcdFx0LSBUaGVzZSBjb2xsaXNpb25zIHdpbGwgYmUgc29ydGVkIGJ5IGFyZWEgaW4gZGVzY2VuZGluZyBvcmRlclxuICogXHRcbiAqIFx0Q09MTElTSU9OIFJFU09MVVRJT046XG4gKiBcdFx0LSBGb3IgZWFjaCBoaXQsIHRpbWUgb2YgY29sbGlzaW9uIGlzIGNhbGN1bGF0ZWQgdXNpbmcgYSBzd2VwdCBsaW5lIHRocm91Z2ggdGhlIEFBQkIgb2YgdGhlIHN0YXRpYyBub2RlIGV4cGFuZGVkXG4gKiBcdFx0XHR3aXRoIG1pbmtvd3NraSBzdW1zIChkaXNjcmV0ZWx5LCBidXQgdGhlIGNvbmNlcHQgaXMgdGhlcmUpXG4gKiBcdFx0LSBUaGUgY29sbGlzaW9uIGlzIHJlc29sdmVkIGJhc2VkIG9uIHRoZSBuZWFyIHRpbWUgb2YgdGhlIGNvbGxpc2lvbiAoZnJvbSBtZXRob2Qgb2Ygc2VwYXJhdGVkIGF4ZXMpXG4gKiBcdFx0XHQtIFggaXMgcmVzb2x2ZWQgYnkgbmVhciB4LCBZIGJ5IG5lYXIgeS5cbiAqIFx0XHRcdC0gVGhlcmUgaXMgc29tZSBmdWRnaW5nIHRvIGFsbG93IGZvciBzbGlkaW5nIGFsb25nIHdhbGxzIG9mIHNlcGFyYXRlIGNvbGxpZGVycy4gU29ydGluZyBieSBhcmVhIGFsc28gaGVscHMgd2l0aCB0aGlzLlxuICogXHRcdFx0LSBDb3JuZXIgdG8gY29ybmVyIGNvbGxpc2lvbnMgYXJlIHJlc29sdmUgdG8gZmF2b3IgeC1tb3ZlbWVudC4gVGhpcyBpcyBpbiBjb25zaWRlcmF0aW9uIG9mIHBsYXRmb3JtZXJzLCB0byBnaXZlXG4gKiBcdFx0XHRcdHRoZSBwbGF5ZXIgc29tZSBoZWxwIHdpdGgganVtcHNcbiAqIFxuICogXHRQcm9zOlxuICogXHRcdC0gRXZlcnl0aGluZyBoYXBwZW5zIHdpdGggYSBjb25zaXN0ZW50IHRpbWUuIFRoZXJlIGlzIGEgZGlzdGluY3QgYmVmb3JlIGFuZCBhZnRlciBmb3IgZWFjaCByZXNvbHV0aW9uLlxuICogXHRcdC0gTm8gYmFjay10cmFja2luZyBuZWVkcyB0byBiZSBkb25lLiBPbmNlIHdlIHJlc29sdmUgYSBub2RlLCBpdCBpcyBkZWZpbml0aXZlbHkgcmVzb2x2ZWQuXG4gKiBcdFxuICogXHRDb25zOlxuICogXHRcdC0gTm9kZXMgdGhhdCBhcmUgcHJvY2Vzc2VkIGVhcmx5IGhhdmUgbW92ZW1lbnQgcHJpb3JpdHkgb3ZlciBvdGhlciBub2Rlcy4gVGhpcyBjYW4gbGVhZCB0byBzb21lIHVuZGVzaXJhYmxlIGludGVyYWN0aW9ucy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNQaHlzaWNzTWFuYWdlciBleHRlbmRzIFBoeXNpY3NNYW5hZ2VyIHtcblxuXHQvKiogVGhlIGFycmF5IG9mIHN0YXRpYyBub2RlcyAqL1xuXHRwcm90ZWN0ZWQgc3RhdGljTm9kZXM6IEFycmF5PFBoeXNpY2FsPjtcblxuXHQvKiogVGhlIGFycmF5IG9mIGR5bmFtaWMgbm9kZXMgKi9cblx0cHJvdGVjdGVkIGR5bmFtaWNOb2RlczogQXJyYXk8UGh5c2ljYWw+O1xuXG5cdC8qKiBUaGUgYXJyYXkgb2YgdGlsZW1hcHMgKi9cblx0cHJvdGVjdGVkIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPjtcblxuXHQvKiogQW4gYXJyYXkgb2YgdGhlIGNvbGxpc2lvbiBtYXNrcyBmb3IgZWFjaCBncm91cCAqL1xuXHRwcm90ZWN0ZWQgY29sbGlzaW9uTWFza3M6IEFycmF5PG51bWJlcj47XG5cblx0Y29uc3RydWN0b3Iob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pil7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnN0YXRpY05vZGVzID0gbmV3IEFycmF5KCk7XG5cdFx0dGhpcy5keW5hbWljTm9kZXMgPSBuZXcgQXJyYXkoKTtcblx0XHR0aGlzLnRpbGVtYXBzID0gbmV3IEFycmF5KCk7XG5cdFx0dGhpcy5jb2xsaXNpb25NYXNrcyA9IG5ldyBBcnJheSgzMik7XG5cblx0XHQvLyBQYXJzZSBvcHRpb25zXG5cdFx0dGhpcy5wYXJzZU9wdGlvbnMob3B0aW9ucyk7XG5cdH1cblxuXHQvKipcblx0ICogUGFyc2VzIHRoZSBvcHRpb25zIGZvciBjb25zdHJ1Y3RpbmcgdGhlIHBoeXNpY3MgbWFuYWdlclxuXHQgKiBAcGFyYW0gb3B0aW9ucyBBIHJlY29yZCBvZiBvcHRpb25zXG5cdCAqL1xuXHRwcm90ZWN0ZWQgcGFyc2VPcHRpb25zKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcblx0XHRpZihvcHRpb25zLmdyb3VwTmFtZXMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmNvbGxpc2lvbnMgIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRmb3IobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5ncm91cE5hbWVzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0bGV0IGdyb3VwID0gb3B0aW9ucy5ncm91cE5hbWVzW2ldO1xuXG5cdFx0XHRcdC8vIFJlZ2lzdGVyIHRoZSBncm91cCBuYW1lIGFuZCBudW1iZXJcblx0XHRcdFx0dGhpcy5ncm91cE5hbWVzW2ldID0gZ3JvdXA7XG5cblx0XHRcdFx0dGhpcy5ncm91cE1hcC5zZXQoZ3JvdXAsIDEgPDwgaSk7XG5cblx0XHRcdFx0bGV0IGNvbGxpc2lvbk1hc2sgPSAwO1xuXG5cdFx0XHRcdGZvcihsZXQgaiA9IDA7IGogPCBvcHRpb25zLmNvbGxpc2lvbnNbaV0ubGVuZ3RoOyBqKyspe1xuXHRcdFx0XHRcdGlmKG9wdGlvbnMuY29sbGlzaW9uc1tpXVtqXSl7XG5cdFx0XHRcdFx0XHRjb2xsaXNpb25NYXNrIHw9IDEgPDwgajtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmNvbGxpc2lvbk1hc2tzW2ldID0gY29sbGlzaW9uTWFzaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0cmVnaXN0ZXJPYmplY3Qobm9kZTogUGh5c2ljYWwpOiB2b2lkIHtcblx0XHRpZihub2RlLmlzU3RhdGljKXtcblx0XHRcdC8vIFN0YXRpYyBhbmQgbm90IGNvbGxpZGFibGVcblx0XHRcdHRoaXMuc3RhdGljTm9kZXMucHVzaChub2RlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRHluYW1pYyBhbmQgbm90IGNvbGxpZGFibGVcblx0XHRcdHRoaXMuZHluYW1pY05vZGVzLnB1c2gobm9kZSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQG92ZXJyaWRlXG5cdGRlcmVnaXN0ZXJPYmplY3Qobm9kZTogUGh5c2ljYWwpOiB2b2lkIHtcblx0XHRpZihub2RlLmlzU3RhdGljKXtcblx0XHRcdC8vIFJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSBzdGF0aWMgbGlzdFxuXHRcdFx0Y29uc3QgaW5kZXggPSB0aGlzLnN0YXRpY05vZGVzLmluZGV4T2Yobm9kZSk7XG5cdFx0XHR0aGlzLnN0YXRpY05vZGVzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSBkeW5hbWljIGxpc3Rcblx0XHRcdGNvbnN0IGluZGV4ID0gdGhpcy5keW5hbWljTm9kZXMuaW5kZXhPZihub2RlKTtcblx0XHRcdHRoaXMuZHluYW1pY05vZGVzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQG92ZXJyaWRlXG5cdHJlZ2lzdGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XG5cdFx0dGhpcy50aWxlbWFwcy5wdXNoKHRpbGVtYXApO1xuXHR9XG5cblx0Ly8gQG92ZXJyaWRlXG5cdGRlcmVnaXN0ZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkIHtcblx0XHRjb25zdCBpbmRleCA9IHRoaXMudGlsZW1hcHMuaW5kZXhPZih0aWxlbWFwKTtcblx0XHR0aGlzLnRpbGVtYXBzLnNwbGljZShpbmRleCwgMSk7XG5cdH1cblxuXHQvLyBAb3ZlcnJpZGVcblx0dXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG5cdFx0Zm9yKGxldCBub2RlIG9mIHRoaXMuZHluYW1pY05vZGVzKXtcblx0XHRcdC8qLS0tLS0tLS0tLSBJTklUSUFMSVpBVElPTiBQSEFTRSAtLS0tLS0tLS0tKi9cblx0XHRcdC8vIENsZWFyIGZyYW1lIGRlcGVuZGVudCBib29sZWFuIHZhbHVlcyBmb3IgZWFjaCBub2RlXG5cdFx0XHRub2RlLm9uR3JvdW5kID0gZmFsc2U7XG5cdFx0XHRub2RlLm9uQ2VpbGluZyA9IGZhbHNlO1xuXHRcdFx0bm9kZS5vbldhbGwgPSBmYWxzZTtcblx0XHRcdG5vZGUuY29sbGlkZWRXaXRoVGlsZW1hcCA9IGZhbHNlO1xuXHRcdFx0bm9kZS5pc0NvbGxpZGluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBJZiB0aGlzIG5vZGUgaXMgbm90IGFjdGl2ZSwgZG9uJ3QgcHJvY2VzcyBpdFxuXHRcdFx0aWYoIW5vZGUuYWN0aXZlKXtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSB0aGUgc3dlcHQgc2hhcGVzIG9mIGVhY2ggbm9kZVxuXHRcdFx0aWYobm9kZS5tb3Zpbmcpe1xuXHRcdFx0XHQvLyBJZiBtb3ZpbmcsIHJlZmxlY3QgdGhhdCBpbiB0aGUgc3dlcHQgc2hhcGVcblx0XHRcdFx0bm9kZS5zd2VwdFJlY3Quc3dlZXAobm9kZS5fdmVsb2NpdHksIG5vZGUuY29sbGlzaW9uU2hhcGUuY2VudGVyLCBub2RlLmNvbGxpc2lvblNoYXBlLmhhbGZTaXplKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIElmIG91ciBub2RlIGlzbid0IG1vdmluZywgZG9uJ3QgYm90aGVyIHRvIGNoZWNrIGl0IChvdGhlciBub2RlcyB3aWxsIGRldGVjdCBpZiB0aGV5IHJ1biBpbnRvIGl0KVxuXHRcdFx0XHRub2RlLl92ZWxvY2l0eS56ZXJvKCk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvKi0tLS0tLS0tLS0gREVURUNUSU9OIFBIQVNFIC0tLS0tLS0tLS0qL1xuXHRcdFx0Ly8gR2F0aGVyIGEgc2V0IG9mIG92ZXJsYXBzXG5cdFx0XHRsZXQgb3ZlcmxhcHMgPSBuZXcgQXJyYXk8QXJlYUNvbGxpc2lvbj4oKTtcblxuXHRcdFx0bGV0IGdyb3VwSW5kZXggPSBub2RlLmdyb3VwID09PSAtMSA/IC0xIDogTWF0aC5sb2cyKG5vZGUuZ3JvdXApO1xuXG5cdFx0XHQvLyBGaXJzdCwgY2hlY2sgdGhpcyBub2RlIGFnYWluc3QgZXZlcnkgc3RhdGljIG5vZGUgKG9yZGVyIGRvZXNuJ3QgYWN0dWFsbHkgbWF0dGVyIGhlcmUsIHNpbmNlIHdlIHNvcnQgYW55d2F5cylcblx0XHRcdGZvcihsZXQgb3RoZXIgb2YgdGhpcy5zdGF0aWNOb2Rlcyl7XG5cdFx0XHRcdC8vIElnbm9yZSBpbmFjdGl2ZSBub2Rlc1xuXHRcdFx0XHRpZighb3RoZXIuYWN0aXZlKSBjb250aW51ZTtcblxuXHRcdFx0XHRsZXQgY29sbGlkZXIgPSBvdGhlci5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKTtcblx0XHRcdFx0bGV0IGFyZWEgPSBub2RlLnN3ZXB0UmVjdC5vdmVybGFwQXJlYShjb2xsaWRlcik7XG5cdFx0XHRcdGlmKGFyZWEgPiAwKXtcblx0XHRcdFx0XHQvLyBXZSBoYWQgYSBjb2xsaXNpb25cblx0XHRcdFx0XHRvdmVybGFwcy5wdXNoKG5ldyBBcmVhQ29sbGlzaW9uKGFyZWEsIGNvbGxpZGVyLCBvdGhlciwgXCJHYW1lTm9kZVwiLCBudWxsKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlbiwgY2hlY2sgaXQgYWdhaW5zdCBldmVyeSBkeW5hbWljIG5vZGVcblx0XHRcdGZvcihsZXQgb3RoZXIgb2YgdGhpcy5keW5hbWljTm9kZXMpe1xuXHRcdFx0XHQvLyBJZ25vcmUgb3Vyc2VsdmVzXG5cdFx0XHRcdGlmKG5vZGUgPT09IG90aGVyKSBjb250aW51ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgaW5hY3RpdmUgbm9kZXNcblx0XHRcdFx0aWYoIW90aGVyLmFjdGl2ZSkgY29udGludWU7XG5cblx0XHRcdFx0bGV0IGNvbGxpZGVyID0gb3RoZXIuY29sbGlzaW9uU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCk7XG5cdFx0XHRcdGxldCBhcmVhID0gbm9kZS5zd2VwdFJlY3Qub3ZlcmxhcEFyZWEoY29sbGlkZXIpO1xuXHRcdFx0XHRpZihhcmVhID4gMCl7XG5cdFx0XHRcdFx0Ly8gV2UgaGFkIGEgY29sbGlzaW9uXG5cdFx0XHRcdFx0b3ZlcmxhcHMucHVzaChuZXcgQXJlYUNvbGxpc2lvbihhcmVhLCBjb2xsaWRlciwgb3RoZXIsIFwiR2FtZU5vZGVcIiwgbnVsbCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExhc3RseSwgZ2F0aGVyIGEgc2V0IG9mIEFBQkJzIGZyb20gdGhlIHRpbGVtYXAuXG5cdFx0XHQvLyBUaGlzIHN0ZXAgaW52b2x2ZXMgdGhlIG1vc3QgZXh0cmEgd29yaywgc28gaXQgaXMgYWJzdHJhY3RlZCBpbnRvIGEgbWV0aG9kXG5cdFx0XHRmb3IobGV0IHRpbGVtYXAgb2YgdGhpcy50aWxlbWFwcyl7XG5cdFx0XHRcdC8vIElnbm9yZSBpbmFjdGl2ZSB0aWxlbWFwc1xuXHRcdFx0XHRpZighdGlsZW1hcC5hY3RpdmUpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGlmKHRpbGVtYXAgaW5zdGFuY2VvZiBPcnRob2dvbmFsVGlsZW1hcCl7XG5cdFx0XHRcdFx0dGhpcy5jb2xsaWRlV2l0aE9ydGhvZ29uYWxUaWxlbWFwKG5vZGUsIHRpbGVtYXAsIG92ZXJsYXBzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTb3J0IHRoZSBvdmVybGFwcyBieSBhcmVhXG5cdFx0XHRvdmVybGFwcyA9IG92ZXJsYXBzLnNvcnQoKGEsIGIpID0+IGIuYXJlYSAtIGEuYXJlYSk7XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2YgaGl0cyB0byB1c2UgbGF0ZXJcblx0XHRcdGxldCBoaXRzID0gW107XG5cblx0XHRcdC8qLS0tLS0tLS0tLSBSRVNPTFVUSU9OIFBIQVNFIC0tLS0tLS0tLS0qL1xuXHRcdFx0Ly8gRm9yIGV2ZXJ5IG92ZXJsYXAsIGRldGVybWluZSBpZiB3ZSBuZWVkIHRvIGNvbGxpZGUgd2l0aCBpdCBhbmQgd2hlblxuXHRcdFx0Zm9yKGxldCBvdmVybGFwIG9mIG92ZXJsYXBzKXtcblx0XHRcdFx0Ly8gSWdub3JlIG5vZGVzIHdlIGRvbid0IGludGVyYWN0IHdpdGhcblx0XHRcdFx0aWYoIGdyb3VwSW5kZXggIT09IC0xICYmIG92ZXJsYXAub3RoZXIuZ3JvdXAgIT09IC0xICYmICgodGhpcy5jb2xsaXNpb25NYXNrc1tncm91cEluZGV4XSAmIG92ZXJsYXAub3RoZXIuZ3JvdXApID09PSAwKSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdC8vIERvIGEgc3dlcHQgbGluZSB0ZXN0IG9uIHRoZSBzdGF0aWMgQUFCQiB3aXRoIHRoaXMgQUFCQiBzaXplIGFzIHBhZGRpbmcgKHRoaXMgaXMgYmFzaWNhbGx5IHVzaW5nIGEgbWlua293c2tpIHN1bSEpXG5cdFx0XHRcdC8vIFN0YXJ0IHRoZSBzd2VlcCBhdCB0aGUgcG9zaXRpb24gb2YgdGhpcyBub2RlIHdpdGggYSBkZWx0YSBvZiBfdmVsb2NpdHlcblx0XHRcdFx0Y29uc3QgcG9pbnQgPSBub2RlLmNvbGxpc2lvblNoYXBlLmNlbnRlcjtcblx0XHRcdFx0Y29uc3QgZGVsdGEgPSBub2RlLl92ZWxvY2l0eTtcblx0XHRcdFx0Y29uc3QgcGFkZGluZyA9IG5vZGUuY29sbGlzaW9uU2hhcGUuaGFsZlNpemU7XG5cdFx0XHRcdGNvbnN0IG90aGVyQUFCQiA9IG92ZXJsYXAuY29sbGlkZXI7XG5cblxuXHRcdFx0XHRjb25zdCBoaXQgPSBvdGhlckFBQkIuaW50ZXJzZWN0U2VnbWVudChub2RlLmNvbGxpc2lvblNoYXBlLmNlbnRlciwgbm9kZS5fdmVsb2NpdHksIG5vZGUuY29sbGlzaW9uU2hhcGUuaGFsZlNpemUpO1xuXG5cdFx0XHRcdG92ZXJsYXAuaGl0ID0gaGl0O1xuXG5cdFx0XHRcdGlmKGhpdCAhPT0gbnVsbCl7XG5cdFx0XHRcdFx0aGl0cy5wdXNoKGhpdCk7XG5cblx0XHRcdFx0XHQvLyBXZSBnb3QgYSBoaXQsIHJlc29sdmUgd2l0aCB0aGUgdGltZSBpbnNpZGUgb2YgdGhlIGhpdFxuXHRcdFx0XHRcdGxldCB0bmVhcnggPSBoaXQubmVhclRpbWVzLng7XG5cdFx0XHRcdFx0bGV0IHRuZWFyeSA9IGhpdC5uZWFyVGltZXMueTtcblxuXHRcdFx0XHRcdC8vIEFsbG93IGVkZ2UgY2xpcHBpbmcgKGVkZ2Ugb3ZlcmxhcHMgZG9uJ3QgY291bnQsIG9ubHkgYXJlYSBvdmVybGFwcylcblx0XHRcdFx0XHQvLyBJbXBvcnRhbnRseSBkb24ndCBhbGxvdyBib3RoIGNhc2VzIHRvIGJlIHRydWUuIFRoZW4gd2UgY2xpcCB0aHJvdWdoIGNvcm5lcnMuIEZhdm9yIHggdG8gaGVscCBwbGF5ZXJzIGxhbmQganVtcHNcblx0XHRcdFx0XHRpZih0bmVhcnggPCAxLjAgJiYgKHBvaW50LnkgPT09IG90aGVyQUFCQi50b3AgLSBwYWRkaW5nLnkgfHwgcG9pbnQueSA9PT0gb3RoZXJBQUJCLmJvdHRvbSArIHBhZGRpbmcueSkgJiYgZGVsdGEueCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0dG5lYXJ4ID0gMS4wO1xuXHRcdFx0XHRcdH0gZWxzZSBpZih0bmVhcnkgPCAxLjAgJiYgKHBvaW50LnggPT09IG90aGVyQUFCQi5sZWZ0IC0gcGFkZGluZy54IHx8IHBvaW50LnggPT09IG90aGVyQUFCQi5yaWdodCArIHBhZGRpbmcueCkgJiYgZGVsdGEueSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0dG5lYXJ5ID0gMS4wO1xuXHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdFx0aWYoaGl0Lm5lYXJUaW1lcy54ID49IDAgJiYgaGl0Lm5lYXJUaW1lcy54IDwgMSl7XG5cdFx0XHRcdFx0XHQvLyBBbnkgdGlsZW1hcCBvYmplY3RzIHRoYXQgbWFkZSBpdCBoZXJlIGFyZSBjb2xsaWRhYmxlXG5cdFx0XHRcdFx0XHRpZihvdmVybGFwLnR5cGUgPT09IFwiVGlsZW1hcFwiIHx8IG92ZXJsYXAub3RoZXIuaXNDb2xsaWRhYmxlKXtcblx0XHRcdFx0XHRcdFx0bm9kZS5fdmVsb2NpdHkueCA9IG5vZGUuX3ZlbG9jaXR5LnggKiB0bmVhcng7XG5cdFx0XHRcdFx0XHRcdG5vZGUuaXNDb2xsaWRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmKGhpdC5uZWFyVGltZXMueSA+PSAwICYmIGhpdC5uZWFyVGltZXMueSA8IDEpe1xuXHRcdFx0XHRcdFx0Ly8gQW55IHRpbGVtYXAgb2JqZWN0cyB0aGF0IG1hZGUgaXQgaGVyZSBhcmUgY29sbGlkYWJsZVxuXHRcdFx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09PSBcIlRpbGVtYXBcIiB8fCBvdmVybGFwLm90aGVyLmlzQ29sbGlkYWJsZSl7XG5cdFx0XHRcdFx0XHRcdG5vZGUuX3ZlbG9jaXR5LnkgPSBub2RlLl92ZWxvY2l0eS55ICogdG5lYXJ5O1xuXHRcdFx0XHRcdFx0XHRub2RlLmlzQ29sbGlkaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LyotLS0tLS0tLS0tIElORk9STUFUSU9OL1RSSUdHRVIgUEhBU0UgLS0tLS0tLS0tLSovXG5cdFx0XHQvLyBDaGVjayBpZiB3ZSBlbmRlZCB1cCBvbiB0aGUgZ3JvdW5kLCBjZWlsaW5nIG9yIHdhbGxcblx0XHRcdC8vIEFsc28gY2hlY2sgZm9yIHRyaWdnZXJzXG5cdFx0XHRmb3IobGV0IG92ZXJsYXAgb2Ygb3ZlcmxhcHMpe1xuXHRcdFx0XHQvLyBDaGVjayBmb3IgYSB0cmlnZ2VyLiBJZiB3ZSBjYXJlIGFib3V0IHRoZSB0cmlnZ2VyLCByZWFjdFxuXHRcdFx0XHRpZihvdmVybGFwLm90aGVyLmlzVHJpZ2dlciAmJiAob3ZlcmxhcC5vdGhlci50cmlnZ2VyTWFzayAmIG5vZGUuZ3JvdXApKXtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGJpdCB0aGF0IHRoaXMgZ3JvdXAgaXMgcmVwcmVzZW50ZWQgYnlcblx0XHRcdFx0XHRsZXQgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgubG9nMihub2RlLmdyb3VwKSk7XG5cblx0XHRcdFx0XHQvLyBFeHRyYWN0IHRoZSB0cmlnZ2VyRW50ZXIgZXZlbnQgbmFtZVxuXHRcdFx0XHRcdHRoaXMuZW1pdHRlci5maXJlRXZlbnQob3ZlcmxhcC5vdGhlci50cmlnZ2VyRW50ZXJzW2luZGV4XSwge1xuXHRcdFx0XHRcdFx0bm9kZTogKDxHYW1lTm9kZT5ub2RlKS5pZCxcblx0XHRcdFx0XHRcdG90aGVyOiAoPEdhbWVOb2RlPm92ZXJsYXAub3RoZXIpLmlkXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZ25vcmUgY29sbGlzaW9uIHNpZGVzIGZvciBub2RlcyB3ZSBkb24ndCBpbnRlcmFjdCB3aXRoXG5cdFx0XHRcdGlmKCBncm91cEluZGV4ICE9PSAtMSAmJiBvdmVybGFwLm90aGVyLmdyb3VwICE9PSAtMSAmJiAoKHRoaXMuY29sbGlzaW9uTWFza3NbZ3JvdXBJbmRleF0gJiBvdmVybGFwLm90aGVyLmdyb3VwKSA9PT0gMCkpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdC8vIE9ubHkgY2hlY2sgZm9yIGRpcmVjdGlvbiBpZiB0aGUgb3ZlcmxhcCB3YXMgY29sbGlkYWJsZVxuXHRcdFx0XHRpZihvdmVybGFwLnR5cGUgPT09IFwiVGlsZW1hcFwiIHx8IG92ZXJsYXAub3RoZXIuaXNDb2xsaWRhYmxlKXtcblx0XHRcdFx0XHRsZXQgY29sbGlzaW9uU2lkZSA9IG92ZXJsYXAuY29sbGlkZXIudG91Y2hlc0FBQkJXaXRob3V0Q29ybmVycyhub2RlLmNvbGxpc2lvblNoYXBlLmdldEJvdW5kaW5nUmVjdCgpKTtcblx0XHRcdFx0XHRpZihjb2xsaXNpb25TaWRlICE9PSBudWxsKXtcblx0XHRcdFx0XHRcdC8vIElmIHdlIHRvdWNoLCBub3QgaW5jbHVkaW5nIGNvcm5lciBjYXNlcywgY2hlY2sgdGhlIGNvbGxpc2lvbiBub3JtYWxcblx0XHRcdFx0XHRcdGlmKG92ZXJsYXAuaGl0ICE9PSBudWxsKXtcblx0XHRcdFx0XHRcdFx0Ly8gSWYgd2UgaGl0IGEgdGlsZW1hcCwga2VlcCB0cmFjayBvZiBpdFxuXHRcdFx0XHRcdFx0XHRpZihvdmVybGFwLnR5cGUgPT0gXCJUaWxlbWFwXCIpe1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUuY29sbGlkZWRXaXRoVGlsZW1hcCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZihjb2xsaXNpb25TaWRlLnkgPT09IC0xKXtcblx0XHRcdFx0XHRcdFx0XHQvLyBOb2RlIGlzIG9uIHRvcCBvZiBvdmVybGFwLCBzbyBvbkdyb3VuZFxuXHRcdFx0XHRcdFx0XHRcdG5vZGUub25Hcm91bmQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYoY29sbGlzaW9uU2lkZS55ID09PSAxKXtcblx0XHRcdFx0XHRcdFx0XHQvLyBOb2RlIGlzIG9uIGJvdHRvbSBvZiBvdmVybGFwLCBzbyBvbkNlaWxpbmdcblx0XHRcdFx0XHRcdFx0XHRub2RlLm9uQ2VpbGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTm9kZSB3YXNuJ3QgdG91Y2hpbmcgb24geSwgc28gaXQgaXMgdG91Y2hpbmcgb24geFxuXHRcdFx0XHRcdFx0XHRcdG5vZGUub25XYWxsID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBjb2xsaXNpb24gd2l0aCB0aGUgbm9kZSwgYW5kIG1vdmUgaXRcblx0XHRcdG5vZGUuZmluaXNoTW92ZSgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVzIGEgY29sbGlzaW9uIGJldHdlZW4gdGhpcyBub2RlIGFuZCBhbiBvcnRob2dvbmFsIHRpbGVtYXBcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGVcblx0ICogQHBhcmFtIHRpbGVtYXAgVGhlIHRpbGVtYXAgdGhlIG5vZGUgbWF5IGJlIGNvbGxpZGluZyB3aXRoXG5cdCAqIEBwYXJhbSBvdmVybGFwcyBUaGUgbGlzdCBvZiBvdmVybGFwc1xuXHQgKi9cblx0cHJvdGVjdGVkIGNvbGxpZGVXaXRoT3J0aG9nb25hbFRpbGVtYXAobm9kZTogUGh5c2ljYWwsIHRpbGVtYXA6IE9ydGhvZ29uYWxUaWxlbWFwLCBvdmVybGFwczogQXJyYXk8QXJlYUNvbGxpc2lvbj4pOiB2b2lkIHtcblx0XHQvLyBHZXQgdGhlIG1pbiBhbmQgbWF4IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdmluZyBub2RlXG5cdFx0bGV0IG1pbiA9IG5ldyBWZWMyKG5vZGUuc3dlcHRSZWN0LmxlZnQsIG5vZGUuc3dlcHRSZWN0LnRvcCk7XG5cdFx0bGV0IG1heCA9IG5ldyBWZWMyKG5vZGUuc3dlcHRSZWN0LnJpZ2h0LCBub2RlLnN3ZXB0UmVjdC5ib3R0b20pO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgbWluL21heCB4L3kgdG8gdGhlIG1pbiBhbmQgbWF4IHJvdy9jb2wgaW4gdGhlIHRpbGVtYXAgYXJyYXlcblx0XHRsZXQgbWluSW5kZXggPSB0aWxlbWFwLmdldENvbFJvd0F0KG1pbik7XG5cdFx0bGV0IG1heEluZGV4ID0gdGlsZW1hcC5nZXRDb2xSb3dBdChtYXgpO1xuXG5cdFx0bGV0IHRpbGVTaXplID0gdGlsZW1hcC5nZXRUaWxlU2l6ZSgpO1xuXG5cdFx0Ly8gTG9vcCBvdmVyIGFsbCBwb3NzaWJsZSB0aWxlcyAod2hpY2ggaXNuJ3QgbWFueSBpbiB0aGUgc2NvcGUgb2YgdGhlIHZlbG9jaXR5IHBlciBmcmFtZSlcblx0XHRmb3IobGV0IGNvbCA9IG1pbkluZGV4Lng7IGNvbCA8PSBtYXhJbmRleC54OyBjb2wrKyl7XG5cdFx0XHRmb3IobGV0IHJvdyA9IG1pbkluZGV4Lnk7IHJvdyA8PSBtYXhJbmRleC55OyByb3crKyl7XG5cdFx0XHRcdGlmKHRpbGVtYXAuaXNUaWxlQ29sbGlkYWJsZShjb2wsIHJvdykpe1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgcG9zaXRpb24gb2YgdGhpcyB0aWxlXG5cdFx0XHRcdFx0bGV0IHRpbGVQb3MgPSBuZXcgVmVjMihjb2wgKiB0aWxlU2l6ZS54ICsgdGlsZVNpemUueC8yLCByb3cgKiB0aWxlU2l6ZS55ICsgdGlsZVNpemUueS8yKTtcblxuXHRcdFx0XHRcdC8vIENyZWF0ZSBhIG5ldyBjb2xsaWRlciBmb3IgdGhpcyB0aWxlXG5cdFx0XHRcdFx0bGV0IGNvbGxpZGVyID0gbmV3IEFBQkIodGlsZVBvcywgdGlsZVNpemUuc2NhbGVkKDEvMikpO1xuXG5cdFx0XHRcdFx0Ly8gQ2FsY3VsYXRlIGNvbGxpc2lvbiBhcmVhIGJldHdlZW4gdGhlIG5vZGUgYW5kIHRoZSB0aWxlXG5cdFx0XHRcdFx0bGV0IGFyZWEgPSBub2RlLnN3ZXB0UmVjdC5vdmVybGFwQXJlYShjb2xsaWRlcik7XG5cdFx0XHRcdFx0aWYoYXJlYSA+IDApe1xuXHRcdFx0XHRcdFx0Ly8gV2UgaGFkIGEgY29sbGlzaW9uXG5cdFx0XHRcdFx0XHRvdmVybGFwcy5wdXNoKG5ldyBBcmVhQ29sbGlzaW9uKGFyZWEsIGNvbGxpZGVyLCB0aWxlbWFwLCBcIlRpbGVtYXBcIiwgbmV3IFZlYzIoY29sLCByb3cpKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uL0V2ZW50cy9FbWl0dGVyXCI7XG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XG5pbXBvcnQgUGh5c2ljYWwgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1BoeXNpY2FsXCI7XG5cbi8qKlxuICogQW4gYWJzdHJhY3QgcGh5c2ljcyBtYW5hZ2VyLlxuICogVGhpcyBjbGFzcyBleHBvc2VzIGZ1bmN0aW9ucyBmb3Igc3ViY2xhc3NlcyB0byBpbXBsZW1lbnQgdGhhdCBzaG91bGQgYWxsb3cgZm9yIGEgd29ya2luZyBwaHlzaWNzIHN5c3RlbSB0byBiZSBjcmVhdGVkLlxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBQaHlzaWNzTWFuYWdlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuXHQvKiogVGhlIGV2ZW50IHJlY2VpdmVyIGZvciB0aGUgcGh5c2ljcyBzeXN0ZW0gKi9cblx0cHJvdGVjdGVkIHJlY2VpdmVyOiBSZWNlaXZlcjtcblx0LyoqIFRoZSBldmVudCBlbWl0dGVyIGZvciB0aGUgcGh5c2ljcyBzeXN0ZW0gKi9cblx0cHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XG5cblx0LyoqIE1hcHMgbGF5ZXIgbmFtZXMgdG8gbnVtYmVycyAqL1xuXHRwcm90ZWN0ZWQgZ3JvdXBNYXA6IE1hcDxudW1iZXI+O1xuXG5cdC8qKiBNYXBzIGxheWVyIG51bWJlcnMgdG8gbmFtZXMgKi9cblx0cHJvdGVjdGVkIGdyb3VwTmFtZXM6IEFycmF5PHN0cmluZz47XG5cblx0LyoqIFRoZSBkZWZhdWx0IGdyb3VwIG5hbWUgKi9cblx0cHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBERUZBVUxUX0dST1VQOiBzdHJpbmcgPSBcIkRlZmF1bHRcIjtcblxuXHRjb25zdHJ1Y3Rvcigpe1xuXHRcdHRoaXMucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcblx0XHR0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuXG5cdFx0Ly8gVGhlIGNyZWF0aW9uIGFuZCBpbXBsZW1lbnRhdGlvbiBvZiBsYXllcnMgaXMgZGVmZXJyZWQgdG8gdGhlIHN1YmNsYXNzXG5cdFx0dGhpcy5ncm91cE1hcCA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLmdyb3VwTmFtZXMgPSBuZXcgQXJyYXkoKTtcblx0fVxuXG5cdGRlc3Ryb3koKTogdm9pZCB7XG5cdFx0dGhpcy5yZWNlaXZlci5kZXN0cm95KCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGEgZ2FtZW5vZGUgd2l0aCB0aGlzIHBoeXNpY3MgbWFuYWdlclxuXHQgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcmVnaXN0ZXJcblx0ICovXG5cdGFic3RyYWN0IHJlZ2lzdGVyT2JqZWN0KG9iamVjdDogUGh5c2ljYWwpOiB2b2lkO1xuXG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgcmVmZXJlbmNlcyB0byB0aGlzIG9iamVjdCBmcm9tIHRoZSBwaHlzaWNzIG1hbmFnZXJyXG5cdCAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdCB0byBkZXJlZ2lzdGVyXG5cdCAqL1xuXHRhYnN0cmFjdCBkZXJlZ2lzdGVyT2JqZWN0KG9iamVjdDogUGh5c2ljYWwpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYSB0aWxlbWFwIHdpdGggdGhpcyBwaHlzaWNzIG1hbmFnZXJcblx0ICogQHBhcmFtIHRpbGVtYXAgVGhlIHRpbGVtYXAgdG8gcmVnaXN0ZXJcblx0ICovXG5cdGFic3RyYWN0IHJlZ2lzdGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZDtcblxuXHQvKipcblx0ICogUmVtb3ZlcyByZWZlcmVuY2VzIHRvIHRoaXMgdGlsZW1hcCBmcm9tIHRoZSBwaHlzaWNzIG1hbmFnZXJyXG5cdCAqIEBwYXJhbSB0aWxlbWFwIFRoZSBvYmplY3QgdG8gZGVyZWdpc3RlclxuXHQgKi9cblx0YWJzdHJhY3QgZGVyZWdpc3RlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQ7XG5cblx0YWJzdHJhY3QgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZDtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgcGh5c2ljcyBsYXllciBvZiB0aGUgR2FtZU5vZGVcblx0ICogQHBhcmFtIG5vZGUgVGhlIEdhbWVOb2RlXG5cdCAqIEBwYXJhbSBncm91cCBUaGUgZ3JvdXAgdGhhdCB0aGUgR2FtZU5vZGUgc2hvdWxkIGJlIG9uXG5cdCAqL1xuXHRzZXRHcm91cChub2RlOiBQaHlzaWNhbCwgZ3JvdXA6IHN0cmluZyk6IHZvaWQge1xuXHRcdG5vZGUuZ3JvdXAgPSB0aGlzLmdyb3VwTWFwLmdldChncm91cCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0cmlldmVzIHRoZSBsYXllciBudW1iZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBuYW1lXG5cdCAqIEBwYXJhbSBsYXllciBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcblx0ICogQHJldHVybnMgVGhlIGxheWVyIG51bWJlciwgb3IgMCBpZiB0aGVyZSBpcyBub3QgYSBsYXllciB3aXRoIHRoYXQgbmFtZSByZWdpc3RlcmVkXG5cdCAqL1xuXHRnZXRHcm91cE51bWJlcihncm91cDogc3RyaW5nKTogbnVtYmVyIHtcblx0XHRpZih0aGlzLmdyb3VwTWFwLmhhcyhncm91cCkpe1xuXHRcdFx0cmV0dXJuIHRoaXMuZ3JvdXBNYXAuZ2V0KGdyb3VwKTtcblx0XHR9IGVsc2V7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhbGwgZ3JvdXAgbmFtZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBudW1iZXIgcHJvdmlkZWRcblx0ICogQHBhcmFtIGdyb3VwcyBBIG1hc2sgb2YgZ3JvdXBzXG5cdCAqIEByZXR1cm5zIEFsbCBncm91cHMgY29udGFpbmVkIGluIHRoZSBtYXNrXG5cdCAqL1xuXHRnZXRHcm91cE5hbWVzKGdyb3VwczogbnVtYmVyKTogQXJyYXk8c3RyaW5nPiB7XG5cdFx0aWYoZ3JvdXBzID09PSAtMSl7XG5cdFx0XHRyZXR1cm4gW1BoeXNpY3NNYW5hZ2VyLkRFRkFVTFRfR1JPVVBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgZyA9IDE7XG5cdFx0XHRsZXQgbmFtZXMgPSBbXTtcblxuXHRcdFx0Zm9yKGxldCBpID0gMDsgaSA8IDMyOyBpKyspe1xuXHRcdFx0XHRpZihnICYgZ3JvdXBzKXtcblx0XHRcdFx0XHQvLyBUaGlzIGdyb3VwIGlzIGluIHRoZSBncm91cHMgbnVtYmVyXG5cdFx0XHRcdFx0bmFtZXMucHVzaCh0aGlzLmdyb3VwTmFtZXNbaV0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2hpZnQgdGhlIGJpdCBvdmVyXG5cdFx0XHRcdGcgPSBnIDw8IDE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59IiwiaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50XCI7XG5pbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi4vRXZlbnRzL0V2ZW50UXVldWVcIjtcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFR5cGVcIjtcblxuLy8gQGlnbm9yZVBhZ2VcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjb3JkZXIge1xuXHRwcml2YXRlIHJlY2VpdmVyOiBSZWNlaXZlcjtcblx0cHJpdmF0ZSBsb2c6IFF1ZXVlPExvZ0l0ZW0+O1xuXHRwcml2YXRlIHJlY29yZGluZzogYm9vbGVhbjtcblx0cHJpdmF0ZSBldmVudFF1ZXVlOiBFdmVudFF1ZXVlO1xuXHRwcml2YXRlIGZyYW1lOiBudW1iZXI7XG5cdHByaXZhdGUgcGxheWluZzogYm9vbGVhbjtcblxuXHRjb25zdHJ1Y3Rvcigpe1xuXHRcdHRoaXMucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcblx0XHR0aGlzLmxvZyA9IG5ldyBRdWV1ZSgxMDAwKTtcblx0XHR0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xuXHRcdHRoaXMucGxheWluZyA9IGZhbHNlO1xuXHRcdHRoaXMuZnJhbWUgPSAwO1xuXG5cdFx0dGhpcy5ldmVudFF1ZXVlID0gRXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpO1xuXHRcdHRoaXMuZXZlbnRRdWV1ZS5zdWJzY3JpYmUodGhpcy5yZWNlaXZlciwgXCJhbGxcIik7XG5cdH1cblxuXHR1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcblx0XHRpZih0aGlzLnJlY29yZGluZyl7XG5cdFx0XHR0aGlzLmZyYW1lICs9IDE7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5wbGF5aW5nKXtcblx0XHRcdC8vIElmIHBsYXlpbmcsIGlnbm9yZSBldmVudHMsIGp1c3QgZmVlZCB0aGUgcmVjb3JkIHRvIHRoZSBldmVudCBxdWV1ZVxuXHRcdFx0dGhpcy5yZWNlaXZlci5pZ25vcmVFdmVudHMoKTtcblxuXHRcdFx0Lypcblx0XHRcdFx0V2hpbGUgdGhlcmUgaXMgYSBuZXh0IGl0ZW0sIGFuZCB3aGlsZSBpdCBzaG91bGQgb2NjdXIgaW4gdGhpcyBmcmFtZSxcblx0XHRcdFx0c2VuZCB0aGUgZXZlbnQuIGkuZS4sIHdoaWxlIGN1cnJlbnRfZnJhbWUgKiBjdXJyZW50X2RlbHRhX3QgaXMgZ3JlYXRlclxuXHRcdFx0XHR0aGFuIHJlY29yZGVkX2ZyYW1lICogcmVjb3JkZWRfZGVsdGFfdFxuXHRcdFx0Ki9cblx0XHRcdHdoaWxlKHRoaXMubG9nLmhhc0l0ZW1zKClcblx0XHRcdFx0XHQmJiB0aGlzLmxvZy5wZWVrTmV4dCgpLmZyYW1lICogdGhpcy5sb2cucGVla05leHQoKS5kZWx0YSA8IHRoaXMuZnJhbWUgKiBkZWx0YVQpe1xuXHRcdFx0XHRsZXQgZXZlbnQgPSB0aGlzLmxvZy5kZXF1ZXVlKCkuZXZlbnQ7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGV2ZW50KTtcblx0XHRcdFx0dGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGV2ZW50KTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIXRoaXMubG9nLmhhc0l0ZW1zKCkpe1xuXHRcdFx0XHR0aGlzLnBsYXlpbmcgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5mcmFtZSArPSAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBJZiBub3QgcGxheWluZywgaGFuZGxlIGV2ZW50c1xuXHRcdFx0d2hpbGUodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSl7XG5cdFx0XHRcdGxldCBldmVudCA9IHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XG5cblx0XHRcdFx0aWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5TVE9QX1JFQ09SRElORyl7XG5cdFx0XHRcdFx0dGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKHRoaXMucmVjb3JkaW5nKXtcblx0XHRcdFx0XHR0aGlzLmxvZy5lbnF1ZXVlKG5ldyBMb2dJdGVtKHRoaXMuZnJhbWUsIGRlbHRhVCwgZXZlbnQpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuU1RBUlRfUkVDT1JESU5HKXtcblx0XHRcdFx0XHR0aGlzLmxvZy5jbGVhcigpO1xuXHRcdFx0XHRcdHRoaXMucmVjb3JkaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLmZyYW1lID0gMFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5QTEFZX1JFQ09SRElORyl7XG5cdFx0XHRcdFx0dGhpcy5mcmFtZSA9IDA7XG5cdFx0XHRcdFx0dGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHR0aGlzLnBsYXlpbmcgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmNsYXNzIExvZ0l0ZW0ge1xuXHRmcmFtZTogbnVtYmVyO1xuXHRkZWx0YTogbnVtYmVyO1xuXHRldmVudDogR2FtZUV2ZW50O1xuXG5cdGNvbnN0cnVjdG9yKGZyYW1lOiBudW1iZXIsIGRlbHRhVDogbnVtYmVyLCBldmVudDogR2FtZUV2ZW50KXtcblx0XHR0aGlzLmZyYW1lID0gZnJhbWU7XG5cdFx0dGhpcy5kZWx0YSA9IGRlbHRhVDtcblx0XHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdH1cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvTWFwXCI7XG5cbi8qKiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUmVnaXN0cnk8VD4gZXh0ZW5kcyBNYXA8VD57XG5cbiAgICAvKiogUHJlbG9hZHMgcmVnaXN0cnkgZGF0YSAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBwcmVsb2FkKCk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gaXRlbSBhbmQgcHJlbG9hZHMgYW55IG5lY2Vzc2FyeSBmaWxlc1xuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byByZWdpc3RlciB0aGlzIGl0ZW0gd2l0aFxuICAgICAqIEBwYXJhbSBhcmdzIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBuZWVkZWQgZm9yIHJlZ2lzdHJhdGlvblxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCByZWdpc3RlckFuZFByZWxvYWRJdGVtKGtleTogc3RyaW5nLCAuLi5hcmdzOiBhbnkpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGl0ZW0gYW5kIHByZWxvYWRzIGFueSBuZWNlc3NhcnkgZmlsZXNcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gcmVnaXN0ZXIgdGhpcyBpdGVtIHdpdGhcbiAgICAgKiBAcGFyYW0gYXJncyBBbnkgYWRpdGlvbmFsIGFyZ3VtZW50cyBuZWVkZWQgZm9yIHJlZ2lzdHJhdGlvblxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCByZWdpc3Rlckl0ZW0oa2V5OiBzdHJpbmcsIC4uLmFyZ3M6IGFueSk6IHZvaWQ7XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlXCI7XG5pbXBvcnQgTGFiZWxTaGFkZXJUeXBlIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvTGFiZWxTaGFkZXJUeXBlXCI7XG5pbXBvcnQgUG9pbnRTaGFkZXJUeXBlIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvUG9pbnRTaGFkZXJUeXBlXCI7XG5pbXBvcnQgUmVjdFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9SZWN0U2hhZGVyVHlwZVwiO1xuaW1wb3J0IFNwcml0ZVNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9TcHJpdGVTaGFkZXJUeXBlXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgUmVnaXN0cnkgZnJvbSBcIi4vUmVnaXN0cnlcIjtcblxuLyoqXG4gKiBBIHJlZ2lzdHJ5IHRoYXQgaGFuZGxlcyBzaGFkZXJzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlclJlZ2lzdHJ5IGV4dGVuZHMgUmVnaXN0cnk8U2hhZGVyVHlwZT4ge1xuXG5cdC8vIFNoYWRlciBuYW1lc1xuXHRwdWJsaWMgc3RhdGljIFBPSU5UX1NIQURFUiA9IFwicG9pbnRcIjtcblx0cHVibGljIHN0YXRpYyBSRUNUX1NIQURFUiA9IFwicmVjdFwiO1xuXHRwdWJsaWMgc3RhdGljIFNQUklURV9TSEFERVIgPSBcInNwcml0ZVwiO1xuXHRwdWJsaWMgc3RhdGljIExBQkVMX1NIQURFUiA9IFwibGFiZWxcIjtcblxuXHRwcml2YXRlIHJlZ2lzdHJ5SXRlbXM6IEFycmF5PFNoYWRlclJlZ2lzdHJ5SXRlbT4gPSBuZXcgQXJyYXkoKTtcblxuXHQvKipcblx0ICogUHJlbG9hZHMgYWxsIGJ1aWx0LWluIHNoYWRlcnNcblx0ICovXG5cdHB1YmxpYyBwcmVsb2FkKCl7XG5cdFx0Ly8gR2V0IHRoZSByZXNvdXJjZU1hbmFnZXIgYW5kIHF1ZXVlIGFsbCBidWlsdC1pbiBzaGFkZXJzIGZvciBwcmVsb2FkaW5nXG5cdFx0Y29uc3Qgcm0gPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcblxuXHRcdC8vIFF1ZXVlIGEgbG9hZCBmb3IgdGhlIHBvaW50IHNoYWRlclxuXHRcdHRoaXMucmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShTaGFkZXJSZWdpc3RyeS5QT0lOVF9TSEFERVIsIFBvaW50U2hhZGVyVHlwZSwgXCJidWlsdGluL3NoYWRlcnMvcG9pbnQudnNoYWRlclwiLCBcImJ1aWx0aW4vc2hhZGVycy9wb2ludC5mc2hhZGVyXCIpO1xuXG5cdFx0Ly8gUXVldWUgYSBsb2FkIGZvciB0aGUgcmVjdCBzaGFkZXJcblx0XHR0aGlzLnJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oU2hhZGVyUmVnaXN0cnkuUkVDVF9TSEFERVIsIFJlY3RTaGFkZXJUeXBlLCBcImJ1aWx0aW4vc2hhZGVycy9yZWN0LnZzaGFkZXJcIiwgXCJidWlsdGluL3NoYWRlcnMvcmVjdC5mc2hhZGVyXCIpO1xuXG5cdFx0Ly8gUXVldWUgYSBsb2FkIGZvciB0aGUgc3ByaXRlIHNoYWRlclxuXHRcdHRoaXMucmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShTaGFkZXJSZWdpc3RyeS5TUFJJVEVfU0hBREVSLCBTcHJpdGVTaGFkZXJUeXBlLCBcImJ1aWx0aW4vc2hhZGVycy9zcHJpdGUudnNoYWRlclwiLCBcImJ1aWx0aW4vc2hhZGVycy9zcHJpdGUuZnNoYWRlclwiKTtcblx0XG5cdFx0Ly8gUXVldWUgYSBsb2FkIGZvciB0aGUgbGFiZWwgc2hhZGVyXG5cdFx0dGhpcy5yZWdpc3RlckFuZFByZWxvYWRJdGVtKFNoYWRlclJlZ2lzdHJ5LkxBQkVMX1NIQURFUiwgTGFiZWxTaGFkZXJUeXBlLCBcImJ1aWx0aW4vc2hhZGVycy9sYWJlbC52c2hhZGVyXCIsIFwiYnVpbHRpbi9zaGFkZXJzL2xhYmVsLmZzaGFkZXJcIik7XG5cblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIGFueSBwcmVsb2FkZWQgaXRlbXNcblx0XHRmb3IobGV0IGl0ZW0gb2YgdGhpcy5yZWdpc3RyeUl0ZW1zKXtcblx0XHRcdGNvbnN0IHNoYWRlciA9IG5ldyBpdGVtLmNvbnN0cihpdGVtLmtleSk7XG5cdFx0XHRzaGFkZXIuaW5pdEJ1ZmZlck9iamVjdCgpO1xuXHRcdFx0dGhpcy5hZGQoaXRlbS5rZXksIHNoYWRlcik7XG5cblx0XHRcdC8vIExvYWQgaWYgZGVzaXJlZFxuXHRcdFx0aWYoaXRlbS5wcmVsb2FkICE9PSB1bmRlZmluZWQpe1xuXHRcdFx0XHRybS5zaGFkZXIoaXRlbS5rZXksIGl0ZW0ucHJlbG9hZC52c2hhZGVyTG9jYXRpb24sIGl0ZW0ucHJlbG9hZC5mc2hhZGVyTG9jYXRpb24pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYSBzaGFkZXIgaW4gdGhlIHJlZ2lzdHJ5IGFuZCBsb2FkcyBpdCBiZWZvcmUgdGhlIGdhbWUgYmVnaW5zXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSB5b3Ugd2lzaCB0byBhc3NpZ24gdG8gdGhlIHNoYWRlclxuXHQgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgU2hhZGVyVHlwZVxuXHQgKiBAcGFyYW0gdnNoYWRlckxvY2F0aW9uIFRoZSBsb2NhdGlvbiBvZiB0aGUgdmVydGV4IHNoYWRlclxuXHQgKiBAcGFyYW0gZnNoYWRlckxvY2F0aW9uIHRoZSBsb2NhdGlvbiBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyXG5cdCAqL1xuXHRwdWJsaWMgcmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShrZXk6IHN0cmluZywgY29uc3RyOiBuZXcgKHByb2dyYW1LZXk6IHN0cmluZykgPT4gU2hhZGVyVHlwZSwgdnNoYWRlckxvY2F0aW9uOiBzdHJpbmcsIGZzaGFkZXJMb2NhdGlvbjogc3RyaW5nKTogdm9pZCB7XG5cdFx0bGV0IHNoYWRlclByZWxvYWQgPSBuZXcgU2hhZGVyUHJlbG9hZCgpO1xuXHRcdHNoYWRlclByZWxvYWQudnNoYWRlckxvY2F0aW9uID0gdnNoYWRlckxvY2F0aW9uO1xuXHRcdHNoYWRlclByZWxvYWQuZnNoYWRlckxvY2F0aW9uID0gZnNoYWRlckxvY2F0aW9uO1xuXG5cdFx0bGV0IHJlZ2lzdHJ5SXRlbSA9IG5ldyBTaGFkZXJSZWdpc3RyeUl0ZW0oKTtcblx0XHRyZWdpc3RyeUl0ZW0ua2V5ID0ga2V5O1xuXHRcdHJlZ2lzdHJ5SXRlbS5jb25zdHIgPSBjb25zdHI7XG5cdFx0cmVnaXN0cnlJdGVtLnByZWxvYWQgPSBzaGFkZXJQcmVsb2FkO1xuXG5cdFx0dGhpcy5yZWdpc3RyeUl0ZW1zLnB1c2gocmVnaXN0cnlJdGVtKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYSBzaGFkZXIgaW4gdGhlIHJlZ2lzdHJ5LiBOT1RFOiBJZiB5b3UgdXNlIHRoaXMsIHlvdSBNVVNUIGxvYWQgdGhlIHNoYWRlciBiZWZvcmUgdXNlLlxuXHQgKiBJZiB5b3Ugd2lzaCB0byBwcmVsb2FkIHRoZSBzaGFkZXIsIHVzZSByZWdpc3RlckFuZFByZWxvYWRJdGVtKClcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IHlvdSB3aXNoIHRvIGFzc2lnbiB0byB0aGUgc2hhZGVyXG5cdCAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBTaGFkZXJUeXBlXG5cdCAqL1xuXHRwdWJsaWMgcmVnaXN0ZXJJdGVtKGtleTogc3RyaW5nLCBjb25zdHI6IG5ldyAocHJvZ3JhbUtleTogc3RyaW5nKSA9PiBTaGFkZXJUeXBlKTogdm9pZCB7XG5cdFx0bGV0IHJlZ2lzdHJ5SXRlbSA9IG5ldyBTaGFkZXJSZWdpc3RyeUl0ZW0oKTtcblx0XHRyZWdpc3RyeUl0ZW0ua2V5ID0ga2V5O1xuXHRcdHJlZ2lzdHJ5SXRlbS5jb25zdHIgPSBjb25zdHI7XG5cblx0XHR0aGlzLnJlZ2lzdHJ5SXRlbXMucHVzaChyZWdpc3RyeUl0ZW0pO1xuXHR9XG59XG5cbmNsYXNzIFNoYWRlclJlZ2lzdHJ5SXRlbSB7XG5cdGtleTogc3RyaW5nO1xuXHRjb25zdHI6IG5ldyAocHJvZ3JhbUtleTogc3RyaW5nKSA9PiBTaGFkZXJUeXBlO1xuXHRwcmVsb2FkOiBTaGFkZXJQcmVsb2FkO1xufVxuXG5jbGFzcyBTaGFkZXJQcmVsb2FkIHtcblx0dnNoYWRlckxvY2F0aW9uOiBzdHJpbmc7XG5cdGZzaGFkZXJMb2NhdGlvbjogc3RyaW5nO1xufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBSZWdpc3RyeSBmcm9tIFwiLi9SZWdpc3RyaWVzL1JlZ2lzdHJ5XCI7XG5pbXBvcnQgU2hhZGVyUmVnaXN0cnkgZnJvbSBcIi4vUmVnaXN0cmllcy9TaGFkZXJSZWdpc3RyeVwiO1xuXG4vKipcbiAqIFRoZSBSZWdpc3RyeSBpcyB0aGUgc3lzdGVtJ3Mgd2F5IG9mIGNvbnZlcnRpbmcgY2xhc3NlcyBhbmQgdHlwZXMgaW50byBzdHJpbmdcbiAqIHJlcHJlc2VudGF0aW9ucyBmb3IgdXNlIGVsc2V3aGVyZSBpbiB0aGUgYXBwbGljYXRpb24uXG4gKiBJdCBhbGxvd3MgY2xhc3NlcyB0byBiZSBhY2Nlc3NlZCB3aXRob3V0IGV4cGxpY2l0bHkgdXNpbmcgY29uc3RydWN0b3JzIGluIGNvZGUsXG4gKiBhbmQgZm9yIHJlc291cmNlcyB0byBiZSBsb2FkZWQgYXQgR2FtZSBjcmVhdGlvbiB0aW1lLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWdpc3RyeU1hbmFnZXIge1xuXG5cdHB1YmxpYyBzdGF0aWMgc2hhZGVycyA9IG5ldyBTaGFkZXJSZWdpc3RyeSgpO1xuXG5cdC8qKiBBZGRpdGlvbmFsIGN1c3RvbSByZWdpc3RyaWVzIHRvIGFkZCB0byB0aGUgcmVnaXN0cnkgbWFuYWdlciAqL1xuXHRwcm90ZWN0ZWQgc3RhdGljIHJlZ2lzdHJpZXM6IE1hcDxSZWdpc3RyeTxhbnk+PiA9IG5ldyBNYXAoKTtcblxuXHRzdGF0aWMgcHJlbG9hZCgpe1xuXHRcdHRoaXMuc2hhZGVycy5wcmVsb2FkKCk7XG5cblx0XHR0aGlzLnJlZ2lzdHJpZXMuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IHRoaXMucmVnaXN0cmllcy5nZXQoa2V5KS5wcmVsb2FkKCkpO1xuXHR9XG5cblx0c3RhdGljIGFkZEN1c3RvbVJlZ2lzdHJ5KG5hbWU6IHN0cmluZywgcmVnaXN0cnk6IFJlZ2lzdHJ5PGFueT4pe1xuXHRcdHRoaXMucmVnaXN0cmllcy5hZGQobmFtZSwgcmVnaXN0cnkpO1xuXHR9XG5cblx0c3RhdGljIGdldFJlZ2lzdHJ5KGtleTogc3RyaW5nKXtcblx0XHRyZXR1cm4gdGhpcy5yZWdpc3RyaWVzLmdldChrZXkpO1xuXHR9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uLy4uL0V2ZW50cy9FbWl0dGVyXCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IHsgQW5pbWF0aW9uRGF0YSwgQW5pbWF0aW9uU3RhdGUgfSBmcm9tIFwiLi9BbmltYXRpb25UeXBlc1wiO1xuXG4vKipcbiAqIEFuIGFuaW1hdGlvbiBtYW5hZ2VyIGNsYXNzIGZvciBhbiBhbmltYXRlZCBDYW52YXNOb2RlLlxuICogVGhpcyBjbGFzcyBrZWVwcyB0cmFjayBvZiB0aGUgcG9zc2libGUgYW5pbWF0aW9ucywgYXMgd2VsbCBhcyB0aGUgY3VycmVudCBhbmltYXRpb24gc3RhdGUsXG4gKiBhbmQgYWJzdHJhY3RzIGFsbCBpbnRlcmFjdGlvbnMgd2l0aCBwbGF5aW5nLCBwYXVzaW5nLCBhbmQgc3RvcHBpbmcgYW5pbWF0aW9ucyBhcyB3ZWxsIGFzIFxuICogY3JlYXRpbmcgbmV3IGFuaW1hdGlvbnMgZnJvbSB0aGUgQ2FudmFzTm9kZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9uTWFuYWdlciB7XG4gICAgLyoqIFRoZSBvd25lciBvZiB0aGlzIGFuaW1hdGlvbiBtYW5hZ2VyICovXG4gICAgcHJvdGVjdGVkIG93bmVyOiBDYW52YXNOb2RlO1xuICAgIFxuICAgIC8qKiBUaGUgY3VycmVudCBhbmltYXRpb24gc3RhdGUgb2YgdGhpcyBzcHJpdGUgKi9cbiAgICBwcm90ZWN0ZWQgYW5pbWF0aW9uU3RhdGU6IEFuaW1hdGlvblN0YXRlO1xuXG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBvZiB0aGlzIHNwcml0ZSAqL1xuICAgIHByb3RlY3RlZCBjdXJyZW50QW5pbWF0aW9uOiBzdHJpbmc7XG5cbiAgICAvKiogVGhlIGN1cnJlbnQgZnJhbWUgb2YgdGhpcyBhbmltYXRpb24gKi9cbiAgICBwcm90ZWN0ZWQgY3VycmVudEZyYW1lOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIHByb2dyZXNzIG9mIHRoZSBjdXJyZW50IGFuaW1hdGlvbiB0aHJvdWdoIHRoZSBjdXJyZW50IGZyYW1lICovXG4gICAgcHJvdGVjdGVkIGZyYW1lUHJvZ3Jlc3M6IG51bWJlcjtcblxuICAgIC8qKiBXaGV0aGVyIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpcyBsb29waW5nIG9yIG5vdCAqL1xuICAgIHByb3RlY3RlZCBsb29wOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBtYXAgb2YgYW5pbWF0aW9ucyAqL1xuICAgIHByb3RlY3RlZCBhbmltYXRpb25zOiBNYXA8QW5pbWF0aW9uRGF0YT47XG5cbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChpZiBhbnkpIHRvIHNlbmQgd2hlbiB0aGUgY3VycmVudCBhbmltYXRpb24gc3RvcHMgcGxheWluZy4gKi9cbiAgICBwcm90ZWN0ZWQgb25FbmRFdmVudDogc3RyaW5nO1xuXG4gICAgLyoqIFRoZSBldmVudCBlbWl0dGVyIGZvciB0aGlzIGFuaW1hdGlvbiBtYW5hZ2VyICovXG4gICAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XG5cbiAgICAvKiogQSBxdWV1ZWQgYW5pbWF0aW9uICovXG4gICAgcHJvdGVjdGVkIHBlbmRpbmdBbmltYXRpb246IHN0cmluZztcblxuICAgIC8qKiBUaGUgbG9vcCBzdGF0dXMgb2YgYSBwZW5kaW5nIGFuaW1hdGlvbiAqL1xuICAgIHByb3RlY3RlZCBwZW5kaW5nTG9vcDogYm9vbGVhbjtcblxuICAgIC8qKiBUaGUgb25FbmQgZXZlbnQgb2YgYSBwZW5kaW5nIGFuaW1hdGlvbiAqL1xuICAgIHByb3RlY3RlZCBwZW5kaW5nT25FbmQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQW5pbWF0aW9uTWFuYWdlclxuICAgICAqIEBwYXJhbSBvd25lciBUaGUgb3duZXIgb2YgdGhlIEFuaW1hdGlvbk1hbmFnZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihvd25lcjogQ2FudmFzTm9kZSl7XG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlNUT1BQRUQ7XG4gICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IFwiXCI7XG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcbiAgICAgICAgdGhpcy5mcmFtZVByb2dyZXNzID0gMDtcbiAgICAgICAgdGhpcy5sb29wID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5vbkVuZEV2ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gYW5pbWF0aW9uIHRvIHRoaXMgc3ByaXRlXG4gICAgICogQHBhcmFtIGtleSBUaGUgdW5pcXVlIGtleSBvZiB0aGUgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBUaGUgYW5pbWF0aW9uIGRhdGFcbiAgICAgKi9cbiAgICBhZGQoa2V5OiBzdHJpbmcsIGFuaW1hdGlvbjogQW5pbWF0aW9uRGF0YSk6IHZvaWQge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMuYWRkKGtleSwgYW5pbWF0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBzcGVjaWZpZWQgYnkgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGFuZCBjdXJyZW50IGZyYW1lXG4gICAgICogQHJldHVybnMgVGhlIGluZGV4IGluIHRoZSBjdXJyZW50IGFuaW1hdGlvblxuICAgICAqL1xuICAgIGdldEluZGV4KCk6IG51bWJlciB7XG4gICAgICAgIGlmKHRoaXMuYW5pbWF0aW9ucy5oYXModGhpcy5jdXJyZW50QW5pbWF0aW9uKSl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb25zLmdldCh0aGlzLmN1cnJlbnRBbmltYXRpb24pLmZyYW1lc1t0aGlzLmN1cnJlbnRGcmFtZV0uaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBjdXJyZW50IGFuaW1hdGlvbiwgd2FybiB0aGUgdXNlclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBBbmltYXRpb24gaW5kZXggd2FzIHJlcXVlc3RlZCwgYnV0IHRoZSBjdXJyZW50IGFuaW1hdGlvbjogJHt0aGlzLmN1cnJlbnRBbmltYXRpb259IHdhcyBpbnZhbGlkYCk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbiBpcyBjdXJyZW50bHkgcGxheWluZ1xuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgYW5pbWF0aW9uIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbiBpcyBwbGF5aW5nLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBpc1BsYXlpbmcoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9PT0ga2V5ICYmIHRoaXMuYW5pbWF0aW9uU3RhdGUgPT09IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpbmRleCBhbmQgYWR2YW5jZXMgdGhlIGFuaW1hdGlvbiBmcmFtZVxuICAgICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgYW5pbWF0aW9uIGZyYW1lXG4gICAgICovXG4gICAgZ2V0SW5kZXhBbmRBZHZhbmNlQW5pbWF0aW9uKCk6IG51bWJlciB7XG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCBwbGF5aW5nLCB3ZSB3b24ndCBiZSBhZHZhbmNpbmcgdGhlIGFuaW1hdGlvblxuICAgICAgICBpZighKHRoaXMuYW5pbWF0aW9uU3RhdGUgPT09IEFuaW1hdGlvblN0YXRlLlBMQVlJTkcpKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEluZGV4KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmFuaW1hdGlvbnMuaGFzKHRoaXMuY3VycmVudEFuaW1hdGlvbikpe1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRBbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnMuZ2V0KHRoaXMuY3VycmVudEFuaW1hdGlvbik7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBjdXJyZW50QW5pbWF0aW9uLmZyYW1lc1t0aGlzLmN1cnJlbnRGcmFtZV0uaW5kZXg7XG5cbiAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgdGhpcy5mcmFtZVByb2dyZXNzICs9IDE7XG4gICAgICAgICAgICBpZih0aGlzLmZyYW1lUHJvZ3Jlc3MgPj0gY3VycmVudEFuaW1hdGlvbi5mcmFtZXNbdGhpcy5jdXJyZW50RnJhbWVdLmR1cmF0aW9uKXtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGJlZW4gb24gdGhpcyBmcmFtZSBmb3IgaXRzIHdob2xlIGR1cmF0aW9uLCBnbyB0byB0aGUgbmV4dCBvbmVcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lICs9IDE7XG5cbiAgICAgICAgICAgICAgICBpZih0aGlzLmN1cnJlbnRGcmFtZSA+PSBjdXJyZW50QW5pbWF0aW9uLmZyYW1lcy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGlzIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmxvb3Ape1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFtZVByb2dyZXNzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kQ3VycmVudEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGN1cnJlbnQgaW5kZXhcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIGN1cnJlbnQgYW5pbWF0aW9uLCBjYW4ndCBhZHZhbmNlLiBXYXJuIHRoZSB1c2VyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEFuaW1hdGlvbiBpbmRleCBhbmQgYWR2YW5jZSB3YXMgcmVxdWVzdGVkLCBidXQgdGhlIGN1cnJlbnQgYW5pbWF0aW9uICgke3RoaXMuY3VycmVudEFuaW1hdGlvbn0pIGluIG5vZGUgd2l0aCBpZDogJHt0aGlzLm93bmVyLmlkfSB3YXMgaW52YWxpZGApO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRW5kcyB0aGUgY3VycmVudCBhbmltYXRpb24gYW5kIGZpcmVzIGFueSBuZWNlc3NhcnkgZXZlbnRzLCBhcyB3ZWxsIGFzIHN0YXJ0aW5nIGFueSBuZXcgYW5pbWF0aW9ucyAqL1xuICAgIHByb3RlY3RlZCBlbmRDdXJyZW50QW5pbWF0aW9uKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xuXG4gICAgICAgIGlmKHRoaXMub25FbmRFdmVudCAhPT0gbnVsbCl7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25FbmRFdmVudCwge293bmVyOiB0aGlzLm93bmVyLmlkLCBhbmltYXRpb246IHRoaXMuY3VycmVudEFuaW1hdGlvbn0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwZW5kaW5nIGFuaW1hdGlvbiwgcGxheSBpdFxuICAgICAgICBpZih0aGlzLnBlbmRpbmdBbmltYXRpb24gIT09IG51bGwpe1xuICAgICAgICAgICAgdGhpcy5wbGF5KHRoaXMucGVuZGluZ0FuaW1hdGlvbiwgdGhpcy5wZW5kaW5nTG9vcCwgdGhpcy5wZW5kaW5nT25FbmQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxheXMgdGhlIHNwZWNpZmllZCBhbmltYXRpb24uIERvZXMgbm90IHJlc3RhcnQgaXQgaWYgaXQgaXMgYWxyZWFkeSBwbGF5aW5nXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBUaGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHBsYXlcbiAgICAgKiBAcGFyYW0gbG9vcCBXaGV0aGVyIG9yIG5vdCB0byBsb29wIHRoZSBhbmltYXRpb24uIEZhbHNlIGJ5IGRlZmF1bHRcbiAgICAgKiBAcGFyYW0gb25FbmQgVGhlIG5hbWUgb2YgYW4gZXZlbnQgdG8gc2VuZCB3aGVuIHRoaXMgYW5pbWF0aW9uIG5hdHVyYWxseSBzdG9wcyBwbGF5aW5nLiBUaGlzIG9ubHkgbWF0dGVycyBpZiBsb29wIGlzIGZhbHNlLlxuICAgICAqL1xuICAgIHBsYXlJZk5vdEFscmVhZHkoYW5pbWF0aW9uOiBzdHJpbmcsIGxvb3A/OiBib29sZWFuLCBvbkVuZD86IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLmN1cnJlbnRBbmltYXRpb24gIT09IGFuaW1hdGlvbil7XG4gICAgICAgICAgICB0aGlzLnBsYXkoYW5pbWF0aW9uLCBsb29wLCBvbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGF5cyB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBwbGF5XG4gICAgICogQHBhcmFtIGxvb3AgV2hldGhlciBvciBub3QgdG8gbG9vcCB0aGUgYW5pbWF0aW9uLiBGYWxzZSBieSBkZWZhdWx0XG4gICAgICogQHBhcmFtIG9uRW5kIFRoZSBuYW1lIG9mIGFuIGV2ZW50IHRvIHNlbmQgd2hlbiB0aGlzIGFuaW1hdGlvbiBuYXR1cmFsbHkgc3RvcHMgcGxheWluZy4gVGhpcyBvbmx5IG1hdHRlcnMgaWYgbG9vcCBpcyBmYWxzZS5cbiAgICAgKi9cbiAgICBwbGF5KGFuaW1hdGlvbjogc3RyaW5nLCBsb29wPzogYm9vbGVhbiwgb25FbmQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG4gICAgICAgIHRoaXMuZnJhbWVQcm9ncmVzcyA9IDA7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xuXG4gICAgICAgIC8vIElmIGxvb3AgYXJnIHdhcyBwcm92aWRlZCwgdXNlIHRoYXRcbiAgICAgICAgaWYobG9vcCAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHRoaXMubG9vcCA9IGxvb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHVzZSB3aGF0IHRoZSBqc29uIGZpbGUgc3BlY2lmaWVkXG4gICAgICAgICAgICB0aGlzLmxvb3AgPSB0aGlzLmFuaW1hdGlvbnMuZ2V0KGFuaW1hdGlvbikucmVwZWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYob25FbmQgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICB0aGlzLm9uRW5kRXZlbnQgPSBvbkVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25FbmRFdmVudCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCBwZW5kaW5nIGFuaW1hdGlvblxuICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFF1ZXVlcyBhIHNpbmdsZSBhbmltYXRpb24gdG8gYmUgcGxheWVkIGFmdGVyIHRoZSBjdXJyZW50IG9uZS4gRG9lcyBOT1Qgc3RhY2suXG4gICAgICogUXVldWVpbmcgYWRkaXRpb25hbCBhbmltYXRpb25zIHBhc3QgMSB3aWxsIGp1c3QgcmVwbGFjZSB0aGUgcXVldWVkIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gVGhlIGFuaW1hdGlvbiB0byBxdWV1ZVxuICAgICAqIEBwYXJhbSBsb29wIFdoZXRoZXIgb3Igbm90IHRoZSBsb29wIHRoZSBxdWV1ZWQgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIG9uRW5kIFRoZSBldmVudCB0byBmaXJlIHdoZW4gdGhlIHF1ZXVlZCBhbmltYXRpb24gZW5kc1xuICAgICAqL1xuICAgIHF1ZXVlKGFuaW1hdGlvbjogc3RyaW5nLCBsb29wOiBib29sZWFuID0gZmFsc2UsIG9uRW5kPzogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMucGVuZGluZ0FuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICAgICAgdGhpcy5wZW5kaW5nTG9vcCA9IGxvb3A7XG4gICAgICAgIGlmKG9uRW5kICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nT25FbmQgPSBvbkVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ09uRW5kID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBQYXVzZXMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uICovXG4gICAgcGF1c2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QQVVTRUQ7XG4gICAgfVxuXG4gICAgLyoqIFJlc3VtZXMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGlmIHBvc3NpYmxlICovXG4gICAgcmVzdW1lKCk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QQVVTRUQpe1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogU3RvcHMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLiBUaGUgYW5pbWF0aW9uIGNhbm5vdCBiZSByZXN1bWVkIGFmdGVyIHRoaXMuICovXG4gICAgc3RvcCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlNUT1BQRUQ7XG4gICAgfVxufSIsImltcG9ydCB7IFR3ZWVuYWJsZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vLi4vTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCB7IEVhc2VGdW5jdGlvblR5cGUgfSBmcm9tIFwiLi4vLi4vVXRpbHMvRWFzZUZ1bmN0aW9uc1wiO1xuXG4vLyBAaWdub3JlUGFnZVxuXG5leHBvcnQgZW51bSBBbmltYXRpb25TdGF0ZSB7XG4gICAgU1RPUFBFRCA9IDAsXG4gICAgUEFVU0VEID0gMSxcbiAgICBQTEFZSU5HID0gMixcbn1cblxuZXhwb3J0IGNsYXNzIEFuaW1hdGlvbkRhdGEge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBmcmFtZXM6IEFycmF5PHtpbmRleDogbnVtYmVyLCBkdXJhdGlvbjogbnVtYmVyfT47XG4gICAgcmVwZWF0OiBib29sZWFuID0gZmFsc2U7XG59XG5cbmV4cG9ydCBjbGFzcyBUd2VlbkVmZmVjdCB7XG4gICAgLyoqIFRoZSBwcm9wZXJ0eSB0byB0d2VlbiAqL1xuICAgIHByb3BlcnR5OiBUd2VlbmFibGVQcm9wZXJ0aWVzO1xuXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBUd2VlbiBzaG91bGQgcmVzZXQgdGhlIHByb3BlcnR5IHRvIGl0cyBvcmlnaW5hbCB2YWx1ZSBhZnRlciBwbGF5aW5nICovXG4gICAgcmVzZXRPbkNvbXBsZXRlOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBzdGFydGluZyB2YWx1ZSBmb3IgdGhlIHR3ZWVuICovXG4gICAgc3RhcnQ6IGFueTtcblxuICAgIC8qKiBUaGUgZW5kaW5nIHZhbHVlIGZvciB0aGUgdHdlZW4gKi9cbiAgICBlbmQ6IGFueTtcblxuICAgIC8qKiBUaGUgZWFzZSBmdW5jdGlvbiB0byB1c2UgKi9cbiAgICBlYXNlOiBFYXNlRnVuY3Rpb25UeXBlO1xuXG4gICAgLyoqIERPIE5PVCBNT0RJRlkgLSBUaGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHByb3BlcnR5IC0gc2V0IGF1dG9tYXRpY2FsbHkgKi9cbiAgICBpbml0aWFsVmFsdWU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFR3ZWVuRGF0YSB7XG4gICAgLy8gTWVtYmVycyBmb3IgaW5pdGlhbGl6YXRpb24gYnkgdGhlIHVzZXJcbiAgICAvKiogVGhlIGFtb3VudCBvZiB0aW1lIGluIG1zIHRvIHdhaXQgYmVmb3JlIGV4ZWN1dGluZyB0aGUgdHdlZW4gKi9cbiAgICBzdGFydERlbGF5OiBudW1iZXI7XG4gICAgLyoqIFRoZSBkdXJhdGlvbiBvZiB0aW1lIG92ZXIgd2hpY2ggdGhlIHZhbHVlIHdpdGggY2hhbmdlIGZyb20gc3RhcnQgdG8gZW5kICovXG4gICAgZHVyYXRpb246IG51bWJlcjtcbiAgICAvKiogQW4gYXJyYXkgb2YgdGhlIGVmZmVjdHMgb24gdGhlIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCAqL1xuICAgIGVmZmVjdHM6IEFycmF5PFR3ZWVuRWZmZWN0PjtcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhpcyB0d2VlbiBzaG91bGQgcmV2ZXJzZSBmcm9tIGVuZCB0byBzdGFydCBmb3IgZWFjaCBwcm9wZXJ0eSB3aGVuIGl0IGZpbmlzaGVzICovXG4gICAgcmV2ZXJzZU9uQ29tcGxldGU6IGJvb2xlYW47XG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgdHdlZW4gc2hvdWxkIGxvb3Agd2hlbiBpdCBjb21wbGV0ZXMgKi9cbiAgICBsb29wOiBib29sZWFuO1xuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc2VuZCAoaWYgYW55KSB3aGVuIHRoZSB0d2VlbiBmaW5pc2hlcyBwbGF5aW5nICovXG4gICAgb25FbmQ6IHN0cmluZ1xuICAgIFxuICAgIC8vIE1lbWJlcnMgZm9yIG1hbmFnZW1lbnQgYnkgdGhlIHR3ZWVuIG1hbmFnZXJcbiAgICAvKiogVGhlIHByb2dyZXNzIG9mIHRoaXMgdHdlZW4gdGhyb3VnaCBpdHMgZWZmZWN0cyAqL1xuICAgIHByb2dyZXNzOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGFtb3VudCBvZiB0aW1lIGluIG1zIHRoYXQgaGFzIHBhc3NlZCBmcm9tIHdoZW4gdGhpcyB0d2VlbiBzdGFydGVkIHJ1bm5pbmcgKi9cbiAgICBlbGFwc2VkVGltZTogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBzdGF0ZSBvZiB0aGlzIHR3ZWVuICovXG4gICAgYW5pbWF0aW9uU3RhdGU6IEFuaW1hdGlvblN0YXRlO1xuXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgdHdlZW4gaXMgY3VycmVudGx5IHJldmVyc2luZyAqL1xuICAgIHJldmVyc2luZzogYm9vbGVhbjtcbn0iLCJpbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuaW1wb3J0IFBhcnRpY2xlU3lzdGVtIGZyb20gXCIuL1BhcnRpY2xlU3lzdGVtXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcnRpY2xlU3lzdGVtTWFuYWdlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFBhcnRpY2xlU3lzdGVtTWFuYWdlciA9IG51bGw7XG4gICAgXG4gICAgcHJvdGVjdGVkIHBhcnRpY2xlU3lzdGVtczogQXJyYXk8UGFydGljbGVTeXN0ZW0+O1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnBhcnRpY2xlU3lzdGVtcyA9IG5ldyBBcnJheSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIge1xuICAgICAgICBpZihQYXJ0aWNsZVN5c3RlbU1hbmFnZXIuaW5zdGFuY2UgPT09IG51bGwpe1xuICAgICAgICAgICAgUGFydGljbGVTeXN0ZW1NYW5hZ2VyLmluc3RhbmNlID0gbmV3IFBhcnRpY2xlU3lzdGVtTWFuYWdlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFBhcnRpY2xlU3lzdGVtTWFuYWdlci5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICByZWdpc3RlclBhcnRpY2xlU3lzdGVtKHN5c3RlbTogUGFydGljbGVTeXN0ZW0pe1xuICAgICAgICB0aGlzLnBhcnRpY2xlU3lzdGVtcy5wdXNoKHN5c3RlbSk7XG4gICAgfVxuXG4gICAgZGVyZWdpc3RlclBhcnRpY2xlU3lzdGVtKHN5c3RlbTogUGFydGljbGVTeXN0ZW0pe1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnBhcnRpY2xlU3lzdGVtcy5pbmRleE9mKHN5c3RlbSk7XG4gICAgICAgIHRoaXMucGFydGljbGVTeXN0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgY2xlYXJQYXJ0aWNsZVN5c3RlbXMoKXtcbiAgICAgICAgdGhpcy5wYXJ0aWNsZVN5c3RlbXMgPSBuZXcgQXJyYXkoKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgZm9yKGxldCBwYXJ0aWNsZVN5c3RlbSBvZiB0aGlzLnBhcnRpY2xlU3lzdGVtcyl7XG4gICAgICAgICAgICBwYXJ0aWNsZVN5c3RlbS51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvTWFwXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgeyBBbmltYXRpb25TdGF0ZSwgVHdlZW5EYXRhIH0gZnJvbSBcIi4vQW5pbWF0aW9uVHlwZXNcIjtcbmltcG9ydCBFYXNlRnVuY3Rpb25zIGZyb20gXCIuLi8uLi9VdGlscy9FYXNlRnVuY3Rpb25zXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi8uLi9VdGlscy9NYXRoVXRpbHNcIjtcbmltcG9ydCBUd2Vlbk1hbmFnZXIgZnJvbSBcIi4vVHdlZW5NYW5hZ2VyXCI7XG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcblxuLyoqXG4gKiBBIG1hbmFnZXIgZm9yIHRoZSB0d2VlbnMgb2YgYSBHYW1lTm9kZS5cbiAqIFR3ZWVucyBhcmUgc2hvcnQgYW5pbWF0aW9ucyBwbGF5ZWQgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHR3byBwcm9wZXJ0aWVzIHVzaW5nIGFuIGVhc2luZyBmdW5jdGlvbi5cbiAqIEZvciBhIGdvb2QgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIGVhc2luZyBmdW5jdGlvbnMsIGNoZWNrIG91dCBAbGluayhodHRwczovL2Vhc2luZ3MubmV0LykoaHR0cHM6Ly9lYXNpbmdzLm5ldC8pLlxuICogTXVsdGlwbGUgdHdlZW4gY2FuIGJlIHBsYXllZCBhdCB0aGUgc2FtZSB0aW1lLCBhcyBsb25nIGFzIHRoZXkgZG9uJ3QgY2hhbmdlIHRoZSBzYW1lIHByb3BlcnR5LlxuICogVGhpcyBhbGxvd3MgZm9yIHNvbWUgaW50ZXJlc3RpbmcgcG9saXNoZXMgb3IgYW5pbWF0aW9ucyB0aGF0IG1heSBiZSB2ZXJ5IGRpZmZpY3VsdCB0byBkbyB3aXRoIHNwcml0ZSB3b3JrIGFsb25lXG4gKiAtIGVzcGVjaWFsbHkgcGl4ZWwgYXJ0IChzdWNoIGFzIHJvdGF0aW9ucyBvciBzY2FsaW5nKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHdlZW5Db250cm9sbGVyIHtcbiAgICAvKiogVGhlIEdhbWVOb2RlIHRoaXMgVHdlZW5Db250cm9sbGVyIGFjdHMgdXBvbiAqL1xuICAgIHByb3RlY3RlZCBvd25lcjogR2FtZU5vZGU7XG4gICAgLyoqIFRoZSBsaXN0IG9mIGNyZWF0ZWQgdHdlZW5zICovXG4gICAgcHJvdGVjdGVkIHR3ZWVuczogTWFwPFR3ZWVuRGF0YT47XG4gICAgLyoqIEFuIGV2ZW50IGVtaXR0ZXIgKi9cbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVHdlZW5Db250cm9sbGVyXG4gICAgICogQHBhcmFtIG93bmVyIFRoZSBvd25lciBvZiB0aGUgVHdlZW5Db250cm9sbGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3duZXI6IEdhbWVOb2RlKXtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLnR3ZWVucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcblxuICAgICAgICAvLyBHaXZlIG91cnNlbHZlcyB0byB0aGUgVHdlZW5NYW5hZ2VyXG4gICAgICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLnJlZ2lzdGVyVHdlZW5Db250cm9sbGVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgVHdlZW5Db250cm9sbGVyXG4gICAgICovXG4gICAgZGVzdHJveSgpe1xuICAgICAgICAvLyBPbmx5IHRoZSBnYW1lbm9kZSBhbmQgdGhlIHR3ZWVuIG1hbmFnZXIgc2hvdWxkIGhhdmUgYSByZWZlcmVuY2UgdG8gdGhpc1xuICAgICAgICBkZWxldGUgdGhpcy5vd25lci50d2VlbnM7XG4gICAgICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLmRlcmVnaXN0ZXJUd2VlbkNvbnRyb2xsZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgdHdlZW4gdG8gdGhpcyBnYW1lIG5vZGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBuYW1lIG9mIHRoZSB0d2VlblxuICAgICAqIEBwYXJhbSB0d2VlbiBUaGUgZGF0YSBvZiB0aGUgdHdlZW5cbiAgICAgKi9cbiAgICBhZGQoa2V5OiBzdHJpbmcsIHR3ZWVuOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgVHdlZW5EYXRhKTogdm9pZCB7XG4gICAgICAgIGxldCB0eXBlZFR3ZWVuID0gPFR3ZWVuRGF0YT50d2VlbjtcblxuICAgICAgICAvLyBJbml0aWFsaXplIG1lbWJlcnMgdGhhdCB3ZSBuZWVkIChhbmQgdGhlIHVzZXIgZGlkbid0IHByb3ZpZGUpXG4gICAgICAgIHR5cGVkVHdlZW4ucHJvZ3Jlc3MgPSAwO1xuICAgICAgICB0eXBlZFR3ZWVuLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgdHlwZWRUd2Vlbi5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlNUT1BQRUQ7XG5cbiAgICAgICAgdGhpcy50d2VlbnMuYWRkKGtleSwgdHlwZWRUd2Vlbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxheSBhIHR3ZWVuIHdpdGggYSBjZXJ0YWluIG5hbWVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBuYW1lIG9mIHRoZSB0d2VlbiB0byBwbGF5XG4gICAgICogQHBhcmFtIGxvb3AgV2hldGhlciBvciBub3QgdGhlIHR3ZWVuIHNob3VsZCBsb29wXG4gICAgICovXG4gICAgcGxheShrZXk6IHN0cmluZywgbG9vcD86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIC8vIFNldCBsb29wIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYobG9vcCAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICB0d2Vlbi5sb29wID0gbG9vcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBpbml0aWFsIHZhbHVlc1xuICAgICAgICAgICAgZm9yKGxldCBlZmZlY3Qgb2YgdHdlZW4uZWZmZWN0cyl7XG4gICAgICAgICAgICAgICAgaWYoZWZmZWN0LnJlc2V0T25Db21wbGV0ZSl7XG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdC5pbml0aWFsVmFsdWUgPSB0aGlzLm93bmVyW2VmZmVjdC5wcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgdHdlZW4gcnVubmluZ1xuICAgICAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xuICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICAgICAgdHdlZW4ucHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgdHdlZW4ucmV2ZXJzaW5nID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRyaWVkIHRvIHBsYXkgdHdlZW4gXCIke2tleX1cIiBvbiBub2RlIHdpdGggaWQgJHt0aGlzLm93bmVyLmlkfSwgYnV0IG5vIHN1Y2ggdHdlZW4gZXhpc3RzYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgYSBwbGF5aW5nIHR3ZWVuLiBEb2VzIG5vdCBhZmZlY3QgdHdlZW5zIHRoYXQgYXJlIHN0b3BwZWQuXG4gICAgICogQHBhcmFtIGtleSBUaGUgbmFtZSBvZiB0aGUgdHdlZW4gdG8gcGF1c2UuXG4gICAgICovXG4gICAgcGF1c2Uoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xuICAgICAgICAgICAgdGhpcy50d2VlbnMuZ2V0KGtleSkuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QQVVTRUQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIGEgcGF1c2VkIHR3ZWVuLlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIG5hbWUgb2YgdGhlIHR3ZWVuIHRvIHJlc3VtZVxuICAgICAqL1xuICAgIHJlc3VtZShrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLnR3ZWVucy5oYXMoa2V5KSl7XG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmKHR3ZWVuLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QQVVTRUQpXG4gICAgICAgICAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcHMgYSBjdXJyZW50bHkgcGxheWluZyB0d2VlblxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgdHdlZW5cbiAgICAgKi9cbiAgICBzdG9wKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMudHdlZW5zLmhhcyhrZXkpKXtcbiAgICAgICAgICAgIGxldCB0d2VlbiA9IHRoaXMudHdlZW5zLmdldChrZXkpO1xuICAgICAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdG8gdGhlIGluaXRpYWwgdmFsdWVzXG4gICAgICAgICAgICBmb3IobGV0IGVmZmVjdCBvZiB0d2Vlbi5lZmZlY3RzKXtcbiAgICAgICAgICAgICAgICBpZihlZmZlY3QucmVzZXRPbkNvbXBsZXRlKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vd25lcltlZmZlY3QucHJvcGVydHldID0gZWZmZWN0LmluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmF0dXJhbCBzdG9wIG9mIGEgY3VycmVudGx5IHBsYXlpbmcgdHdlZW5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHR3ZWVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGVuZChrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0b3Aoa2V5KTtcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xuICAgICAgICAgICAgLy8gR2V0IHRoZSB0d2VlblxuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIC8vIElmIGl0IGhhcyBhbiBvbkVuZCwgc2VuZCBhbiBldmVudFxuICAgICAgICAgICAgaWYodHdlZW4ub25FbmQpe1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodHdlZW4ub25FbmQsIHtrZXk6IGtleSwgbm9kZTogdGhpcy5vd25lci5pZH0pOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIGFsbCBjdXJyZW50bHkgcGxheWluZyB0d2VlbnNcbiAgICAgKi9cbiAgICBzdG9wQWxsKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnR3ZWVucy5mb3JFYWNoKGtleSA9PiB0aGlzLnN0b3Aoa2V5KSk7XG4gICAgfVxuICAgIFxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnR3ZWVucy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmKHR3ZWVuLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HKXtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByb2dyZXNzIG9mIHRoZSB0d2VlblxuICAgICAgICAgICAgICAgIHR3ZWVuLmVsYXBzZWRUaW1lICs9IGRlbHRhVCoxMDAwO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgcGFzdCB0aGUgc3RhcnREZWxheSwgZG8gdGhlIHR3ZWVuXG4gICAgICAgICAgICAgICAgaWYodHdlZW4uZWxhcHNlZFRpbWUgPj0gdHdlZW4uc3RhcnREZWxheSl7XG4gICAgICAgICAgICAgICAgICAgIGlmKCF0d2Vlbi5yZXZlcnNpbmcgJiYgdHdlZW4uZWxhcHNlZFRpbWUgPj0gdHdlZW4uc3RhcnREZWxheSArIHR3ZWVuLmR1cmF0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG92ZXIgdGltZSwgc3RvcCB0aGUgdHdlZW4sIGxvb3AsIG9yIHJldmVyc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR3ZWVuLnJldmVyc2VPbkNvbXBsZXRlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBvdmVyIHRpbWUgYW5kIGNhbiByZXZlcnNlLCBkbyBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLnJldmVyc2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYodHdlZW4ubG9vcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgcmV2ZXJzZSBhbmQgY2FuIGxvb3AsIGRvIHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgLT0gdHdlZW4uZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZW4ndCBsb29waW5nIGFuZCBjYW4ndCByZXZlcnNlLCBzbyBzdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgZW5kIG9mIHJldmVyc2luZ1xuICAgICAgICAgICAgICAgICAgICBpZih0d2Vlbi5yZXZlcnNpbmcgJiYgdHdlZW4uZWxhcHNlZFRpbWUgPj0gdHdlZW4uc3RhcnREZWxheSArIDIqdHdlZW4uZHVyYXRpb24pe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHdlZW4ubG9vcCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ucmV2ZXJzaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgLT0gMip0d2Vlbi5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MsIG1ha2Ugc3VyZSBpdCBpcyBiZXR3ZWVuIDAgYW5kIDEuIEVycm9ycyBmcm9tIHRoaXMgc2hvdWxkIG5ldmVyIGJlIGxhcmdlXG4gICAgICAgICAgICAgICAgICAgIGlmKHR3ZWVuLnJldmVyc2luZyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0d2Vlbi5wcm9ncmVzcyA9IE1hdGhVdGlscy5jbGFtcDAxKCgyKnR3ZWVuLmR1cmF0aW9uIC0gKHR3ZWVuLmVsYXBzZWRUaW1lLSB0d2Vlbi5zdGFydERlbGF5KSkvdHdlZW4uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ucHJvZ3Jlc3MgPSBNYXRoVXRpbHMuY2xhbXAwMSgodHdlZW4uZWxhcHNlZFRpbWUgLSB0d2Vlbi5zdGFydERlbGF5KS90d2Vlbi5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGVmZmVjdCBvZiB0d2Vlbi5lZmZlY3RzKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBlYXNlIGZ1bmN0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gb3VyIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWFzZSA9IEVhc2VGdW5jdGlvbnNbZWZmZWN0LmVhc2VdKHR3ZWVuLnByb2dyZXNzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSB2YWx1ZSB0byBsZXJwIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gTWF0aFV0aWxzLmxlcnAoZWZmZWN0LnN0YXJ0LCBlZmZlY3QuZW5kLCBlYXNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3duZXJbZWZmZWN0LnByb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcbmltcG9ydCBUd2VlbkNvbnRyb2xsZXIgZnJvbSBcIi4vVHdlZW5Db250cm9sbGVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR3ZWVuTWFuYWdlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFR3ZWVuTWFuYWdlciA9IG51bGw7XG4gICAgXG4gICAgcHJvdGVjdGVkIHR3ZWVuQ29udHJvbGxlcnM6IEFycmF5PFR3ZWVuQ29udHJvbGxlcj47XG5cbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMudHdlZW5Db250cm9sbGVycyA9IG5ldyBBcnJheSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBUd2Vlbk1hbmFnZXIge1xuICAgICAgICBpZihUd2Vlbk1hbmFnZXIuaW5zdGFuY2UgPT09IG51bGwpe1xuICAgICAgICAgICAgVHdlZW5NYW5hZ2VyLmluc3RhbmNlID0gbmV3IFR3ZWVuTWFuYWdlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFR3ZWVuTWFuYWdlci5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICByZWdpc3RlclR3ZWVuQ29udHJvbGxlcihjb250cm9sbGVyOiBUd2VlbkNvbnRyb2xsZXIpe1xuICAgICAgICB0aGlzLnR3ZWVuQ29udHJvbGxlcnMucHVzaChjb250cm9sbGVyKTtcbiAgICB9XG5cbiAgICBkZXJlZ2lzdGVyVHdlZW5Db250cm9sbGVyKGNvbnRyb2xsZXI6IFR3ZWVuQ29udHJvbGxlcil7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMudHdlZW5Db250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLnR3ZWVuQ29udHJvbGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICBjbGVhclR3ZWVuQ29udHJvbGxlcnMoKXtcbiAgICAgICAgdGhpcy50d2VlbkNvbnRyb2xsZXJzID0gbmV3IEFycmF5KCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGZvcihsZXQgdHdlZW5Db250cm9sbGVyIG9mIHRoaXMudHdlZW5Db250cm9sbGVycyl7XG4gICAgICAgICAgICB0d2VlbkNvbnRyb2xsZXIudXBkYXRlKGRlbHRhVCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljXCI7XG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRcIjtcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvVUlMYXllclwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IEdyYXBoaWNSZW5kZXJlciBmcm9tIFwiLi9DYW52YXNSZW5kZXJpbmcvR3JhcGhpY1JlbmRlcmVyXCI7XG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi9SZW5kZXJpbmdNYW5hZ2VyXCJcbmltcG9ydCBUaWxlbWFwUmVuZGVyZXIgZnJvbSBcIi4vQ2FudmFzUmVuZGVyaW5nL1RpbGVtYXBSZW5kZXJlclwiO1xuaW1wb3J0IFVJRWxlbWVudFJlbmRlcmVyIGZyb20gXCIuL0NhbnZhc1JlbmRlcmluZy9VSUVsZW1lbnRSZW5kZXJlclwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XG5pbXBvcnQgQnV0dG9uIGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvblwiO1xuaW1wb3J0IFNsaWRlciBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50cy9TbGlkZXJcIjtcbmltcG9ydCBUZXh0SW5wdXQgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvVGV4dElucHV0XCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xuaW1wb3J0IExpbmUgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL0xpbmVcIjtcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUmVuZGVyaW5nTWFuYWdlciBjbGFzcyB1c2luZyBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbnZhc1JlbmRlcmVyIGV4dGVuZHMgUmVuZGVyaW5nTWFuYWdlciB7XG4gICAgcHJvdGVjdGVkIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICAgIHByb3RlY3RlZCBncmFwaGljUmVuZGVyZXI6IEdyYXBoaWNSZW5kZXJlcjtcbiAgICBwcm90ZWN0ZWQgdGlsZW1hcFJlbmRlcmVyOiBUaWxlbWFwUmVuZGVyZXI7XG4gICAgcHJvdGVjdGVkIHVpRWxlbWVudFJlbmRlcmVyOiBVSUVsZW1lbnRSZW5kZXJlcjtcblxuICAgIHByb3RlY3RlZCBvcmlnaW46IFZlYzI7XG4gICAgcHJvdGVjdGVkIHpvb206IG51bWJlcjtcblxuICAgIHByb3RlY3RlZCB3b3JsZFNpemU6IFZlYzI7XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIHNldFNjZW5lKHNjZW5lOiBTY2VuZSl7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5ncmFwaGljUmVuZGVyZXIuc2V0U2NlbmUoc2NlbmUpO1xuICAgICAgICB0aGlzLnRpbGVtYXBSZW5kZXJlci5zZXRTY2VuZShzY2VuZSk7XG4gICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIuc2V0U2NlbmUoc2NlbmUpO1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIGluaXRpYWxpemVDYW52YXMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQge1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICB0aGlzLndvcmxkU2l6ZSA9IG5ldyBWZWMyKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIHRoaXMuY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlciA9IG5ldyBHcmFwaGljUmVuZGVyZXIodGhpcy5jdHgpO1xuICAgICAgICB0aGlzLnRpbGVtYXBSZW5kZXJlciA9IG5ldyBUaWxlbWFwUmVuZGVyZXIodGhpcy5jdHgpO1xuICAgICAgICB0aGlzLnVpRWxlbWVudFJlbmRlcmVyID0gbmV3IFVJRWxlbWVudFJlbmRlcmVyKHRoaXMuY3R4KVxuXG4gICAgICAgIC8vIEZvciBjcmlzcCBwaXhlbCBhcnRcbiAgICAgICAgdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3R4O1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIHJlbmRlcih2aXNpYmxlU2V0OiBDYW52YXNOb2RlW10sIHRpbGVtYXBzOiBUaWxlbWFwW10sIHVpTGF5ZXJzOiBNYXA8VUlMYXllcj4pOiB2b2lkIHtcbiAgICAgICAgLy8gU29ydCBieSBkZXB0aCwgdGhlbiBieSB2aXNpYmxlIHNldCBieSB5LXZhbHVlXG4gICAgICAgIHZpc2libGVTZXQuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYoYS5nZXRMYXllcigpLmdldERlcHRoKCkgPT09IGIuZ2V0TGF5ZXIoKS5nZXREZXB0aCgpKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGEuYm91bmRhcnkuYm90dG9tKSAtIChiLmJvdW5kYXJ5LmJvdHRvbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmdldExheWVyKCkuZ2V0RGVwdGgoKSAtIGIuZ2V0TGF5ZXIoKS5nZXREZXB0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgdGlsZW1hcEluZGV4ID0gMDtcbiAgICAgICAgbGV0IHRpbGVtYXBMZW5ndGggPSB0aWxlbWFwcy5sZW5ndGg7XG5cbiAgICAgICAgbGV0IHZpc2libGVTZXRJbmRleCA9IDA7XG4gICAgICAgIGxldCB2aXNpYmxlU2V0TGVuZ3RoID0gdmlzaWJsZVNldC5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUodGlsZW1hcEluZGV4IDwgdGlsZW1hcExlbmd0aCB8fCB2aXNpYmxlU2V0SW5kZXggPCB2aXNpYmxlU2V0TGVuZ3RoKXtcbiAgICAgICAgICAgIC8vIENoZWNrIGNvbmRpdGlvbnMgd2hlcmUgd2UndmUgYWxyZWFkeSByZWFjaGVkIHRoZSBlZGdlIG9mIG9uZSBsaXN0XG4gICAgICAgICAgICBpZih0aWxlbWFwSW5kZXggPj0gdGlsZW1hcExlbmd0aCl7XG4gICAgICAgICAgICAgICAgLy8gT25seSByZW5kZXIgdGhlIHJlbWFpbmluZyB2aXNpYmxlIHNldFxuICAgICAgICAgICAgICAgIGxldCBub2RlID0gdmlzaWJsZVNldFt2aXNpYmxlU2V0SW5kZXgrK107XG4gICAgICAgICAgICAgICAgaWYobm9kZS52aXNpYmxlKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodmlzaWJsZVNldEluZGV4ID49IHZpc2libGVTZXRMZW5ndGgpe1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVuZGVyIHRpbGVtYXBzXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaWxlbWFwKHRpbGVtYXBzW3RpbGVtYXBJbmRleCsrXSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbmRlciB3aGljaGV2ZXIgaXMgZnVydGhlciBkb3duXG4gICAgICAgICAgICBpZih0aWxlbWFwc1t0aWxlbWFwSW5kZXhdLmdldExheWVyKCkuZ2V0RGVwdGgoKSA8PSB2aXNpYmxlU2V0W3Zpc2libGVTZXRJbmRleF0uZ2V0TGF5ZXIoKS5nZXREZXB0aCgpKXtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbGVtYXAodGlsZW1hcHNbdGlsZW1hcEluZGV4KytdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB2aXNpYmxlU2V0W3Zpc2libGVTZXRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZihub2RlLnZpc2libGUpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVuZGVyIHRoZSB1aUxheWVycyBvbiB0b3Agb2YgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGxldCBzb3J0ZWRVSUxheWVycyA9IG5ldyBBcnJheTxVSUxheWVyPigpO1xuXG4gICAgICAgIHVpTGF5ZXJzLmZvckVhY2goa2V5ID0+IHNvcnRlZFVJTGF5ZXJzLnB1c2godWlMYXllcnMuZ2V0KGtleSkpKTtcblxuICAgICAgICBzb3J0ZWRVSUxheWVycyA9IHNvcnRlZFVJTGF5ZXJzLnNvcnQoKHVpMSwgdWkyKSA9PiB1aTEuZ2V0RGVwdGgoKSAtIHVpMi5nZXREZXB0aCgpKTtcblxuICAgICAgICBzb3J0ZWRVSUxheWVycy5mb3JFYWNoKHVpTGF5ZXIgPT4ge1xuXHRcdFx0aWYoIXVpTGF5ZXIuaXNIaWRkZW4oKSlcblx0XHRcdFx0dWlMYXllci5nZXRJdGVtcygpLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCg8Q2FudmFzTm9kZT5ub2RlKS52aXNpYmxlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZSg8Q2FudmFzTm9kZT5ub2RlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcblx0XHR9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgc3BlY2lmaWVkIENhbnZhc05vZGVcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgQ2FudmFzTm9kZSB0byByZW5kZXJcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcmVuZGVyTm9kZShub2RlOiBDYW52YXNOb2RlKTogdm9pZCB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgb3JpZ2luIG9mIHRoZSB2aWV3cG9ydCBhY2NvcmRpbmcgdG8gdGhpcyBzcHJpdGVcbiAgICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbihub2RlKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIHNjZW5lXG4gICAgICAgIHRoaXMuem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBNb3ZlIHRoZSBjYW52YXMgdG8gdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGFuZCByb3RhdGVcbiAgICAgICAgbGV0IHhTY2FsZSA9IDE7XG4gICAgICAgIGxldCB5U2NhbGUgPSAxO1xuICAgICAgICBcbiAgICAgICAgaWYobm9kZSBpbnN0YW5jZW9mIFNwcml0ZSl7XG4gICAgICAgICAgICB4U2NhbGUgPSBub2RlLmludmVydFggPyAtMSA6IDE7XG4gICAgICAgICAgICB5U2NhbGUgPSBub2RlLmludmVydFkgPyAtMSA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oeFNjYWxlLCAwLCAwLCB5U2NhbGUsIChub2RlLnBvc2l0aW9uLnggLSB0aGlzLm9yaWdpbi54KSp0aGlzLnpvb20sIChub2RlLnBvc2l0aW9uLnkgLSB0aGlzLm9yaWdpbi55KSp0aGlzLnpvb20pO1xuICAgICAgICB0aGlzLmN0eC5yb3RhdGUoLW5vZGUucm90YXRpb24pO1xuICAgICAgICBsZXQgZ2xvYmFsQWxwaGEgPSB0aGlzLmN0eC5nbG9iYWxBbHBoYTtcbiAgICAgICAgaWYobm9kZSBpbnN0YW5jZW9mIFJlY3Qpe1xuICAgICAgICAgICAgRGVidWcubG9nKFwibm9kZVwiICsgbm9kZS5pZCwgXCJOb2RlXCIgKyBub2RlLmlkICsgXCIgQWxwaGE6IFwiICsgbm9kZS5hbHBoYSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBub2RlLmFscGhhO1xuICAgICAgICBcbiAgICAgICAgaWYobm9kZSBpbnN0YW5jZW9mIEFuaW1hdGVkU3ByaXRlKXtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQW5pbWF0ZWRTcHJpdGUoPEFuaW1hdGVkU3ByaXRlPm5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIFNwcml0ZSl7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclNwcml0ZSg8U3ByaXRlPm5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIEdyYXBoaWMpe1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJHcmFwaGljKDxHcmFwaGljPm5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIFVJRWxlbWVudCl7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclVJRWxlbWVudCg8VUlFbGVtZW50Pm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYTtcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIHByb3RlY3RlZCByZW5kZXJTcHJpdGUoc3ByaXRlOiBTcHJpdGUpOiB2b2lkIHtcbiAgICAgICAgLy8gR2V0IHRoZSBpbWFnZSBmcm9tIHRoZSByZXNvdXJjZSBtYW5hZ2VyXG4gICAgICAgIGxldCBpbWFnZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEltYWdlKHNwcml0ZS5pbWFnZUlkKTtcblxuICAgICAgICAvKlxuICAgICAgICAgICAgQ29vcmRpbmF0ZXMgaW4gdGhlIHNwYWNlIG9mIHRoZSBpbWFnZTpcbiAgICAgICAgICAgICAgICBpbWFnZSBjcm9wIHN0YXJ0IC0+IHgsIHlcbiAgICAgICAgICAgICAgICBpbWFnZSBjcm9wIHNpemUgIC0+IHcsIGhcbiAgICAgICAgICAgIENvb3JkaW5hdGVzIGluIHRoZSBzcGFjZSBvZiB0aGUgd29ybGRcbiAgICAgICAgICAgICAgICBpbWFnZSBkcmF3IHN0YXJ0IC0+IHgsIHlcbiAgICAgICAgICAgICAgICBpbWFnZSBkcmF3IHNpemUgIC0+IHcsIGhcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGltYWdlLFxuICAgICAgICAgICAgc3ByaXRlLmltYWdlT2Zmc2V0LngsIHNwcml0ZS5pbWFnZU9mZnNldC55LFxuICAgICAgICAgICAgc3ByaXRlLnNpemUueCwgc3ByaXRlLnNpemUueSxcbiAgICAgICAgICAgICgtc3ByaXRlLnNpemUueCpzcHJpdGUuc2NhbGUueC8yKSp0aGlzLnpvb20sICgtc3ByaXRlLnNpemUueSpzcHJpdGUuc2NhbGUueS8yKSp0aGlzLnpvb20sXG4gICAgICAgICAgICBzcHJpdGUuc2l6ZS54ICogc3ByaXRlLnNjYWxlLngqdGhpcy56b29tLCBzcHJpdGUuc2l6ZS55ICogc3ByaXRlLnNjYWxlLnkqdGhpcy56b29tKTtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBwcm90ZWN0ZWQgcmVuZGVyQW5pbWF0ZWRTcHJpdGUoc3ByaXRlOiBBbmltYXRlZFNwcml0ZSk6IHZvaWQge1xuICAgICAgICAvLyBHZXQgdGhlIGltYWdlIGZyb20gdGhlIHJlc291cmNlIG1hbmFnZXJcbiAgICAgICAgbGV0IGltYWdlID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0SW1hZ2Uoc3ByaXRlLmltYWdlSWQpO1xuXG4gICAgICAgIGxldCBhbmltYXRpb25JbmRleCA9IHNwcml0ZS5hbmltYXRpb24uZ2V0SW5kZXhBbmRBZHZhbmNlQW5pbWF0aW9uKCk7XG5cbiAgICAgICAgbGV0IGFuaW1hdGlvbk9mZnNldCA9IHNwcml0ZS5nZXRBbmltYXRpb25PZmZzZXQoYW5pbWF0aW9uSW5kZXgpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBDb29yZGluYXRlcyBpbiB0aGUgc3BhY2Ugb2YgdGhlIGltYWdlOlxuICAgICAgICAgICAgICAgIGltYWdlIGNyb3Agc3RhcnQgLT4geCwgeVxuICAgICAgICAgICAgICAgIGltYWdlIGNyb3Agc2l6ZSAgLT4gdywgaFxuICAgICAgICAgICAgQ29vcmRpbmF0ZXMgaW4gdGhlIHNwYWNlIG9mIHRoZSB3b3JsZCAoZ2l2ZW4gd2UgbW92ZWQpXG4gICAgICAgICAgICAgICAgaW1hZ2UgZHJhdyBzdGFydCAtPiAtdy8yLCAtaC8yXG4gICAgICAgICAgICAgICAgaW1hZ2UgZHJhdyBzaXplICAtPiB3LCBoXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWFnZSxcbiAgICAgICAgICAgIHNwcml0ZS5pbWFnZU9mZnNldC54ICsgYW5pbWF0aW9uT2Zmc2V0LngsIHNwcml0ZS5pbWFnZU9mZnNldC55ICsgYW5pbWF0aW9uT2Zmc2V0LnksXG4gICAgICAgICAgICBzcHJpdGUuc2l6ZS54LCBzcHJpdGUuc2l6ZS55LFxuICAgICAgICAgICAgKC1zcHJpdGUuc2l6ZS54KnNwcml0ZS5zY2FsZS54LzIpKnRoaXMuem9vbSwgKC1zcHJpdGUuc2l6ZS55KnNwcml0ZS5zY2FsZS55LzIpKnRoaXMuem9vbSxcbiAgICAgICAgICAgIHNwcml0ZS5zaXplLnggKiBzcHJpdGUuc2NhbGUueCp0aGlzLnpvb20sIHNwcml0ZS5zaXplLnkgKiBzcHJpdGUuc2NhbGUueSp0aGlzLnpvb20pO1xuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIHByb3RlY3RlZCByZW5kZXJHcmFwaGljKGdyYXBoaWM6IEdyYXBoaWMpOiB2b2lkIHtcbiAgICAgICAgaWYoZ3JhcGhpYyBpbnN0YW5jZW9mIFBvaW50KXtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY1JlbmRlcmVyLnJlbmRlclBvaW50KDxQb2ludD5ncmFwaGljLCB0aGlzLnpvb20pO1xuICAgICAgICB9IGVsc2UgaWYoZ3JhcGhpYyBpbnN0YW5jZW9mIExpbmUpe1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljUmVuZGVyZXIucmVuZGVyTGluZSg8TGluZT5ncmFwaGljLCB0aGlzLm9yaWdpbiwgdGhpcy56b29tKTtcbiAgICAgICAgfSBlbHNlIGlmKGdyYXBoaWMgaW5zdGFuY2VvZiBSZWN0KXtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY1JlbmRlcmVyLnJlbmRlclJlY3QoPFJlY3Q+Z3JhcGhpYywgdGhpcy56b29tKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIHByb3RlY3RlZCByZW5kZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkIHtcbiAgICAgICAgaWYodGlsZW1hcCBpbnN0YW5jZW9mIE9ydGhvZ29uYWxUaWxlbWFwKXtcbiAgICAgICAgICAgIHRoaXMudGlsZW1hcFJlbmRlcmVyLnJlbmRlck9ydGhvZ29uYWxUaWxlbWFwKDxPcnRob2dvbmFsVGlsZW1hcD50aWxlbWFwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIHByb3RlY3RlZCByZW5kZXJVSUVsZW1lbnQodWlFbGVtZW50OiBVSUVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgaWYodWlFbGVtZW50IGluc3RhbmNlb2YgTGFiZWwpe1xuICAgICAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5yZW5kZXJMYWJlbCh1aUVsZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYodWlFbGVtZW50IGluc3RhbmNlb2YgQnV0dG9uKXtcbiAgICAgICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIucmVuZGVyQnV0dG9uKHVpRWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZih1aUVsZW1lbnQgaW5zdGFuY2VvZiBTbGlkZXIpe1xuICAgICAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5yZW5kZXJTbGlkZXIodWlFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIFRleHRJbnB1dCl7XG4gICAgICAgICAgICB0aGlzLnVpRWxlbWVudFJlbmRlcmVyLnJlbmRlclRleHRJbnB1dCh1aUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXIoY2xlYXJDb2xvcjogQ29sb3IpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud29ybGRTaXplLngsIHRoaXMud29ybGRTaXplLnkpO1xuICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBjbGVhckNvbG9yLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMud29ybGRTaXplLngsIHRoaXMud29ybGRTaXplLnkpO1xuICAgIH1cbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBMaW5lIGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi9TY2VuZS9TY2VuZVwiO1xuXG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyB0byBoZWxwIHRoZSBAcmVmZXJlbmNlW0NhbnZhc1JlbmRlcmVyXSByZW5kZXIgQHJlZmVyZW5jZVtHcmFwaGljXXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhcGhpY1JlbmRlcmVyIHtcbiAgICAvKiogVGhlIHJlc291cmNlIG1hbmFnZXIgb2YgdGhlIGdhbWUgZW5naW5lICovXG4gICAgcHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xuICAgIC8qKiBUaGUgY3VycmVudCBzY2VuZSAqL1xuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XG4gICAgLyoqIFRoZSByZW5kZXJpbmcgY29udGV4dCAqL1xuICAgIHByb3RlY3RlZCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblxuICAgIGNvbnN0cnVjdG9yKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKXtcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2NlbmUgb2YgdGhpcyBHcmFwaGljUmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIGN1cnJlbnQgc2NlbmVcbiAgICAgKi9cbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBwb2ludFxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIHpvb20gVGhlIHpvb20gbGV2ZWxcbiAgICAgKi9cbiAgICByZW5kZXJQb2ludChwb2ludDogUG9pbnQsIHpvb206IG51bWJlcik6IHZvaWQge1xuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IHBvaW50LmNvbG9yLnRvU3RyaW5nUkdCQSgpO1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgoLXBvaW50LnNpemUueC8yKSp6b29tLCAoLXBvaW50LnNpemUueS8yKSp6b29tLFxuICAgICAgICBwb2ludC5zaXplLngqem9vbSwgcG9pbnQuc2l6ZS55Knpvb20pO1xuICAgIH1cblxuICAgIHJlbmRlckxpbmUobGluZTogTGluZSwgb3JpZ2luOiBWZWMyLCB6b29tOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBsaW5lLmNvbG9yLnRvU3RyaW5nUkdCQSgpO1xuICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSBsaW5lLnRoaWNrbmVzcztcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKChsaW5lLmVuZC54IC0gbGluZS5zdGFydC54KSp6b29tLCAobGluZS5lbmQueSAtIGxpbmUuc3RhcnQueSkqem9vbSk7XG4gICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgcmVjdFxuICAgICAqIEBwYXJhbSByZWN0IFRoZSByZWN0IHRvIHJlbmRlclxuICAgICAqIEBwYXJhbSB6b29tIFRoZSB6b29tIGxldmVsXG4gICAgICovXG4gICAgcmVuZGVyUmVjdChyZWN0OiBSZWN0LCB6b29tOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgLy8gRHJhdyB0aGUgaW50ZXJpb3Igb2YgdGhlIHJlY3RcbiAgICAgICAgaWYocmVjdC5jb2xvci5hICE9PSAwKXtcbiAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHJlY3QuY29sb3IudG9TdHJpbmdSR0IoKTtcbiAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KCgtcmVjdC5zaXplLngvMikqem9vbSwgKC1yZWN0LnNpemUueS8yKSp6b29tLCByZWN0LnNpemUueCp6b29tLCByZWN0LnNpemUueSp6b29tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERyYXcgdGhlIGJvcmRlciBvZiB0aGUgcmVjdCBpZiBpdCBpc24ndCB0cmFuc3BhcmVudFxuICAgICAgICBpZihyZWN0LmJvcmRlckNvbG9yLmEgIT09IDApe1xuICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSByZWN0LmdldEJvcmRlckNvbG9yKCkudG9TdHJpbmdSR0IoKTtcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHJlY3QuZ2V0Qm9yZGVyV2lkdGgoKTtcbiAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZVJlY3QoKC1yZWN0LnNpemUueC8yKSp6b29tLCAoLXJlY3Quc2l6ZS55LzIpKnpvb20sIHJlY3Quc2l6ZS54Knpvb20sIHJlY3Quc2l6ZS55Knpvb20pO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IFRpbGVzZXQgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlc2V0XCI7XG5cbi8qKlxuICogQSB1dGlsaXR5IGNsYXNzIGZvciB0aGUgQHJlZmVyZW5jZVtDYW52YXNSZW5kZXJlcl0gdG8gcmVuZGVyIEByZWZlcmVuY2VbVGlsZW1hcF1zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVtYXBSZW5kZXJlciB7XG4gICAgcHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XG4gICAgcHJvdGVjdGVkIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuXG4gICAgY29uc3RydWN0b3IoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpe1xuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzY2VuZSBvZiB0aGlzIFRpbGVtYXBSZW5kZXJlclxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgY3VycmVudCBzY2VuZVxuICAgICAqL1xuICAgIHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbiBvcnRob2dvbmFsIHRpbGVtYXBcbiAgICAgKiBAcGFyYW0gdGlsZW1hcCBUaGUgdGlsZW1hcCB0byByZW5kZXJcbiAgICAgKi9cbiAgICByZW5kZXJPcnRob2dvbmFsVGlsZW1hcCh0aWxlbWFwOiBPcnRob2dvbmFsVGlsZW1hcCk6IHZvaWQge1xuICAgICAgICBsZXQgcHJldmlvdXNBbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xuICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHRpbGVtYXAuZ2V0TGF5ZXIoKS5nZXRBbHBoYSgpO1xuICAgICAgICBcbiAgICAgICAgbGV0IG9yaWdpbiA9IHRoaXMuc2NlbmUuZ2V0Vmlld1RyYW5zbGF0aW9uKHRpbGVtYXApO1xuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuc2NlbmUuZ2V0Vmlld3BvcnQoKS5nZXRIYWxmU2l6ZSgpO1xuICAgICAgICBsZXQgem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XG4gICAgICAgIGxldCBib3R0b21SaWdodCA9IG9yaWdpbi5jbG9uZSgpLmFkZChzaXplLnNjYWxlZCgyKnpvb20pKTtcblxuICAgICAgICBpZih0aWxlbWFwLnZpc2libGUpe1xuICAgICAgICAgICAgbGV0IG1pbkNvbFJvdyA9IHRpbGVtYXAuZ2V0Q29sUm93QXQob3JpZ2luKTtcbiAgICAgICAgICAgIGxldCBtYXhDb2xSb3cgPSB0aWxlbWFwLmdldENvbFJvd0F0KGJvdHRvbVJpZ2h0KTtcblxuICAgICAgICAgICAgZm9yKGxldCB4ID0gbWluQ29sUm93Lng7IHggPD0gbWF4Q29sUm93Lng7IHgrKyl7XG4gICAgICAgICAgICAgICAgZm9yKGxldCB5ID0gbWluQ29sUm93Lnk7IHkgPD0gbWF4Q29sUm93Lnk7IHkrKyl7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdGlsZSBhdCB0aGlzIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGxldCB0aWxlID0gdGlsZW1hcC5nZXRUaWxlQXRSb3dDb2wobmV3IFZlYzIoeCwgeSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIHJvdC9mbGlwIHBhcmFtZXRlcnMgaWYgdGhlcmUgYXJlIGFueVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gKDB4RSA8PCAyOCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdEZsaXAgPSAoKG1hc2sgJiB0aWxlKSA+PiAyOCkgJiAweEY7XG4gICAgICAgICAgICAgICAgICAgIHRpbGUgPSB0aWxlICYgfm1hc2s7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgdGlsZXNldCB0aGF0IG93bnMgdGhpcyB0aWxlIGluZGV4IGFuZCByZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB0aWxlc2V0IG9mIHRpbGVtYXAuZ2V0VGlsZXNldHMoKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aWxlc2V0Lmhhc1RpbGUodGlsZSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZSh0aWxlc2V0LCB0aWxlLCB4LCB5LCBvcmlnaW4sIHRpbGVtYXAuc2NhbGUsIHpvb20sIHJvdEZsaXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBwcmV2aW91c0FscGhhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSB0aWxlXG4gICAgICogQHBhcmFtIHRpbGVzZXQgVGhlIHRpbGVzZXQgdGhpcyB0aWxlIGJlbG9uZ3MgdG8gXG4gICAgICogQHBhcmFtIHRpbGVJbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGVcbiAgICAgKiBAcGFyYW0gdGlsZW1hcFJvdyBUaGUgcm93IG9mIHRoZSB0aWxlIGluIHRoZSB0aWxlbWFwXG4gICAgICogQHBhcmFtIHRpbGVtYXBDb2wgVGhlIGNvbHVtbiBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZW1hcFxuICAgICAqIEBwYXJhbSBvcmlnaW4gVGhlIG9yaWdpbiBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gc2NhbGUgVGhlIHNjYWxlIG9mIHRoZSB0aWxlbWFwXG4gICAgICogQHBhcmFtIHpvb20gVGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXdwb3J0XG4gICAgICovXG4gICAgcHJvdGVjdGVkIHJlbmRlclRpbGUodGlsZXNldDogVGlsZXNldCwgdGlsZUluZGV4OiBudW1iZXIsIHRpbGVtYXBSb3c6IG51bWJlciwgdGlsZW1hcENvbDogbnVtYmVyLCBvcmlnaW46IFZlYzIsIHNjYWxlOiBWZWMyLCB6b29tOiBudW1iZXIsIHJvdEZsaXA6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRJbWFnZSh0aWxlc2V0LmdldEltYWdlS2V5KCkpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgdHJ1ZSBpbmRleFxuICAgICAgICBsZXQgaW5kZXggPSB0aWxlSW5kZXggLSB0aWxlc2V0LmdldFN0YXJ0SW5kZXgoKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHJvdyBhbmQgY29sIG9mIHRoZSB0aWxlIGluIGltYWdlIHNwYWNlXG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGlsZXNldC5nZXROdW1Db2xzKCkpO1xuICAgICAgICBsZXQgY29sID0gaW5kZXggJSB0aWxlc2V0LmdldE51bUNvbHMoKTtcbiAgICAgICAgbGV0IHdpZHRoID0gdGlsZXNldC5nZXRUaWxlU2l6ZSgpLng7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aWxlc2V0LmdldFRpbGVTaXplKCkueTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIHRvIHN0YXJ0IGEgY3JvcCBpbiB0aGUgdGlsZXNldCBpbWFnZVxuICAgICAgICBsZXQgbGVmdCA9IGNvbCAqIHdpZHRoO1xuICAgICAgICBsZXQgdG9wID0gcm93ICogaGVpZ2h0O1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gaW4gdGhlIHdvcmxkIHRvIHJlbmRlciB0aGUgdGlsZVxuICAgICAgICBsZXQgeCA9IE1hdGguZmxvb3IodGlsZW1hcFJvdyAqIHdpZHRoICogc2NhbGUueCk7XG4gICAgICAgIGxldCB5ID0gTWF0aC5mbG9vcih0aWxlbWFwQ29sICogaGVpZ2h0ICogc2NhbGUueSk7XG5cbiAgICAgICAgbGV0IHdvcmxkWCA9IE1hdGguZmxvb3IoKHggLSBvcmlnaW4ueCkqem9vbSk7XG4gICAgICAgIGxldCB3b3JsZFkgPSBNYXRoLmZsb29yKCh5IC0gb3JpZ2luLnkpKnpvb20pO1xuICAgICAgICBsZXQgd29ybGRXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIHNjYWxlLnggKiB6b29tKTtcbiAgICAgICAgbGV0IHdvcmxkSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIHNjYWxlLnkgKiB6b29tKTtcblxuICAgICAgICBpZihyb3RGbGlwICE9PSAwKXtcbiAgICAgICAgICAgIGxldCBzY2FsZVggPSAxO1xuICAgICAgICAgICAgbGV0IHNjYWxlWSA9IDE7XG4gICAgICAgICAgICBsZXQgc2hlYXJYID0gMDtcbiAgICAgICAgICAgIGxldCBzaGVhclkgPSAwO1xuXG4gICAgICAgICAgICAvLyBGbGlwIG9uIHRoZSB4LWF4aXNcbiAgICAgICAgICAgIGlmKHJvdEZsaXAgJiA4KXtcbiAgICAgICAgICAgICAgICBzY2FsZVggPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmxpcCBvbiB0aGUgeS1heGlzXG4gICAgICAgICAgICBpZihyb3RGbGlwICYgNCl7XG4gICAgICAgICAgICAgICAgc2NhbGVZID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZsaXAgb3ZlciB0aGUgbGluZSB5PXhcbiAgICAgICAgICAgIGlmKHJvdEZsaXAgJiAyKXtcbiAgICAgICAgICAgICAgICBzaGVhclggPSBzY2FsZVk7XG4gICAgICAgICAgICAgICAgc2hlYXJZID0gc2NhbGVYO1xuICAgICAgICAgICAgICAgIHNjYWxlWCA9IDA7XG4gICAgICAgICAgICAgICAgc2NhbGVZID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKHNjYWxlWCwgc2hlYXJYLCBzaGVhclksIHNjYWxlWSwgd29ybGRYICsgd29ybGRXaWR0aC8yLCB3b3JsZFkgKyB3b3JsZEhlaWdodC8yKTtcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBSZW5kZXIgdGhlIHRpbGVcbiAgICAgICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWFnZSxcbiAgICAgICAgICAgICAgICBsZWZ0LCB0b3AsXG4gICAgICAgICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICAgICAgICAtd29ybGRXaWR0aC8yLCAtd29ybGRIZWlnaHQvMixcbiAgICAgICAgICAgICAgICB3b3JsZFdpZHRoLCB3b3JsZEhlaWdodCk7XG5cbiAgICAgICAgICAgIGlmKHJvdEZsaXAgIT09IDApe1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIHJvdGF0aW9ucywgZG9uJ3QgZG8gdGhlIGNhbGN1bGF0aW9ucywganVzdCByZW5kZXIgdGhlIHRpbGVcbiAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgdGlsZVxuICAgICAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGltYWdlLFxuICAgICAgICAgICAgICAgIGxlZnQsIHRvcCxcbiAgICAgICAgICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdvcmxkWCwgd29ybGRZLFxuICAgICAgICAgICAgICAgIHdvcmxkV2lkdGgsIHdvcmxkSGVpZ2h0KTtcbiAgICAgICAgfVxuXG5cbiAgICB9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgQnV0dG9uIGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvblwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XG5pbXBvcnQgU2xpZGVyIGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1NsaWRlclwiO1xuaW1wb3J0IFRleHRJbnB1dCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9UZXh0SW5wdXRcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uLy4uL1V0aWxzL01hdGhVdGlsc1wiO1xuXG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyB0byBoZWxwIHRoZSBAcmVmZXJlbmNlW0NhbnZhc1JlbmRlcmVyXSByZW5kZXIgQHJlZmVyZW5jZVtVSUVsZW1lbnRdc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVSUVsZW1lbnRSZW5kZXJlciB7XG4gICAgcHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XG4gICAgcHJvdGVjdGVkIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuXG4gICAgY29uc3RydWN0b3IoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpe1xuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzY2VuZSBvZiB0aGlzIFVJRWxlbWVudFJlbmRlcmVyXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBjdXJyZW50IHNjZW5lXG4gICAgICovXG4gICAgc2V0U2NlbmUoc2NlbmU6IFNjZW5lKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgbGFiZWxcbiAgICAgKiBAcGFyYW0gbGFiZWwgVGhlIGxhYmVsIHRvIHJlbmRlclxuICAgICAqL1xuICAgIHJlbmRlckxhYmVsKGxhYmVsOiBMYWJlbCk6IHZvaWQge1xuICAgICAgICAvLyBJZiB0aGUgc2l6ZSBpcyB1bmFzc2lnbmVkIChieSB0aGUgdXNlciBvciBhdXRvbWF0aWNhbGx5KSBhc3NpZ24gaXRcbiAgICAgICAgbGFiZWwuaGFuZGxlSW5pdGlhbFNpemluZyh0aGlzLmN0eCk7XG5cdFx0XG5cdFx0Ly8gR3JhYiB0aGUgZ2xvYmFsIGFscGhhIHNvIHdlIGNhbiBhZGp1c3QgaXQgZm9yIHRoaXMgcmVuZGVyXG5cdFx0bGV0IHByZXZpb3VzQWxwaGEgPSB0aGlzLmN0eC5nbG9iYWxBbHBoYTtcblxuICAgICAgICAvLyBHZXQgdGhlIGZvbnQgYW5kIHRleHQgcG9zaXRpb24gaW4gbGFiZWxcblx0XHR0aGlzLmN0eC5mb250ID0gbGFiZWwuZ2V0Rm9udFN0cmluZygpO1xuXHRcdGxldCBvZmZzZXQgPSBsYWJlbC5jYWxjdWxhdGVUZXh0T2Zmc2V0KHRoaXMuY3R4KTtcblxuXHRcdC8vIFN0cm9rZSBhbmQgZmlsbCBhIHJvdW5kZWQgcmVjdCBhbmQgZ2l2ZSBpdCB0ZXh0XG5cdFx0dGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBsYWJlbC5iYWNrZ3JvdW5kQ29sb3IuYTtcblx0XHR0aGlzLmN0eC5maWxsU3R5bGUgPSBsYWJlbC5jYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3IoKS50b1N0cmluZ1JHQkEoKTtcblx0XHR0aGlzLmN0eC5maWxsUm91bmRlZFJlY3QoLWxhYmVsLnNpemUueC8yLCAtbGFiZWwuc2l6ZS55LzIsXG5cdFx0XHRsYWJlbC5zaXplLngsIGxhYmVsLnNpemUueSwgbGFiZWwuYm9yZGVyUmFkaXVzKTtcblx0XHRcblx0XHR0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGxhYmVsLmNhbGN1bGF0ZUJvcmRlckNvbG9yKCkudG9TdHJpbmdSR0JBKCk7XG5cdFx0dGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBsYWJlbC5ib3JkZXJDb2xvci5hO1xuXHRcdHRoaXMuY3R4LmxpbmVXaWR0aCA9IGxhYmVsLmJvcmRlcldpZHRoO1xuXHRcdHRoaXMuY3R4LnN0cm9rZVJvdW5kZWRSZWN0KC1sYWJlbC5zaXplLngvMiwgLWxhYmVsLnNpemUueS8yLFxuXHRcdFx0bGFiZWwuc2l6ZS54LCBsYWJlbC5zaXplLnksIGxhYmVsLmJvcmRlclJhZGl1cyk7XG5cblx0XHR0aGlzLmN0eC5maWxsU3R5bGUgPSBsYWJlbC5jYWxjdWxhdGVUZXh0Q29sb3IoKTtcblx0XHR0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IGxhYmVsLnRleHRDb2xvci5hO1xuXHRcdHRoaXMuY3R4LmZpbGxUZXh0KGxhYmVsLnRleHQsIG9mZnNldC54IC0gbGFiZWwuc2l6ZS54LzIsIG9mZnNldC55IC0gbGFiZWwuc2l6ZS55LzIpO1xuXHRcblx0XHR0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHByZXZpb3VzQWxwaGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGJ1dHRvblxuICAgICAqIEBwYXJhbSBidXR0b24gVGhlIGJ1dHRvbiB0byByZW5kZXJcbiAgICAgKi9cbiAgICByZW5kZXJCdXR0b24oYnV0dG9uOiBCdXR0b24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5yZW5kZXJMYWJlbChidXR0b24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBzbGlkZXJcbiAgICAgKiBAcGFyYW0gc2xpZGVyIFRoZSBzbGlkZXIgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcmVuZGVyU2xpZGVyKHNsaWRlcjogU2xpZGVyKTogdm9pZCB7XG5cdFx0Ly8gR3JhYiB0aGUgZ2xvYmFsIGFscGhhIHNvIHdlIGNhbiBhZGp1c3QgaXQgZm9yIHRoaXMgcmVuZGVyXG5cdFx0bGV0IHByZXZpb3VzQWxwaGEgPSB0aGlzLmN0eC5nbG9iYWxBbHBoYTtcblx0XHR0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHNsaWRlci5nZXRMYXllcigpLmdldEFscGhhKCk7XG5cbiAgICAgICAgLy8gQ2FsY3VhbGF0ZSB0aGUgc2xpZGVyIHNpemVcbiAgICAgICAgbGV0IHNsaWRlclNpemUgPSBuZXcgVmVjMihzbGlkZXIuc2l6ZS54LCAyKTtcblxuICAgICAgICAvLyBEcmF3IHRoZSBzbGlkZXJcblx0XHR0aGlzLmN0eC5maWxsU3R5bGUgPSBzbGlkZXIuc2xpZGVyQ29sb3IudG9TdHJpbmcoKTtcblx0XHR0aGlzLmN0eC5maWxsUm91bmRlZFJlY3QoLXNsaWRlclNpemUueC8yLCAtc2xpZGVyU2l6ZS55LzIsXG4gICAgICAgICAgICBzbGlkZXJTaXplLngsIHNsaWRlclNpemUueSwgc2xpZGVyLmJvcmRlclJhZGl1cyk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBuaWIgc2l6ZSBhbmQgcG9zaXRpb25cbiAgICAgICAgbGV0IHggPSBNYXRoVXRpbHMubGVycCgtc2xpZGVyLnNpemUueC8yLCBzbGlkZXIuc2l6ZS54LzIsIHNsaWRlci5nZXRWYWx1ZSgpKTtcblxuICAgICAgICAvLyBEcmF3IHRoZSBuaWJcblx0XHR0aGlzLmN0eC5maWxsU3R5bGUgPSBzbGlkZXIubmliQ29sb3IudG9TdHJpbmcoKTtcblx0XHR0aGlzLmN0eC5maWxsUm91bmRlZFJlY3QoeC1zbGlkZXIubmliU2l6ZS54LzIsIC1zbGlkZXIubmliU2l6ZS55LzIsXG4gICAgICAgICAgICBzbGlkZXIubmliU2l6ZS54LCBzbGlkZXIubmliU2l6ZS55LCBzbGlkZXIuYm9yZGVyUmFkaXVzKTtcblxuICAgICAgICAvLyBSZXNldCB0aGUgYWxwaGFcbiAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBwcmV2aW91c0FscGhhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSB0ZXh0SW5wdXRcbiAgICAgKiBAcGFyYW0gdGV4dElucHV0IFRoZSB0ZXh0SW5wdXQgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcmVuZGVyVGV4dElucHV0KHRleHRJbnB1dDogVGV4dElucHV0KTogdm9pZCB7XG4gICAgICAgIC8vIFNob3cgYSBjdXJzb3Igc29tZXRpbWVzXG4gICAgICAgIGlmKHRleHRJbnB1dC5mb2N1c2VkICYmIHRleHRJbnB1dC5jdXJzb3JDb3VudGVyICUgNjAgPiAzMCl7XG4gICAgICAgICAgICB0ZXh0SW5wdXQudGV4dCArPSBcInxcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVuZGVyTGFiZWwodGV4dElucHV0KTtcblxuICAgICAgICBpZih0ZXh0SW5wdXQuZm9jdXNlZCl7XG4gICAgICAgICAgICBpZih0ZXh0SW5wdXQuY3Vyc29yQ291bnRlciAlIDYwID4gMzApe1xuICAgICAgICAgICAgICAgIHRleHRJbnB1dC50ZXh0ID0gdGV4dElucHV0LnRleHQuc3Vic3RyaW5nKDAsIHRleHRJbnB1dC50ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0SW5wdXQuY3Vyc29yQ291bnRlciArPSAxO1xuICAgICAgICAgICAgaWYodGV4dElucHV0LmN1cnNvckNvdW50ZXIgPj0gNjApe1xuICAgICAgICAgICAgICAgIHRleHRJbnB1dC5jdXJzb3JDb3VudGVyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY1wiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBcIjtcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudFwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFVJTGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9VSUxheWVyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XG5cbi8qKlxuICogQW4gYWJzdHJhY3QgZnJhbWV3b3JrIHRvIHB1dCBhbGwgcmVuZGVyaW5nIGluIG9uY2UgcGxhY2UgaW4gdGhlIGFwcGxpY2F0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFJlbmRlcmluZ01hbmFnZXIge1xuICAgIC8qKiBUaGUgUmVzb3VyY2VNYW5hZ2VyICovXG4gICAgcHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xuXG4gICAgLyoqIFRoZSBzY2VuZSBjdXJyZW50bHkgYmVpbmcgcmVuZGVyZWQgKi9cbiAgICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xuXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzY2VuZSBjdXJyZW50bHkgYmVpbmcgcmVuZGVyZWRcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIGN1cnJlbnQgU2NlbmVcbiAgICAgKi9cbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIGNhbnZhcyBmb3IgdGhlIGdhbWVcbiAgICAgKiBAcGFyYW0gY2FudmFzIFRoZSBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIGhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIGNhbnZhc1xuICAgICAqIEByZXR1cm5zIFRoZSByZW5kZXJpbmcgY29udGV4dCBvZiB0aGUgY2FudmFzXG4gICAgICovXG4gICAgYWJzdHJhY3QgaW5pdGlhbGl6ZUNhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHZpc2libGUgc2V0IG9mIENhbnZhc05vZGVzIGFuZCB2aXNpYmxlIHBvcnRpb25zIG9mIHRpbGVtYXBzLCBhcyB3ZWxsIGFzIGFueSBVSUVsZW1lbnQgaW4gVUlMYXllcnNcbiAgICAgKiBAcGFyYW0gdmlzaWJsZVNldCBUaGUgdmlzaWJsZSBzZXQgb2YgQ2FudmFzTm9kZXNcbiAgICAgKiBAcGFyYW0gdGlsZW1hcHMgVGhlIHRpbGVtYXBzIHVzZWQgaW4gdGhlIGFwcGxpY2F0aW9uXG4gICAgICogQHBhcmFtIHVpTGF5ZXJzIFRoZSB1c2VyIGludGVyZmFjZSBsYXllcnNcbiAgICAgKi9cbiAgICBhYnN0cmFjdCByZW5kZXIodmlzaWJsZVNldDogQXJyYXk8Q2FudmFzTm9kZT4sIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPiwgdWlMYXllcnM6IE1hcDxVSUxheWVyPik6IHZvaWQ7XG5cbiAgICAvKiogQ2xlYXJzIHRoZSBjYW52YXMgKi9cbiAgICBhYnN0cmFjdCBjbGVhcihjb2xvcjogQ29sb3IpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHNwcml0ZVxuICAgICAqIEBwYXJhbSBzcHJpdGUgVGhlIHNwcml0ZSB0byByZW5kZXJcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyU3ByaXRlKHNwcml0ZTogU3ByaXRlKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYW4gYW5pbWF0ZWQgc3ByaXRlXG4gICAgICogQHBhcmFtIHNwcml0ZSBUaGUgYW5pbWF0ZWQgc3ByaXRlIHRvIHJlbmRlclxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJBbmltYXRlZFNwcml0ZShzcHJpdGU6IEFuaW1hdGVkU3ByaXRlKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBncmFwaGljXG4gICAgICogQHBhcmFtIGdyYXBoaWMgVGhlIGdyYXBoaWMgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlckdyYXBoaWMoZ3JhcGhpYzogR3JhcGhpYyk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgdGlsZW1hcFxuICAgICAqIEBwYXJhbSB0aWxlbWFwIFRoZSB0aWxlbWFwIHRvIHJlbmRlclxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgVUlFbGVtZW50XG4gICAgICogQHBhcmFtIHVpRWxlbWVudCBUaGUgVUlFbGVtZW50IHRvIHJlbmRlclxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJVSUVsZW1lbnQodWlFbGVtZW50OiBVSUVsZW1lbnQpOiB2b2lkO1xufSIsImltcG9ydCBHcmFwaCBmcm9tIFwiLi4vRGF0YVR5cGVzL0dyYXBocy9HcmFwaFwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNcIjtcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xuaW1wb3J0IFBvaW50IGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9Qb2ludFwiO1xuaW1wb3J0IFJlY3QgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRcIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xuaW1wb3J0IFNoYWRlclJlZ2lzdHJ5IGZyb20gXCIuLi9SZWdpc3RyeS9SZWdpc3RyaWVzL1NoYWRlclJlZ2lzdHJ5XCI7XG5pbXBvcnQgUmVnaXN0cnlNYW5hZ2VyIGZyb20gXCIuLi9SZWdpc3RyeS9SZWdpc3RyeU1hbmFnZXJcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBQYXJhbGxheExheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvUGFyYWxsYXhMYXllclwiO1xuaW1wb3J0IFVJTGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9VSUxheWVyXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgUmVuZGVyaW5nVXRpbHMgZnJvbSBcIi4uL1V0aWxzL1JlbmRlcmluZ1V0aWxzXCI7XG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi9SZW5kZXJpbmdNYW5hZ2VyXCI7XG5pbXBvcnQgU2hhZGVyVHlwZSBmcm9tIFwiLi9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJpbmdNYW5hZ2VyIHtcblxuXHRwcm90ZWN0ZWQgb3JpZ2luOiBWZWMyO1xuXHRwcm90ZWN0ZWQgem9vbTogbnVtYmVyO1xuXHRwcm90ZWN0ZWQgd29ybGRTaXplOiBWZWMyO1xuXG5cdHByb3RlY3RlZCBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuXHRwcm90ZWN0ZWQgdGV4dEN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuXG5cdGluaXRpYWxpemVDYW52YXMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQge1xuXHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0dGhpcy53b3JsZFNpemUgPSBWZWMyLlpFUk87XG5cdFx0dGhpcy53b3JsZFNpemUueCA9IHdpZHRoO1xuXHRcdHRoaXMud29ybGRTaXplLnkgPSBoZWlnaHQ7XG5cblx0XHQvLyBHZXQgdGhlIFdlYkdMIGNvbnRleHRcbiAgICAgICAgdGhpcy5nbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIik7XG5cblx0XHR0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cblx0XHR0aGlzLmdsLmRpc2FibGUodGhpcy5nbC5ERVBUSF9URVNUKTtcbiAgICAgICAgdGhpcy5nbC5lbmFibGUodGhpcy5nbC5CTEVORCk7XG4gICAgICAgIHRoaXMuZ2wuYmxlbmRGdW5jKHRoaXMuZ2wuU1JDX0FMUEhBLCB0aGlzLmdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkNVTExfRkFDRSk7XG5cblx0XHQvLyBUZWxsIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHdlJ3JlIHVzaW5nIFdlYkdMXG5cdFx0UmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkudXNlV2ViR0wodHJ1ZSwgdGhpcy5nbCk7XG5cblx0XHQvLyBTaG93IHRoZSB0ZXh0IGNhbnZhcyBhbmQgZ2V0IGl0cyBjb250ZXh0XG5cdFx0bGV0IHRleHRDYW52YXMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0ZXh0LWNhbnZhc1wiKTtcblx0XHR0ZXh0Q2FudmFzLmhpZGRlbiA9IGZhbHNlO1xuXHRcdHRoaXMudGV4dEN0eCA9IHRleHRDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG5cdFx0Ly8gU2l6ZSB0aGUgdGV4dCBjYW52YXMgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIGdhbWUgY2FudmFzXG5cdFx0dGV4dENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0dGV4dENhbnZhcy53aWR0aCA9IHdpZHRoO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdsO1xuXHR9XG5cblx0cmVuZGVyKHZpc2libGVTZXQ6IENhbnZhc05vZGVbXSwgdGlsZW1hcHM6IFRpbGVtYXBbXSwgdWlMYXllcnM6IE1hcDxVSUxheWVyPik6IHZvaWQge1xuXHRcdGZvcihsZXQgbm9kZSBvZiB2aXNpYmxlU2V0KXtcblx0XHRcdHRoaXMucmVuZGVyTm9kZShub2RlKTtcblx0XHR9XG5cblx0XHR1aUxheWVycy5mb3JFYWNoKGtleSA9PiB7XG5cdFx0XHRpZighdWlMYXllcnMuZ2V0KGtleSkuaXNIaWRkZW4oKSlcblx0XHRcdFx0dWlMYXllcnMuZ2V0KGtleSkuZ2V0SXRlbXMoKS5mb3JFYWNoKG5vZGUgPT4gdGhpcy5yZW5kZXJOb2RlKDxDYW52YXNOb2RlPm5vZGUpKVxuXHRcdH0pO1xuXHR9XG5cblx0Y2xlYXIoY29sb3I6IENvbG9yKTogdm9pZCB7XG5cdFx0dGhpcy5nbC5jbGVhckNvbG9yKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmEpO1xuXHRcdHRoaXMuZ2wuY2xlYXIodGhpcy5nbC5DT0xPUl9CVUZGRVJfQklUIHwgdGhpcy5nbC5ERVBUSF9CVUZGRVJfQklUKTtcblxuXHRcdHRoaXMudGV4dEN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53b3JsZFNpemUueCwgdGhpcy53b3JsZFNpemUueSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgcmVuZGVyTm9kZShub2RlOiBDYW52YXNOb2RlKTogdm9pZCB7XG5cdFx0Ly8gQ2FsY3VsYXRlIHRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0IGFjY29yZGluZyB0byB0aGlzIHNwcml0ZVxuICAgICAgICB0aGlzLm9yaWdpbiA9IHRoaXMuc2NlbmUuZ2V0Vmlld1RyYW5zbGF0aW9uKG5vZGUpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgem9vbSBsZXZlbCBvZiB0aGUgc2NlbmVcbiAgICAgICAgdGhpcy56b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcblx0XHRcblx0XHRpZihub2RlLmhhc0N1c3RvbVNoYWRlcil7XG5cdFx0XHQvLyBJZiB0aGUgbm9kZSBoYXMgYSBjdXN0b20gc2hhZGVyLCByZW5kZXIgdXNpbmcgdGhhdFxuXHRcdFx0dGhpcy5yZW5kZXJDdXN0b20obm9kZSk7XG5cdFx0fSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBHcmFwaGljKXtcblx0XHRcdHRoaXMucmVuZGVyR3JhcGhpYyhub2RlKTtcblx0XHR9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIFNwcml0ZSl7XG5cdFx0XHRpZihub2RlIGluc3RhbmNlb2YgQW5pbWF0ZWRTcHJpdGUpe1xuXHRcdFx0XHR0aGlzLnJlbmRlckFuaW1hdGVkU3ByaXRlKG5vZGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5yZW5kZXJTcHJpdGUobm9kZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBVSUVsZW1lbnQpe1xuXHRcdFx0dGhpcy5yZW5kZXJVSUVsZW1lbnQobm9kZSk7XG5cdFx0fVxuXHR9XG5cblx0cHJvdGVjdGVkIHJlbmRlclNwcml0ZShzcHJpdGU6IFNwcml0ZSk6IHZvaWQge1xuXHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQoU2hhZGVyUmVnaXN0cnkuU1BSSVRFX1NIQURFUik7XG5cdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMoc3ByaXRlKSwgc3ByaXRlKTtcblx0XHRzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHJlbmRlckFuaW1hdGVkU3ByaXRlKHNwcml0ZTogQW5pbWF0ZWRTcHJpdGUpOiB2b2lkIHtcblx0XHRsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KFNoYWRlclJlZ2lzdHJ5LlNQUklURV9TSEFERVIpO1xuXHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKHNwcml0ZSksIHNwcml0ZSk7XG5cdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcblx0fVxuXG5cdHByb3RlY3RlZCByZW5kZXJHcmFwaGljKGdyYXBoaWM6IEdyYXBoaWMpOiB2b2lkIHtcblxuXHRcdGlmKGdyYXBoaWMgaW5zdGFuY2VvZiBQb2ludCl7XG5cdFx0XHRsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KFNoYWRlclJlZ2lzdHJ5LlBPSU5UX1NIQURFUik7XG5cdFx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyhncmFwaGljKSwgZ3JhcGhpYyk7XG5cdFx0XHRzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSBpZihncmFwaGljIGluc3RhbmNlb2YgUmVjdCkge1xuXHRcdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5SRUNUX1NIQURFUik7XG5cdFx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyhncmFwaGljKSwgZ3JhcGhpYyk7XG5cdFx0XHRzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xuXHRcdH0gXG5cdH1cblxuXHRwcm90ZWN0ZWQgcmVuZGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG5cdH1cblxuXHRwcm90ZWN0ZWQgcmVuZGVyVUlFbGVtZW50KHVpRWxlbWVudDogVUlFbGVtZW50KTogdm9pZCB7XG5cdFx0aWYodWlFbGVtZW50IGluc3RhbmNlb2YgTGFiZWwpe1xuXHRcdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5MQUJFTF9TSEFERVIpO1xuXHRcdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnModWlFbGVtZW50KSwgdWlFbGVtZW50KTtcblx0XHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XG5cblx0XHRcdHRoaXMudGV4dEN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgKHVpRWxlbWVudC5wb3NpdGlvbi54IC0gdGhpcy5vcmlnaW4ueCkqdGhpcy56b29tLCAodWlFbGVtZW50LnBvc2l0aW9uLnkgLSB0aGlzLm9yaWdpbi55KSp0aGlzLnpvb20pO1xuXHRcdFx0dGhpcy50ZXh0Q3R4LnJvdGF0ZSgtdWlFbGVtZW50LnJvdGF0aW9uKTtcblx0XHRcdGxldCBnbG9iYWxBbHBoYSA9IHRoaXMudGV4dEN0eC5nbG9iYWxBbHBoYTtcblx0XHRcdHRoaXMudGV4dEN0eC5nbG9iYWxBbHBoYSA9IHVpRWxlbWVudC5hbHBoYTtcblxuXHRcdFx0Ly8gUmVuZGVyIHRleHRcblx0XHRcdHRoaXMudGV4dEN0eC5mb250ID0gdWlFbGVtZW50LmdldEZvbnRTdHJpbmcoKTtcblx0XHRcdGxldCBvZmZzZXQgPSB1aUVsZW1lbnQuY2FsY3VsYXRlVGV4dE9mZnNldCh0aGlzLnRleHRDdHgpO1xuXHRcdFx0dGhpcy50ZXh0Q3R4LmZpbGxTdHlsZSA9IHVpRWxlbWVudC5jYWxjdWxhdGVUZXh0Q29sb3IoKTtcblx0XHRcdHRoaXMudGV4dEN0eC5nbG9iYWxBbHBoYSA9IHVpRWxlbWVudC50ZXh0Q29sb3IuYTtcblx0XHRcdHRoaXMudGV4dEN0eC5maWxsVGV4dCh1aUVsZW1lbnQudGV4dCwgb2Zmc2V0LnggLSB1aUVsZW1lbnQuc2l6ZS54LzIsIG9mZnNldC55IC0gdWlFbGVtZW50LnNpemUueS8yKTtcblxuXHRcdFx0dGhpcy50ZXh0Q3R4Lmdsb2JhbEFscGhhID0gZ2xvYmFsQWxwaGE7XG4gICAgICAgIFx0dGhpcy50ZXh0Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHR9XG5cdH1cblxuXHRwcm90ZWN0ZWQgcmVuZGVyQ3VzdG9tKG5vZGU6IENhbnZhc05vZGUpOiB2b2lkIHtcblx0XHRsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KG5vZGUuY3VzdG9tU2hhZGVyS2V5KTtcblx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyhub2RlKSwgbm9kZSk7XG5cdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcblx0fVxuXG5cdHByb3RlY3RlZCBhZGRPcHRpb25zKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4sIG5vZGU6IENhbnZhc05vZGUpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcblx0XHQvLyBHaXZlIHRoZSBzaGFkZXIgYWNjZXNzIHRvIHRoZSB3b3JsZCBzaXplXG5cdFx0b3B0aW9ucy53b3JsZFNpemUgPSB0aGlzLndvcmxkU2l6ZTtcblxuXHRcdC8vIEFkanVzdCB0aGUgb3JpZ2luIHBvc2l0aW9uIHRvIHRoZSBwYXJhbGxheFxuXHRcdGxldCBsYXllciA9IG5vZGUuZ2V0TGF5ZXIoKTtcblx0XHRsZXQgcGFyYWxsYXggPSBuZXcgVmVjMigxLCAxKTtcblx0XHRpZihsYXllciBpbnN0YW5jZW9mIFBhcmFsbGF4TGF5ZXIpe1xuXHRcdFx0cGFyYWxsYXggPSAoPFBhcmFsbGF4TGF5ZXI+bGF5ZXIpLnBhcmFsbGF4O1xuXHRcdH1cblxuXHRcdG9wdGlvbnMub3JpZ2luID0gdGhpcy5vcmlnaW4uY2xvbmUoKS5tdWx0KHBhcmFsbGF4KTtcblxuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG5cbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvTWFwXCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuXG4vKipcbiAqIEEgd3JhcHBlciBjbGFzcyBmb3IgV2ViR0wgc2hhZGVycy5cbiAqIFRoaXMgY2xhc3MgaXMgYSBzaW5nbGV0b24sIGFuZCB0aGVyZSBpcyBvbmx5IG9uZSBmb3IgZWFjaCBzaGFkZXIgdHlwZS5cbiAqIEFsbCBvYmplY3RzIHRoYXQgdXNlIHRoaXMgc2hhZGVyIHR5cGUgd2lsbCByZWZlciB0byBhbmQgbW9kaWZ5IHRoaXMgc2FtZSB0eXBlLlxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJUeXBlIHtcblx0LyoqIFRoZSBuYW1lIG9mIHRoaXMgc2hhZGVyICovXG5cdHByb3RlY3RlZCBuYW1lOiBzdHJpbmc7XG5cblx0LyoqIFRoZSBrZXkgdG8gdGhlIFdlYkdMUHJvZ3JhbSBpbiB0aGUgUmVzb3VyY2VNYW5hZ2VyICovXG5cdHByb3RlY3RlZCBwcm9ncmFtS2V5OiBzdHJpbmc7XG5cblx0LyoqIEEgcmVmZXJlbmNlIHRvIHRoZSByZXNvdXJjZSBtYW5hZ2VyICovXG5cdHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcblxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xuXHRcdHRoaXMucHJvZ3JhbUtleSA9IHByb2dyYW1LZXk7XG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyBhbnkgYnVmZmVyIG9iamVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc2hhZGVyIHR5cGUuXG5cdCAqIEBwYXJhbSBnbCBUaGUgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcblx0ICovXG5cdGFic3RyYWN0IGluaXRCdWZmZXJPYmplY3QoKTogdm9pZDtcblxuXHQvKipcblx0ICogTG9hZHMgYW55IHVuaWZvcm1zXG5cdCAqIEBwYXJhbSBnbCBUaGUgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcblx0ICogQHBhcmFtIG9wdGlvbnMgSW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nXG5cdCAqL1xuXHRhYnN0cmFjdCByZW5kZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIEV4dHJhY3RzIHRoZSBvcHRpb25zIGZyb20gdGhlIENhbnZhc05vZGUgYW5kIGdpdmVzIHRoZW0gdG8gdGhlIHJlbmRlciBmdW5jdGlvblxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBnZXQgb3B0aW9ucyBmcm9tXG5cdCAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25zIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgcmVuZGVyIGZ1bmN0aW9uXG5cdCAqL1xuXHRnZXRPcHRpb25zKG5vZGU6IENhbnZhc05vZGUpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtyZXR1cm4ge307fVxufSIsImltcG9ydCBNYXQ0eDQgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9NYXQ0eDRcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IERlYnVnIGZyb20gXCIuLi8uLi8uLi9EZWJ1Zy9EZWJ1Z1wiO1xuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uLy4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFF1YWRTaGFkZXJUeXBlIGZyb20gXCIuL1F1YWRTaGFkZXJUeXBlXCI7XG5cbi8qKiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFiZWxTaGFkZXJUeXBlIGV4dGVuZHMgUXVhZFNoYWRlclR5cGUge1xuXG5cdGNvbnN0cnVjdG9yKHByb2dyYW1LZXk6IHN0cmluZyl7XG5cdFx0c3VwZXIocHJvZ3JhbUtleSk7XG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcblx0fVxuXG5cdGluaXRCdWZmZXJPYmplY3QoKTogdm9pZCB7XG5cdFx0dGhpcy5idWZmZXJPYmplY3RLZXkgPSBcImxhYmVsXCI7XG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcblx0fVxuXG5cdHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG5cdFx0Y29uc3QgYmFja2dyb3VuZENvbG9yID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IudG9XZWJHTCgpO1xuXHRcdGNvbnN0IGJvcmRlckNvbG9yID0gb3B0aW9ucy5ib3JkZXJDb2xvci50b1dlYkdMKCk7XG5cblx0XHRjb25zdCBwcm9ncmFtID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0U2hhZGVyUHJvZ3JhbSh0aGlzLnByb2dyYW1LZXkpO1xuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XG5cblx0XHRnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG5cdFx0Y29uc3QgdmVydGV4RGF0YSA9IHRoaXMuZ2V0VmVydGljZXMob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcblxuXHRcdGNvbnN0IEZTSVpFID0gdmVydGV4RGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcblxuXHRcdC8vIEJpbmQgdGhlIGJ1ZmZlclxuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG5cblx0XHQvLyBBdHRyaWJ1dGVzXG5cdFx0Y29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfUG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIEZTSVpFLCAwICogRlNJWkUpO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfUG9zaXRpb24pO1xuXG5cdFx0Ly8gVW5pZm9ybXNcblx0XHRjb25zdCB1X0JhY2tncm91bmRDb2xvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfQmFja2dyb3VuZENvbG9yXCIpO1xuXHRcdGdsLnVuaWZvcm00ZnYodV9CYWNrZ3JvdW5kQ29sb3IsIGJhY2tncm91bmRDb2xvcik7XG5cbiAgICAgICAgY29uc3QgdV9Cb3JkZXJDb2xvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfQm9yZGVyQ29sb3JcIik7XG5cdFx0Z2wudW5pZm9ybTRmdih1X0JvcmRlckNvbG9yLCBib3JkZXJDb2xvcik7XG5cbiAgICAgICAgY29uc3QgdV9NYXhTaXplID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9NYXhTaXplXCIpO1xuICAgICAgICBnbC51bmlmb3JtMmYodV9NYXhTaXplLCAtdmVydGV4RGF0YVswXSwgdmVydGV4RGF0YVsxXSk7XG5cblx0XHQvLyBHZXQgdHJhbnNmb3JtYXRpb24gbWF0cml4XG5cdFx0Ly8gV2Ugd2FudCBhIHNxdWFyZSBmb3Igb3VyIHJlbmRlcmluZyBzcGFjZSwgc28gZ2V0IHRoZSBtYXhpbXVtIGRpbWVuc2lvbiBvZiBvdXIgcXVhZFxuXHRcdGxldCBtYXhEaW1lbnNpb24gPSBNYXRoLm1heChvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnkpO1xuXG4gICAgICAgIGNvbnN0IHVfQm9yZGVyV2lkdGggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JvcmRlcldpZHRoXCIpO1xuXHRcdGdsLnVuaWZvcm0xZih1X0JvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoL21heERpbWVuc2lvbik7XG5cbiAgICAgICAgY29uc3QgdV9Cb3JkZXJSYWRpdXMgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JvcmRlclJhZGl1c1wiKTtcblx0XHRnbC51bmlmb3JtMWYodV9Cb3JkZXJSYWRpdXMsIG9wdGlvbnMuYm9yZGVyUmFkaXVzL21heERpbWVuc2lvbik7XG5cblx0XHQvLyBUaGUgc2l6ZSBvZiB0aGUgcmVuZGVyaW5nIHNwYWNlIHdpbGwgYmUgYSBzcXVhcmUgd2l0aCB0aGlzIG1heGltdW0gZGltZW5zaW9uXG5cdFx0bGV0IHNpemUgPSBuZXcgVmVjMihtYXhEaW1lbnNpb24sIG1heERpbWVuc2lvbikuc2NhbGUoMi9vcHRpb25zLndvcmxkU2l6ZS54LCAyL29wdGlvbnMud29ybGRTaXplLnkpO1xuXG5cdFx0Ly8gQ2VudGVyIG91ciB0cmFuc2xhdGlvbnMgYXJvdW5kICgwLCAwKVxuXHRcdGNvbnN0IHRyYW5zbGF0ZVggPSAob3B0aW9ucy5wb3NpdGlvbi54IC0gb3B0aW9ucy5vcmlnaW4ueCAtIG9wdGlvbnMud29ybGRTaXplLngvMikvbWF4RGltZW5zaW9uO1xuXHRcdGNvbnN0IHRyYW5zbGF0ZVkgPSAtKG9wdGlvbnMucG9zaXRpb24ueSAtIG9wdGlvbnMub3JpZ2luLnkgLSBvcHRpb25zLndvcmxkU2l6ZS55LzIpL21heERpbWVuc2lvbjtcblxuXHRcdC8vIENyZWF0ZSBvdXIgdHJhbnNmb3JtYXRpb24gbWF0cml4XG5cdFx0dGhpcy50cmFuc2xhdGlvbi50cmFuc2xhdGUobmV3IEZsb2F0MzJBcnJheShbdHJhbnNsYXRlWCwgdHJhbnNsYXRlWV0pKTtcblx0XHR0aGlzLnNjYWxlLnNjYWxlKHNpemUpO1xuXHRcdHRoaXMucm90YXRpb24ucm90YXRlKG9wdGlvbnMucm90YXRpb24pO1xuXHRcdGxldCB0cmFuc2Zvcm1hdGlvbiA9IE1hdDR4NC5NVUxUKHRoaXMudHJhbnNsYXRpb24sIHRoaXMuc2NhbGUsIHRoaXMucm90YXRpb24pO1xuXG5cdFx0Ly8gUGFzcyB0aGUgdHJhbnNsYXRpb24gbWF0cml4IHRvIG91ciBzaGFkZXJcblx0XHRjb25zdCB1X1RyYW5zZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfVHJhbnNmb3JtXCIpO1xuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYodV9UcmFuc2Zvcm0sIGZhbHNlLCB0cmFuc2Zvcm1hdGlvbi50b0FycmF5KCkpO1xuXG5cdFx0Ly8gRHJhdyB0aGUgcXVhZFxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSByZW5kZXJpbmcgc3BhY2UgYWx3YXlzIGhhcyB0byBiZSBhIHNxdWFyZSwgc28gbWFrZSBzdXJlIGl0cyBzcXVhcmUgdy5yLnQgdG8gdGhlIGxhcmdlc3QgZGltZW5zaW9uXG5cdCAqIEBwYXJhbSB3IFRoZSB3aWR0aCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIGggVGhlIGhlaWdodCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcblx0ICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGhlIHZlcnRpY2VzIG9mIHRoZSBxdWFkXG5cdCAqL1xuXHRnZXRWZXJ0aWNlcyh3OiBudW1iZXIsIGg6IG51bWJlcik6IEZsb2F0MzJBcnJheSB7XG5cdFx0bGV0IHgsIHk7XG5cblx0XHRpZihoID4gdyl7XG5cdFx0XHR5ID0gMC41O1xuXHRcdFx0eCA9IHcvKDIqaCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHggPSAwLjU7XG5cdFx0XHR5ID0gaC8oMip3KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG5cdFx0XHQteCwgIHksXG5cdFx0XHQteCwgLXksXG5cdFx0XHQgeCwgIHksXG5cdFx0XHQgeCwgLXlcblx0XHRdKTtcblx0fVxuXG5cdGdldE9wdGlvbnMocmVjdDogTGFiZWwpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcblx0XHRsZXQgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcblx0XHRcdHBvc2l0aW9uOiByZWN0LnBvc2l0aW9uLFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiByZWN0LmNhbGN1bGF0ZUJhY2tncm91bmRDb2xvcigpLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHJlY3QuY2FsY3VsYXRlQm9yZGVyQ29sb3IoKSxcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiByZWN0LmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiByZWN0LmJvcmRlclJhZGl1cyxcblx0XHRcdHNpemU6IHJlY3Quc2l6ZSxcblx0XHRcdHJvdGF0aW9uOiByZWN0LnJvdGF0aW9uXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH1cbn0iLCJpbXBvcnQgRGVidWcgZnJvbSBcIi4uLy4uLy4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uLy4uLy4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgUmVuZGVyaW5nVXRpbHMgZnJvbSBcIi4uLy4uLy4uL1V0aWxzL1JlbmRlcmluZ1V0aWxzXCI7XG5pbXBvcnQgU2hhZGVyVHlwZSBmcm9tIFwiLi4vU2hhZGVyVHlwZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludFNoYWRlclR5cGUgZXh0ZW5kcyBTaGFkZXJUeXBlIHtcblxuXHRwcm90ZWN0ZWQgYnVmZmVyT2JqZWN0S2V5OiBzdHJpbmc7XG5cblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcblx0XHRzdXBlcihwcm9ncmFtS2V5KTtcblx0fVxuXG5cdGluaXRCdWZmZXJPYmplY3QoKTogdm9pZCB7XG5cdFx0dGhpcy5idWZmZXJPYmplY3RLZXkgPSBcInBvaW50XCI7XG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcblx0fVxuXG5cdHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG5cdFx0bGV0IHBvc2l0aW9uID0gUmVuZGVyaW5nVXRpbHMudG9XZWJHTENvb3JkcyhvcHRpb25zLnBvc2l0aW9uLCBvcHRpb25zLm9yaWdpbiwgb3B0aW9ucy53b3JsZFNpemUpO1xuXHRcdGxldCBjb2xvciA9IFJlbmRlcmluZ1V0aWxzLnRvV2ViR0xDb2xvcihvcHRpb25zLmNvbG9yKTtcblxuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0QnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcblxuXHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cblx0XHRjb25zdCB2ZXJ0ZXhEYXRhID0gcG9zaXRpb247XG5cblx0XHRjb25zdCBGU0laRSA9IHZlcnRleERhdGEuQllURVNfUEVSX0VMRU1FTlQ7XG5cblx0XHQvLyBCaW5kIHRoZSBidWZmZXJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcblx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xuXG5cdFx0Ly8gQXR0cmlidXRlc1xuXHRcdGNvbnN0IGFfUG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfUG9zaXRpb25cIik7XG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhX1Bvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiBGU0laRSwgMCAqIEZTSVpFKTtcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX1Bvc2l0aW9uKTtcblxuXHRcdC8vIFVuaWZvcm1zXG5cdFx0Y29uc3QgdV9Db2xvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfQ29sb3JcIik7XG5cdFx0Z2wudW5pZm9ybTRmdih1X0NvbG9yLCBjb2xvcik7XG5cblx0XHRjb25zdCB1X1BvaW50U2l6ZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfUG9pbnRTaXplXCIpO1xuXHRcdGdsLnVuaWZvcm0xZih1X1BvaW50U2l6ZSwgb3B0aW9ucy5wb2ludFNpemUpO1xuXG5cdFx0Z2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIDAsIDEpO1xuXHR9XG5cblx0Z2V0T3B0aW9ucyhwb2ludDogUG9pbnQpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcblx0XHRsZXQgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcblx0XHRcdHBvc2l0aW9uOiBwb2ludC5wb3NpdGlvbixcblx0XHRcdGNvbG9yOiBwb2ludC5jb2xvcixcblx0XHRcdHBvaW50U2l6ZTogcG9pbnQuc2l6ZSxcblx0XHR9XG5cblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fVxufSIsImltcG9ydCBNYXQ0eDQgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9NYXQ0eDRcIjtcbmltcG9ydCBTaGFkZXJUeXBlIGZyb20gXCIuLi9TaGFkZXJUeXBlXCI7XG5cbi8qKiBSZXByZXNlbnRzIGFueSBXZWJHTCBvYmplY3RzIHRoYXQgaGF2ZSBhIHF1YWQgbWVzaCAoaS5lLiBhIHJlY3Rhbmd1bGFyIGdhbWUgb2JqZWN0IGNvbXBvc2VkIG9mIG9ubHkgdHdvIHRyaWFuZ2xlcykgKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFF1YWRTaGFkZXJUeXBlIGV4dGVuZHMgU2hhZGVyVHlwZSB7XG5cdC8qKiBUaGUga2V5IHRvIHRoZSBidWZmZXIgb2JqZWN0IGZvciB0aGlzIHNoYWRlciAqL1xuXHRwcm90ZWN0ZWQgYnVmZmVyT2JqZWN0S2V5OiBzdHJpbmc7XG5cblx0LyoqIFRoZSBzY2FsZSBtYXRyaWMgKi9cblx0cHJvdGVjdGVkIHNjYWxlOiBNYXQ0eDQ7XG5cblx0LyoqIFRoZSByb3RhdGlvbiBtYXRyaXggKi9cblx0cHJvdGVjdGVkIHJvdGF0aW9uOiBNYXQ0eDQ7XG5cblx0LyoqIFRoZSB0cmFuc2xhdGlvbiBtYXRyaXggKi9cblx0cHJvdGVjdGVkIHRyYW5zbGF0aW9uOiBNYXQ0eDQ7XG5cblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcblx0XHRzdXBlcihwcm9ncmFtS2V5KTtcblxuXHRcdHRoaXMuc2NhbGUgPSBNYXQ0eDQuSURFTlRJVFk7XG5cdFx0dGhpcy5yb3RhdGlvbiA9IE1hdDR4NC5JREVOVElUWTtcblx0XHR0aGlzLnRyYW5zbGF0aW9uID0gTWF0NHg0LklERU5USVRZO1xuXHR9XG59IiwiaW1wb3J0IE1hdDR4NCBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL01hdDR4NFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IFF1YWRTaGFkZXJUeXBlIGZyb20gXCIuL1F1YWRTaGFkZXJUeXBlXCI7XG5cbi8qKiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjdFNoYWRlclR5cGUgZXh0ZW5kcyBRdWFkU2hhZGVyVHlwZSB7XG5cblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcblx0XHRzdXBlcihwcm9ncmFtS2V5KTtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuXHR9XG5cblx0aW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkIHtcblx0XHR0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwicmVjdFwiO1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XG5cdH1cblxuXHRyZW5kZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuXHRcdGNvbnN0IGNvbG9yID0gb3B0aW9ucy5jb2xvci50b1dlYkdMKCk7XG5cblx0XHRjb25zdCBwcm9ncmFtID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0U2hhZGVyUHJvZ3JhbSh0aGlzLnByb2dyYW1LZXkpO1xuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XG5cblx0XHRnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG5cdFx0Y29uc3QgdmVydGV4RGF0YSA9IHRoaXMuZ2V0VmVydGljZXMob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcblxuXHRcdGNvbnN0IEZTSVpFID0gdmVydGV4RGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcblxuXHRcdC8vIEJpbmQgdGhlIGJ1ZmZlclxuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG5cblx0XHQvLyBBdHRyaWJ1dGVzXG5cdFx0Y29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfUG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIEZTSVpFLCAwICogRlNJWkUpO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfUG9zaXRpb24pO1xuXG5cdFx0Ly8gVW5pZm9ybXNcblx0XHRjb25zdCB1X0NvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Db2xvclwiKTtcblx0XHRnbC51bmlmb3JtNGZ2KHVfQ29sb3IsIGNvbG9yKTtcblxuXHRcdC8vIEdldCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcblx0XHQvLyBXZSB3YW50IGEgc3F1YXJlIGZvciBvdXIgcmVuZGVyaW5nIHNwYWNlLCBzbyBnZXQgdGhlIG1heGltdW0gZGltZW5zaW9uIG9mIG91ciBxdWFkXG5cdFx0bGV0IG1heERpbWVuc2lvbiA9IE1hdGgubWF4KG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XG5cblx0XHQvLyBUaGUgc2l6ZSBvZiB0aGUgcmVuZGVyaW5nIHNwYWNlIHdpbGwgYmUgYSBzcXVhcmUgd2l0aCB0aGlzIG1heGltdW0gZGltZW5zaW9uXG5cdFx0bGV0IHNpemUgPSBuZXcgVmVjMihtYXhEaW1lbnNpb24sIG1heERpbWVuc2lvbikuc2NhbGUoMi9vcHRpb25zLndvcmxkU2l6ZS54LCAyL29wdGlvbnMud29ybGRTaXplLnkpO1xuXG5cdFx0Ly8gQ2VudGVyIG91ciB0cmFuc2xhdGlvbnMgYXJvdW5kICgwLCAwKVxuXHRcdGNvbnN0IHRyYW5zbGF0ZVggPSAob3B0aW9ucy5wb3NpdGlvbi54IC0gb3B0aW9ucy5vcmlnaW4ueCAtIG9wdGlvbnMud29ybGRTaXplLngvMikvbWF4RGltZW5zaW9uO1xuXHRcdGNvbnN0IHRyYW5zbGF0ZVkgPSAtKG9wdGlvbnMucG9zaXRpb24ueSAtIG9wdGlvbnMub3JpZ2luLnkgLSBvcHRpb25zLndvcmxkU2l6ZS55LzIpL21heERpbWVuc2lvbjtcblxuXHRcdC8vIENyZWF0ZSBvdXIgdHJhbnNmb3JtYXRpb24gbWF0cml4XG5cdFx0dGhpcy50cmFuc2xhdGlvbi50cmFuc2xhdGUobmV3IEZsb2F0MzJBcnJheShbdHJhbnNsYXRlWCwgdHJhbnNsYXRlWV0pKTtcblx0XHR0aGlzLnNjYWxlLnNjYWxlKHNpemUpO1xuXHRcdHRoaXMucm90YXRpb24ucm90YXRlKG9wdGlvbnMucm90YXRpb24pO1xuXHRcdGxldCB0cmFuc2Zvcm1hdGlvbiA9IE1hdDR4NC5NVUxUKHRoaXMudHJhbnNsYXRpb24sIHRoaXMuc2NhbGUsIHRoaXMucm90YXRpb24pO1xuXG5cdFx0Ly8gUGFzcyB0aGUgdHJhbnNsYXRpb24gbWF0cml4IHRvIG91ciBzaGFkZXJcblx0XHRjb25zdCB1X1RyYW5zZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfVHJhbnNmb3JtXCIpO1xuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYodV9UcmFuc2Zvcm0sIGZhbHNlLCB0cmFuc2Zvcm1hdGlvbi50b0FycmF5KCkpO1xuXG5cdFx0Ly8gRHJhdyB0aGUgcXVhZFxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuXHR9XG5cblxuXHQvKlxuXHRcdFNvIGFzIGl0IHR1cm5zIG91dCwgV2ViR0wgaGFzIGFuIGlzc3VlIHdpdGggbm9uLXNxdWFyZSBxdWFkcy5cblx0XHRJdCBkb2Vzbid0IGxpa2Ugd2hlbiB5b3UgZG9uJ3QgaGF2ZSBhIDEtMSBzY2FsZSwgYW5kIHJvdGF0aW9ucyBhcmUgZW50aXJlbHkgbWVzc2VkIHVwIGlmIHRoaXMgaXMgbm90IHRoZSBjYXNlLlxuXHRcdFRvIHNvbHZlIHRoaXMsIEkgdXNlZCB0aGUgc2NhbGUgb2YgdGhlIExBUkdFU1QgZGltZW5zaW9uIG9mIHRoZSBxdWFkIHRvIG1ha2UgYSBzcXVhcmUsIHRoZW4gYWRqdXN0ZWQgdGhlIHZlcnRleCBjb29yZGluYXRlcyBpbnNpZGUgb2YgdGhhdC5cblx0XHRBIGRpYWdyYW0gb2YgdGhlIHNvbHV0aW9uIGZvbGxvd3MuXG5cblx0XHRUaGVyZSBpcyBhIGJvdW5kaW5nIHNxdWFyZSBmb3IgdGhlIHF1YWQgd2l0aCBkaW1lbnNpb25zIGh4aCAoaW4gdGhpcyBjYXNlLCBzaW5jZSBoZWlnaHQgaXMgdGhlIGxhcmdlc3QgZGltZW5zaW9uKS5cblx0XHRUaGUgb2Zmc2V0IGluIHRoZSB2ZXJ0aWNhbCBkaXJlY3Rpb24gaXMgdGhlcmVmb3JlIDAuNSwgYXMgaXQgaXMgbm9ybWFsbHkuXG5cdFx0SG93ZXZlciwgdGhlIG9mZnNldCBpbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24gaXMgbm90IHNvIHN0cmFpZ2h0Zm9yd2FyZCwgYnV0IGlzbid0IGNvbmNlcHR1YWxseSBoYXJkLlxuXHRcdEFsbCB3ZSByZWFsbHkgaGF2ZSB0byBkbyBpcyBhIHJhbmdlIGNoYW5nZSBmcm9tIFswLCBoZWlnaHQvMl0gdG8gWzAsIDAuNV0sIHdoZXJlIG91ciB2YWx1ZSBpcyB0ID0gd2lkdGgvMiwgYW5kIDAgPD0gdCA8PSBoZWlnaHQvMi5cblxuXHRcdFNvIG5vdyB3ZSBoYXZlIG91ciByZWN0LCBpbiBhIHNwYWNlIHNjYWxlZCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxhcmdlc3QgZGltZW5zaW9uLlxuXHRcdFJvdGF0aW9ucyB3b3JrIGFzIHlvdSB3b3VsZCBleHBlY3QsIGV2ZW4gZm9yIGxvbmcgcmVjdGFuZ2xlcy5cblxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0X18gX18gX18gX18gX18gX18gX19cblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcblx0XHQtMC41fF8gX3w4ODg4ODg4ODg4OHxfIF98MC41XG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XG5cdCAgXHRcdHxfX198ODg4ODg4ODg4ODh8X19ffFxuXHRcdFx0ICBcdFx0LTAuNVxuXG5cdFx0VGhlIGdldFZlcnRpY2VzIGZ1bmN0aW9uIGJlbG93IGRvZXMgYXMgZGVzY3JpYmVkLCBhbmQgY29udmVydHMgdGhlIHJhbmdlXG5cdCovXG5cdC8qKlxuXHQgKiBUaGUgcmVuZGVyaW5nIHNwYWNlIGFsd2F5cyBoYXMgdG8gYmUgYSBzcXVhcmUsIHNvIG1ha2Ugc3VyZSBpdHMgc3F1YXJlIHcuci50IHRvIHRoZSBsYXJnZXN0IGRpbWVuc2lvblxuXHQgKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSBoIFRoZSBoZWlnaHQgb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgcXVhZFxuXHQgKi9cblx0Z2V0VmVydGljZXModzogbnVtYmVyLCBoOiBudW1iZXIpOiBGbG9hdDMyQXJyYXkge1xuXHRcdGxldCB4LCB5O1xuXG5cdFx0aWYoaCA+IHcpe1xuXHRcdFx0eSA9IDAuNTtcblx0XHRcdHggPSB3LygyKmgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gMC41O1xuXHRcdFx0eSA9IGgvKDIqdyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuXHRcdFx0LXgsICB5LFxuXHRcdFx0LXgsIC15LFxuXHRcdFx0IHgsICB5LFxuXHRcdFx0IHgsIC15XG5cdFx0XSk7XG5cdH1cblxuXHRnZXRPcHRpb25zKHJlY3Q6IFJlY3QpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcblx0XHRsZXQgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcblx0XHRcdHBvc2l0aW9uOiByZWN0LnBvc2l0aW9uLFxuXHRcdFx0Y29sb3I6IHJlY3QuY29sb3IsXG5cdFx0XHRzaXplOiByZWN0LnNpemUsXG5cdFx0XHRyb3RhdGlvbjogcmVjdC5yb3RhdGlvblxuXHRcdH1cblxuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG59IiwiaW1wb3J0IE1hdDR4NCBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL01hdDR4NFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uLy4uLy4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uLy4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgUXVhZFNoYWRlclR5cGUgZnJvbSBcIi4vUXVhZFNoYWRlclR5cGVcIjtcblxuLyoqIEEgc2hhZGVyIGZvciBzcHJpdGVzIGFuZCBhbmltYXRlZCBzcHJpdGVzICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcHJpdGVTaGFkZXJUeXBlIGV4dGVuZHMgUXVhZFNoYWRlclR5cGUge1xuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG5cdH1cblxuXHRpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQge1xuXHRcdHRoaXMuYnVmZmVyT2JqZWN0S2V5ID0gXCJzcHJpdGVcIjtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xuXHR9XG5cblx0cmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcblx0XHRjb25zdCBwcm9ncmFtID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0U2hhZGVyUHJvZ3JhbSh0aGlzLnByb2dyYW1LZXkpO1xuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XG5cdFx0Y29uc3QgdGV4dHVyZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFRleHR1cmUob3B0aW9ucy5pbWFnZUtleSk7XG5cblx0XHRnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG5cdFx0Y29uc3QgdmVydGV4RGF0YSA9IHRoaXMuZ2V0VmVydGljZXMob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55LCBvcHRpb25zLnNjYWxlKTtcblxuXHRcdGNvbnN0IEZTSVpFID0gdmVydGV4RGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcblxuXHRcdC8vIEJpbmQgdGhlIGJ1ZmZlclxuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG5cblx0XHQvLyBBdHRyaWJ1dGVzXG5cdFx0Y29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfUG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgNCAqIEZTSVpFLCAwICogRlNJWkUpO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfUG9zaXRpb24pO1xuXG5cdFx0Y29uc3QgYV9UZXhDb29yZCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9UZXhDb29yZFwiKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfVGV4Q29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgNCAqIEZTSVpFLCAyKkZTSVpFKTtcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX1RleENvb3JkKTtcblxuXHRcdC8vIFVuaWZvcm1zXG5cdFx0Ly8gR2V0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuXHRcdC8vIFdlIHdhbnQgYSBzcXVhcmUgZm9yIG91ciByZW5kZXJpbmcgc3BhY2UsIHNvIGdldCB0aGUgbWF4aW11bSBkaW1lbnNpb24gb2Ygb3VyIHF1YWRcblx0XHRsZXQgbWF4RGltZW5zaW9uID0gTWF0aC5tYXgob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcblxuXHRcdC8vIFRoZSBzaXplIG9mIHRoZSByZW5kZXJpbmcgc3BhY2Ugd2lsbCBiZSBhIHNxdWFyZSB3aXRoIHRoaXMgbWF4aW11bSBkaW1lbnNpb25cblx0XHRsZXQgc2l6ZSA9IG5ldyBWZWMyKG1heERpbWVuc2lvbiwgbWF4RGltZW5zaW9uKS5zY2FsZSgyL29wdGlvbnMud29ybGRTaXplLngsIDIvb3B0aW9ucy53b3JsZFNpemUueSk7XG5cblx0XHQvLyBDZW50ZXIgb3VyIHRyYW5zbGF0aW9ucyBhcm91bmQgKDAsIDApXG5cdFx0Y29uc3QgdHJhbnNsYXRlWCA9IChvcHRpb25zLnBvc2l0aW9uLnggLSBvcHRpb25zLm9yaWdpbi54IC0gb3B0aW9ucy53b3JsZFNpemUueC8yKS9tYXhEaW1lbnNpb247XG5cdFx0Y29uc3QgdHJhbnNsYXRlWSA9IC0ob3B0aW9ucy5wb3NpdGlvbi55IC0gb3B0aW9ucy5vcmlnaW4ueSAtIG9wdGlvbnMud29ybGRTaXplLnkvMikvbWF4RGltZW5zaW9uO1xuXG5cdFx0Ly8gQ3JlYXRlIG91ciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcblx0XHR0aGlzLnRyYW5zbGF0aW9uLnRyYW5zbGF0ZShuZXcgRmxvYXQzMkFycmF5KFt0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSkpO1xuXHRcdHRoaXMuc2NhbGUuc2NhbGUoc2l6ZSk7XG5cdFx0dGhpcy5yb3RhdGlvbi5yb3RhdGUob3B0aW9ucy5yb3RhdGlvbik7XG5cdFx0bGV0IHRyYW5zZm9ybWF0aW9uID0gTWF0NHg0Lk1VTFQodGhpcy50cmFuc2xhdGlvbiwgdGhpcy5zY2FsZSwgdGhpcy5yb3RhdGlvbik7XG5cblx0XHQvLyBQYXNzIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggdG8gb3VyIHNoYWRlclxuXHRcdGNvbnN0IHVfVHJhbnNmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9UcmFuc2Zvcm1cIik7XG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdih1X1RyYW5zZm9ybSwgZmFsc2UsIHRyYW5zZm9ybWF0aW9uLnRvQXJyYXkoKSk7XG5cblx0XHQvLyBTZXQgdXAgb3VyIHNhbXBsZXIgd2l0aCBvdXIgYXNzaWduZWQgdGV4dHVyZSB1bml0XG5cdFx0Y29uc3QgdV9TYW1wbGVyID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9TYW1wbGVyXCIpO1xuXHRcdGdsLnVuaWZvcm0xaSh1X1NhbXBsZXIsIHRleHR1cmUpO1xuXG5cdFx0Ly8gUGFzcyBpbiB0ZXhTaGlmdFxuXHRcdGNvbnN0IHVfdGV4U2hpZnQgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X3RleFNoaWZ0XCIpO1xuXHRcdGdsLnVuaWZvcm0yZnYodV90ZXhTaGlmdCwgb3B0aW9ucy50ZXhTaGlmdCk7XG5cblx0XHQvLyBQYXNzIGluIHRleFNjYWxlXG5cdFx0Y29uc3QgdV90ZXhTY2FsZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfdGV4U2NhbGVcIik7XG5cdFx0Z2wudW5pZm9ybTJmdih1X3RleFNjYWxlLCBvcHRpb25zLnRleFNjYWxlKTtcblxuXHRcdC8vIERyYXcgdGhlIHF1YWRcblx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgcmVuZGVyaW5nIHNwYWNlIGFsd2F5cyBoYXMgdG8gYmUgYSBzcXVhcmUsIHNvIG1ha2Ugc3VyZSBpdHMgc3F1YXJlIHcuci50IHRvIHRoZSBsYXJnZXN0IGRpbWVuc2lvblxuXHQgKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSBoIFRoZSBoZWlnaHQgb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgcXVhZFxuXHQgKi9cblx0Z2V0VmVydGljZXModzogbnVtYmVyLCBoOiBudW1iZXIsIHNjYWxlOiBGbG9hdDMyQXJyYXkpOiBGbG9hdDMyQXJyYXkge1xuXHRcdGxldCB4LCB5O1xuXG5cdFx0aWYoaCA+IHcpe1xuXHRcdFx0eSA9IDAuNTtcblx0XHRcdHggPSB3LygyKmgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gMC41O1xuXHRcdFx0eSA9IGgvKDIqdyk7XG5cdFx0fVxuXG5cdFx0Ly8gU2NhbGUgdGhlIHJlbmRlcmluZyBzcGFjZSBpZiBuZWVkZWRcblx0XHR4ICo9IHNjYWxlWzBdO1xuXHRcdHkgKj0gc2NhbGVbMV07XG5cblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG5cdFx0XHQteCwgIHksIDAuMCwgMC4wLFxuXHRcdFx0LXgsIC15LCAwLjAsIDEuMCxcblx0XHRcdCB4LCAgeSwgMS4wLCAwLjAsXG5cdFx0XHQgeCwgLXksIDEuMCwgMS4wXG5cdFx0XSk7XG5cdH1cblxuXHRnZXRPcHRpb25zKHNwcml0ZTogU3ByaXRlKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG5cdFx0bGV0IHRleFNoaWZ0O1xuXHRcdGxldCB0ZXhTY2FsZTtcblxuXHRcdGlmKHNwcml0ZSBpbnN0YW5jZW9mIEFuaW1hdGVkU3ByaXRlKXtcblx0XHRcdGxldCBhbmltYXRpb25JbmRleCA9IHNwcml0ZS5hbmltYXRpb24uZ2V0SW5kZXhBbmRBZHZhbmNlQW5pbWF0aW9uKCk7XG5cdFx0XHRsZXQgb2Zmc2V0ID0gc3ByaXRlLmdldEFuaW1hdGlvbk9mZnNldChhbmltYXRpb25JbmRleCk7XG5cdFx0XHR0ZXhTaGlmdCA9IG5ldyBGbG9hdDMyQXJyYXkoW29mZnNldC54IC8gKHNwcml0ZS5jb2xzICogc3ByaXRlLnNpemUueCksIG9mZnNldC55IC8gKHNwcml0ZS5yb3dzICogc3ByaXRlLnNpemUueSldKTtcblx0XHRcdHRleFNjYWxlID0gbmV3IEZsb2F0MzJBcnJheShbMS8oc3ByaXRlLmNvbHMpLCAxLyhzcHJpdGUucm93cyldKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGV4U2hpZnQgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwXSk7XG5cdFx0XHR0ZXhTY2FsZSA9IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDFdKTtcblx0XHR9XG5cblx0XHRsZXQgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcblx0XHRcdHBvc2l0aW9uOiBzcHJpdGUucG9zaXRpb24sXG5cdFx0XHRyb3RhdGlvbjogc3ByaXRlLnJvdGF0aW9uLFxuXHRcdFx0c2l6ZTogc3ByaXRlLnNpemUsXG5cdFx0XHRzY2FsZTogc3ByaXRlLnNjYWxlLnRvQXJyYXkoKSxcblx0XHRcdGltYWdlS2V5OiBzcHJpdGUuaW1hZ2VJZCxcblx0XHRcdHRleFNoaWZ0LFxuXHRcdFx0dGV4U2NhbGVcblx0XHR9XG5cblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fVxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcbmltcG9ydCBRdWV1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1F1ZXVlXCI7XG5pbXBvcnQgeyBUaWxlZFRpbGVtYXBEYXRhIH0gZnJvbSBcIi4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIjtcbmltcG9ydCBTdHJpbmdVdGlscyBmcm9tIFwiLi4vVXRpbHMvU3RyaW5nVXRpbHNcIjtcbmltcG9ydCBBdWRpb01hbmFnZXIgZnJvbSBcIi4uL1NvdW5kL0F1ZGlvTWFuYWdlclwiO1xuaW1wb3J0IFNwcml0ZXNoZWV0IGZyb20gXCIuLi9EYXRhVHlwZXMvU3ByaXRlc2hlZXRcIjtcbmltcG9ydCBXZWJHTFByb2dyYW1UeXBlIGZyb20gXCIuLi9EYXRhVHlwZXMvUmVuZGVyaW5nL1dlYkdMUHJvZ3JhbVR5cGVcIjtcblxuLyoqXG4gKiBUaGUgcmVzb3VyY2UgbWFuYWdlciBmb3IgdGhlIGdhbWUgZW5naW5lLlxuICogVGhlIHJlc291cmNlIG1hbmFnZXIgaW50ZXJmYWNlcyB3aXRoIHRoZSBsb2FkYWJsZSBhc3NldHMgb2YgYSBnYW1lIHN1Y2ggYXMgaW1hZ2VzLCBkYXRhIGZpbGVzLFxuICogYW5kIHNvdW5kcywgd2hpY2ggYXJlIGFsbCBmb3VuZCBpbiB0aGUgZGlzdCBmb2xkZXIuXG4gKiBUaGlzIGNsYXNzIGNvbnRyb2xzIGxvYWRpbmcgYW5kIHVwZGF0ZXMgdGhlIEByZWZlcmVuY2VbU2NlbmVdIHdpdGggdGhlIGxvYWRpbmcgcHJvZ3Jlc3MsIHNvIHRoYXQgdGhlIHNjZW5lIGRvZXMgXG4gKiBub3Qgc3RhcnQgYmVmb3JlIGFsbCBuZWNlc3NhcnkgYXNzZXRzIGFyZSBsb2FkZWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc291cmNlTWFuYWdlciB7XG4gICAgLy8gSW5zdGFuY2UgZm9yIHRoZSBzaW5nbGV0b24gY2xhc3NcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogUmVzb3VyY2VNYW5hZ2VyO1xuICAgIFxuICAgIC8vIEJvb2xlYW5zIHRvIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBvciBub3QgdGhlIFJlc291cmNlTWFuYWdlciBpcyBjdXJyZW50bHkgbG9hZGluZyBzb21ldGhpbmdcbiAgICAvKiogV2hldGhlciBvciBub3QgYW55IHJlc291cmNlcyBhcmUgbG9hZGluZyAqL1xuICAgIHByaXZhdGUgbG9hZGluZzogYm9vbGVhbjtcbiAgICAvKiogQSBib29sZWFuIHRvIGluZGljYXRlIHRoYXQgdGhlIGFzc2V0cyBqdXN0IGZpbmlzaGVkIGxvYWRpbmcgKi9cbiAgICBwcml2YXRlIGp1c3RMb2FkZWQ6IGJvb2xlYW47XG5cbiAgICAvLyBGdW5jdGlvbnMgdG8gZG8gc29tZXRoaW5nIHdoZW4gbG9hZGluZyBwcm9ncmVzc2VzIG9yIGlzIGNvbXBsZXRlZCBzdWNoIGFzIHJlbmRlciBhIGxvYWRpbmcgc2NyZWVuXG4gICAgLyoqIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBsb2FkaW5nIHByb2dyZXNzZXMgKi9cbiAgICBwdWJsaWMgb25Mb2FkUHJvZ3Jlc3M6IEZ1bmN0aW9uO1xuICAgIC8qKiBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gbG9hZGluZyBjb21wbGV0ZXMgKi9cbiAgICBwdWJsaWMgb25Mb2FkQ29tcGxldGU6IEZ1bmN0aW9uO1xuXG5cbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgaW1hZ2VzIG5lZWQgdG8gYmUgbG9hZGVkKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X2ltYWdlc0xvYWRlZDogbnVtYmVyO1xuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSBpbWFnZXMgYXJlIGxvYWRlZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfaW1hZ2VzVG9Mb2FkOiBudW1iZXI7XG4gICAgLyoqIFRoZSBxdWV1ZSBvZiBpbWFnZXMgd2UgbXVzdCBsb2FkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aFBhaXI+O1xuICAgIC8qKiBBIG1hcCBvZiB0aGUgaW1hZ2VzIHRoYXQgYXJlIGN1cnJlbnRseSBsb2FkZWQgYW5kIGJlaW5nIHVzZWQgYnkgdGhlIHNjZW5lLiBUaGUgcmVmZXJlbmNlIHRvIHRoZXNlIGltYWdlcyBvbmx5IGV4aXN0IGhlcmUgZm9yIGVhc3kgY2xlYW51cC4gKi9cbiAgICBwcml2YXRlIGltYWdlczogTWFwPEhUTUxJbWFnZUVsZW1lbnQ+O1xuXG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRpbGVtYXBzIG5lZWQgdG8gYmUgbG9hZGVkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQ6IG51bWJlcjtcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGlsZW1hcHMgYXJlIGxvYWRlZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkOiBudW1iZXI7XG4gICAgLyoqIFRoZSBxdWV1ZSBvZiB0aWxlbWFwcyB3ZSBtdXN0IGxvYWQgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XG4gICAgLyoqIEEgbWFwIG9mIHRoZSB0aWxlbWFwcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGFuZCAocHJlc3VtYWJseSkgYmVpbmcgdXNlZCBieSB0aGUgc2NlbmUgKi9cbiAgICBwcml2YXRlIHNwcml0ZXNoZWV0czogTWFwPFNwcml0ZXNoZWV0PjtcblxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0aWxlbWFwcyBuZWVkIHRvIGJlIGxvYWRlZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQ6IG51bWJlcjtcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGlsZW1hcHMgYXJlIGxvYWRlZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfdGlsZW1hcHNUb0xvYWQ6IG51bWJlcjtcbiAgICAvKiogVGhlIHF1ZXVlIG9mIHRpbGVtYXBzIHdlIG11c3QgbG9hZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aFBhaXI+O1xuICAgIC8qKiBBIG1hcCBvZiB0aGUgdGlsZW1hcHMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRlZCBhbmQgKHByZXN1bWFibHkpIGJlaW5nIHVzZWQgYnkgdGhlIHNjZW5lICovXG4gICAgcHJpdmF0ZSB0aWxlbWFwczogTWFwPFRpbGVkVGlsZW1hcERhdGE+O1xuXG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHNvdW5kcyBuZWVkIHRvIGJlIGxvYWRlZCAqL1xuICAgIHByaXZhdGUgbG9hZG9ubHlfYXVkaW9Mb2FkZWQ6IG51bWJlcjtcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgc291bmRzIGFyZSBsb2FkZWQgKi9cbiAgICBwcml2YXRlIGxvYWRvbmx5X2F1ZGlvVG9Mb2FkOiBudW1iZXI7XG4gICAgLyoqIFRoZSBxdWV1ZSBvZiBzb3VuZHMgd2UgbXVzdCBsb2FkICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aFBhaXI+O1xuICAgIC8qKiBBIG1hcCBvZiB0aGUgc291bmRzIHRoYXQgYXJlIGN1cnJlbnRseSBsb2FkZWQgYW5kIChwcmVzdW1hYmx5KSBiZWluZyB1c2VkIGJ5IHRoZSBzY2VuZSAqL1xuICAgIHByaXZhdGUgYXVkaW9CdWZmZXJzOiBNYXA8QXVkaW9CdWZmZXI+O1xuXG4gICAgLyoqIFRoZSB0b3RhbCBudW1iZXIgb2YgXCJ0eXBlc1wiIG9mIHRoaW5ncyB0aGF0IG5lZWQgdG8gYmUgbG9hZGVkIChpLmUuIGltYWdlcyBhbmQgdGlsZW1hcHMpICovXG4gICAgcHJpdmF0ZSBsb2Fkb25seV90eXBlc1RvTG9hZDogbnVtYmVyO1xuXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9qc29uTG9hZGVkOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBsb2Fkb25seV9qc29uVG9Mb2FkOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBsb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XG4gICAgcHJpdmF0ZSBqc29uT2JqZWN0czogTWFwPFJlY29yZDxzdHJpbmcsIGFueT4+O1xuXG4gICAgLyogIyMjIyMjIyMjIyBJTkZPUk1BVElPTiBTUEVDSUFMIFRPIFdFQkdMICMjIyMjIyMjIyMgKi9cbiAgICBwcml2YXRlIGdsX1dlYkdMQWN0aXZlOiBib29sZWFuO1xuXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZDogbnVtYmVyO1xuICAgIHByaXZhdGUgbG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQ6IG51bWJlcjtcbiAgICBwcml2YXRlIGxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aF9TaGFkZXI+O1xuXG4gICAgcHJpdmF0ZSBnbF9TaGFkZXJQcm9ncmFtczogTWFwPFdlYkdMUHJvZ3JhbVR5cGU+O1xuXG4gICAgcHJpdmF0ZSBnbF9UZXh0dXJlczogTWFwPG51bWJlcj47XG4gICAgcHJpdmF0ZSBnbF9OZXh0VGV4dHVyZUlEOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBnbF9CdWZmZXJzOiBNYXA8V2ViR0xCdWZmZXI+OyBcblxuICAgIHByaXZhdGUgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcblxuICAgIC8qICMjIyMjIyMjIyMgVU5MT0FESU5HIEFORCBFWENMVVNJT04gTElTVCAjIyMjIyMjIyMjICovXG4gICAgLyoqIEEgbGlzdCBvZiByZXNvdXJjZXMgdGhhdCB3aWxsIGJlIHVubG9hZGVkIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc2NlbmUgKi9cbiAgICBwcml2YXRlIHJlc291cmNlc1RvVW5sb2FkOiBBcnJheTxSZXNvdXJjZVJlZmVyZW5jZT47XG5cbiAgICAvKiogQSBsaXN0IG9mIHJlc291cmNlcyB0byBrZWVwIHVudGlsIGZ1cnRoZXIgbm90aWNlICovXG4gICAgcHJpdmF0ZSByZXNvdXJjZXNUb0tlZXA6IEFycmF5PFJlc291cmNlUmVmZXJlbmNlPjtcblxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuanVzdExvYWRlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZXNUb0xvYWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XG4gICAgICAgIHRoaXMuaW1hZ2VzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XG4gICAgICAgIHRoaXMuc3ByaXRlc2hlZXRzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XG4gICAgICAgIHRoaXMudGlsZW1hcHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XG4gICAgICAgIHRoaXMuYXVkaW9CdWZmZXJzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvbkxvYWRlZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvblRvTG9hZCA9IDA7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuICAgICAgICB0aGlzLmpzb25PYmplY3RzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNMb2FkZWQgPSAwO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zVG9Mb2FkID0gMDtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcblxuICAgICAgICB0aGlzLmdsX1NoYWRlclByb2dyYW1zID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHRoaXMuZ2xfVGV4dHVyZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZ2xfTmV4dFRleHR1cmVJRCA9IDA7XG4gICAgICAgIHRoaXMuZ2xfQnVmZmVycyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMucmVzb3VyY2VzVG9LZWVwID0gbmV3IEFycmF5KCk7XG4gICAgfTtcblxuICAgIC8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgU0lOR0xFVE9OICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBvciBhIG5ldyBpbnN0YW5jZSBpZiBub25lIGV4aXN0XG4gICAgICogQHJldHVybnMgVGhlIHJlc291cmNlIG1hbmFnZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogUmVzb3VyY2VNYW5hZ2VyIHtcbiAgICAgICAgaWYoIXRoaXMuaW5zdGFuY2Upe1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBSZXNvdXJjZU1hbmFnZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICAgIH1cblxuICAgIC8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgUFVCTElDIEZVTkNUSU9OICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyBvciBkZWFjdGl2YXRlcyB0aGUgdXNlIG9mIFdlYkdMXG4gICAgICogQHBhcmFtIGZsYWcgVHJ1ZSBpZiBXZWJHTCBzaG91bGQgYmUgdXNlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHBhcmFtIGdsIFRoZSBpbnN0YW5jZSBvZiB0aGUgZ3JhcGhpY3MgY29udGV4dCwgaWYgYXBwbGljYWJsZVxuICAgICAqL1xuICAgIHB1YmxpYyB1c2VXZWJHTChmbGFnOiBib29sZWFuLCBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogdm9pZCB7XG4gICAgICAgIHRoaXMuZ2xfV2ViR0xBY3RpdmUgPSBmbGFnO1xuXG4gICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xuICAgICAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYW4gaW1hZ2UgZnJvbSBmaWxlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB0aGUgbG9hZGVkIGltYWdlIHdpdGhcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgaW1hZ2UgdG8gbG9hZFxuICAgICAqL1xuICAgIHB1YmxpYyBpbWFnZShrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGh9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHJlc291cmNlXG4gICAgICovXG4gICAgcHVibGljIGtlZXBJbWFnZShrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbG9hZGVkIGltYWdlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBsb2FkZWQgaW1hZ2VcbiAgICAgKiBAcmV0dXJucyBUaGUgaW1hZ2UgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0SW1hZ2Uoa2V5OiBzdHJpbmcpOiBIVE1MSW1hZ2VFbGVtZW50IHtcbiAgICAgICAgbGV0IGltYWdlID0gdGhpcy5pbWFnZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmKGltYWdlID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhyb3cgYFRoZXJlIGlzIG5vIGltYWdlIGFzc29jaWF0ZWQgd2l0aCBrZXkgXCIke2tleX1cImBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBzcHJpdGVzaGVldCBmcm9tIGZpbGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gYXNzb2NpYXRlIHRoZSBsb2FkZWQgc3ByaXRlc2hlZXQgd2l0aFxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBzcHJpdGVzaGVldCB0byBsb2FkXG4gICAgICovXG4gICAgcHVibGljIHNwcml0ZXNoZWV0KGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldExvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcbiAgICAgKi9cbiAgICBwdWJsaWMga2VlcFNwcml0ZXNoZWV0KGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLlNQUklURVNIRUVUKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsb2FkZWQgc3ByaXRlc2hlZXRcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHNwcml0ZXNoZWV0IHRvIGxvYWRcbiAgICAgKiBAcmV0dXJucyBUaGUgbG9hZGVkIFNwcml0ZXNoZWV0XG4gICAgICovXG4gICAgcHVibGljIGdldFNwcml0ZXNoZWV0KGtleTogc3RyaW5nKTogU3ByaXRlc2hlZXQge1xuICAgICAgICByZXR1cm4gdGhpcy5zcHJpdGVzaGVldHMuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYW4gYXVkaW8gZmlsZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbG9hZGVkIGF1ZGlvIGZpbGVcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXG4gICAgICovXG4gICAgcHVibGljIGF1ZGlvKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcbiAgICAgKi9cbiAgICAgcHVibGljIGtlZXBBdWRpbyhrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5BVURJTyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbG9hZGVkIGF1ZGlvIGZpbGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGF1ZGlvIGZpbGUgdG8gbG9hZFxuICAgICAqIEByZXR1cm5zIFRoZSBBdWRpb0J1ZmZlciBjcmVhdGVkIGZyb20gdGhlIGxvYWRlZCBhdWRpbyBmbGVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0QXVkaW8oa2V5OiBzdHJpbmcpOiBBdWRpb0J1ZmZlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1ZGlvQnVmZmVycy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGEgdGlsZW1hcCBmcm9tIGEganNvbiBmaWxlLiBBdXRvbWF0aWNhbGx5IGxvYWRzIHJlbGF0ZWQgaW1hZ2VzXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBsb2FkZWQgdGlsZW1hcFxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSB0aWxlbWFwIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwdWJsaWMgdGlsZW1hcChrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcbiAgICAgKi9cbiAgICAgcHVibGljIGtlZXBUaWxlbWFwKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLlRJTEVNQVApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJlaXZlcyBhIGxvYWRlZCB0aWxlbWFwXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBsb2FkZWQgdGlsZW1hcFxuICAgICAqIEByZXR1cm5zIFRoZSB0aWxlbWFwIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0VGlsZW1hcChrZXk6IHN0cmluZyk6IFRpbGVkVGlsZW1hcERhdGEge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlbWFwcy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbiBvYmplY3QgZnJvbSBhIGpzb24gZmlsZS5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGxvYWRlZCBvYmplY3RcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUganNvbiBmaWxlIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwdWJsaWMgb2JqZWN0KGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpe1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGh9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHJlc291cmNlXG4gICAgICovXG4gICAgIHB1YmxpYyBrZWVwT2JqZWN0KGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLkpTT04pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJlaXZlcyBhIGxvYWRlZCBvYmplY3RcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCBvYmplY3RcbiAgICAgKiBAcmV0dXJucyBUaGUgb2JqZWN0IGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0T2JqZWN0KGtleTogc3RyaW5nKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNvbk9iamVjdHMuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBMT0FEIEZVTkNUSU9OICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xuICAgIC8qKlxuICAgICAqIExvYWRzIGFsbCByZXNvdXJjZXMgY3VycmVudGx5IGluIHRoZSBxdWV1ZVxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsIHdoZW4gdGhlIHJlc291cmNlcyBhcmUgZmluaXNoZWQgbG9hZGluZ1xuICAgICAqL1xuICAgIGxvYWRSZXNvdXJjZXNGcm9tUXVldWUoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfdHlwZXNUb0xvYWQgPSA1O1xuXG4gICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG5cbiAgICAgICAgLy8gTG9hZCBldmVyeXRoaW5nIGluIHRoZSBxdWV1ZXMuIFRpbGVtYXBzIGhhdmUgdG8gY29tZSBiZWZvcmUgaW1hZ2VzIGJlY2F1c2UgdGhleSB3aWxsIGFkZCBuZXcgaW1hZ2VzIHRvIHRoZSBxdWV1ZVxuICAgICAgICB0aGlzLmxvYWRUaWxlbWFwc0Zyb21RdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBUaWxlbWFwc1wiKTtcbiAgICAgICAgICAgIHRoaXMubG9hZFNwcml0ZXNoZWV0c0Zyb21RdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgU3ByaXRlc2hlZXRzXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZEltYWdlc0Zyb21RdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIEltYWdlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkQXVkaW9Gcm9tUXVldWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgQXVkaW9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRPYmplY3RzRnJvbVF1ZXVlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBPYmplY3RzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdsX0xvYWRTaGFkZXJzRnJvbVF1ZXVlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIFNoYWRlcnNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmcoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmcoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZyhjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgLy8gRG9uZSBsb2FkaW5nXG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmp1c3RMb2FkZWQgPSB0cnVlO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIC8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgVU5MT0FEIEZVTkNUSU9OICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xuICAgIFxuICAgIHByaXZhdGUga2VlcFJlc291cmNlKGtleTogc3RyaW5nLCB0eXBlOiBSZXNvdXJjZVR5cGUpOiB2b2lkIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJLZWVwIHJlc291cmNlLi4uXCIpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBsZXQgcmVzb3VyY2UgPSB0aGlzLnJlc291cmNlc1RvVW5sb2FkW2ldO1xuICAgICAgICAgICAgaWYocmVzb3VyY2Uua2V5ID09PSBrZXkgJiYgcmVzb3VyY2UucmVzb3VyY2VUeXBlID09PSB0eXBlKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZvdW5kIHJlc291cmNlIFwiICsga2V5ICsgXCIgb2YgdHlwZSBcIiArIHR5cGUgKyBcIi4gS2VlcGluZy5cIik7XG4gICAgICAgICAgICAgICAgbGV0IHJlc291cmNlVG9Nb3ZlID0gdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb0tlZXAucHVzaCguLi5yZXNvdXJjZVRvTW92ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgcmVmZXJlbmNlcyB0byBhbGwgcmVzb3VyY2VzIGluIHRoZSByZXNvdXJjZSBtYW5hZ2VyXG4gICAgICovXG4gICAgdW5sb2FkQWxsUmVzb3VyY2VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5qdXN0TG9hZGVkID0gZmFsc2U7XG5cbiAgICAgICAgZm9yKGxldCByZXNvdXJjZSBvZiB0aGlzLnJlc291cmNlc1RvVW5sb2FkKXtcbiAgICAgICAgICAgIC8vIFVubG9hZCB0aGUgcmVzb3VyY2VcbiAgICAgICAgICAgIHRoaXMudW5sb2FkUmVzb3VyY2UocmVzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1bmxvYWRSZXNvdXJjZShyZXNvdXJjZTogUmVzb3VyY2VSZWZlcmVuY2UpOiB2b2lkIHtcbiAgICAgICAgLy8gRGVsZXRlIHRoZSByZXNvdXJjZSBpdHNlbGZcbiAgICAgICAgc3dpdGNoKHJlc291cmNlLnJlc291cmNlVHlwZSl7XG4gICAgICAgICAgICBjYXNlIFJlc291cmNlVHlwZS5JTUFHRTpcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlcy5kZWxldGUocmVzb3VyY2Uua2V5KTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmdsX1dlYkdMQWN0aXZlKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbF9UZXh0dXJlcy5kZWxldGUocmVzb3VyY2Uua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJlc291cmNlVHlwZS5USUxFTUFQOlxuICAgICAgICAgICAgICAgIHRoaXMudGlsZW1hcHMuZGVsZXRlKHJlc291cmNlLmtleSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJlc291cmNlVHlwZS5TUFJJVEVTSEVFVDpcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNoZWV0cy5kZWxldGUocmVzb3VyY2Uua2V5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLkFVRElPOlxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXJzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuSlNPTjpcbiAgICAgICAgICAgICAgICB0aGlzLmpzb25PYmplY3RzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLypjYXNlIFJlc291cmNlVHlwZS5TSEFERVI6XG4gICAgICAgICAgICAgICAgdGhpcy5nbF9TaGFkZXJQcm9ncmFtcy5nZXQocmVzb3VyY2Uua2V5KS5kZWxldGUodGhpcy5nbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5nbF9TaGFkZXJQcm9ncmFtcy5kZWxldGUocmVzb3VyY2Uua2V5KTtcbiAgICAgICAgICAgICAgICBicmVhazsqL1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVsZXRlIGFueSBkZXBlbmRlbmNpZXNcbiAgICAgICAgZm9yKGxldCBkZXBlbmRlbmN5IG9mIHJlc291cmNlLmRlcGVuZGVuY2llcyl7XG4gICAgICAgICAgICB0aGlzLnVubG9hZFJlc291cmNlKGRlcGVuZGVuY3kpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBXT1JLIEZVTkNUSU9OUyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjKi9cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbGwgdGlsZW1hcHMgY3VycmVudGx5IGluIHRoZSB0aWxlbWFwIGxvYWRpbmcgcXVldWVcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gbG9hZGluZyBpcyBjb21wbGV0ZVxuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZFRpbGVtYXBzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc1RvTG9hZCA9IHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQgPSAwO1xuXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfdGlsZW1hcHNUb0xvYWQgPT09IDApe1xuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X3RpbGVtYXBMb2FkaW5nUXVldWUuaGFzSXRlbXMoKSl7XG4gICAgICAgICAgICBsZXQgdGlsZW1hcCA9IHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRUaWxlbWFwKHRpbGVtYXAua2V5LCB0aWxlbWFwLnBhdGgsIG9uRmluaXNoTG9hZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIHNpbmd1bGFyIHRpbGVtYXAgXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSB0aWxlbWFwXG4gICAgICogQHBhcmFtIHBhdGhUb1RpbGVtYXBKU09OIFRoZSBwYXRoIHRvIHRoZSB0aWxlbWFwIEpTT04gZmlsZVxuICAgICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IHRpbGVtYXAgdG8gbG9hZFxuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZFRpbGVtYXAoa2V5OiBzdHJpbmcsIHBhdGhUb1RpbGVtYXBKU09OOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZShwYXRoVG9UaWxlbWFwSlNPTiwgKGZpbGVUZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGxldCB0aWxlbWFwT2JqZWN0ID0gPFRpbGVkVGlsZW1hcERhdGE+SlNPTi5wYXJzZShmaWxlVGV4dCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFdlIGNhbiBwYXJzZSB0aGUgb2JqZWN0IGxhdGVyIC0gaXQncyBtdWNoIGZhc3RlciB0aGFuIGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMudGlsZW1hcHMuYWRkKGtleSwgdGlsZW1hcE9iamVjdCk7XG4gICAgICAgICAgICBsZXQgcmVzb3VyY2UgPSBuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuVElMRU1BUCk7XG5cbiAgICAgICAgICAgIC8vIEdyYWIgdGhlIHRpbGVzZXQgaW1hZ2VzIHdlIG5lZWQgdG8gbG9hZCBhbmQgYWRkIHRoZW0gdG8gdGhlIGltYWdlbG9hZGluZyBxdWV1ZVxuICAgICAgICAgICAgZm9yKGxldCB0aWxlc2V0IG9mIHRpbGVtYXBPYmplY3QudGlsZXNldHMpe1xuICAgICAgICAgICAgICAgIGlmKHRpbGVzZXQuaW1hZ2Upe1xuICAgICAgICAgICAgICAgICAgICBsZXQga2V5ID0gdGlsZXNldC5pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhdGggPSBTdHJpbmdVdGlscy5nZXRQYXRoRnJvbUZpbGVQYXRoKHBhdGhUb1RpbGVtYXBKU09OKSArIGtleTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aCwgaXNEZXBlbmRlbmN5OiB0cnVlfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoaXMgaW1hZ2UgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSB0aWxlbWFwXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlLmFkZERlcGVuZGVuY3kobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHRpbGVzZXQudGlsZXMpe1xuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHRpbGUgb2YgdGlsZXNldC50aWxlcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQga2V5ID0gdGlsZS5pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXRoID0gU3RyaW5nVXRpbHMuZ2V0UGF0aEZyb21GaWxlUGF0aChwYXRoVG9UaWxlbWFwSlNPTikgKyBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRoLCBpc0RlcGVuZGVuY3k6IHRydWV9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoaXMgaW1hZ2UgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSB0aWxlbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5hZGREZXBlbmRlbmN5KG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHJlc291cmNlIHJlZmVyZW5jZSB0byB0aGUgbGlzdCBvZiByZXNvdXJjZSB0byB1bmxvYWRcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChyZXNvdXJjZSk7XG5cbiAgICAgICAgICAgIC8vIEZpbmlzaCBsb2FkaW5nXG4gICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmdUaWxlbWFwKGNhbGxiYWNrSWZMYXN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluaXNoIGxvYWRpbmcgYSB0aWxlbWFwLiBDYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaWYgdGhpcyBpcyB0aGUgbGFzdCB0aWxlbWFwIGJlaW5nIGxvYWRlZFxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IHRpbGVtYXAgdG8gbG9hZFxuICAgICAqL1xuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZ1RpbGVtYXAoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQgKz0gMTtcblxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X3RpbGVtYXBzTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkKXtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUgbG9hZGluZyB0aWxlbWFwc1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGFsbCBzcHJpdGVzaGVldHMgY3VycmVudGx5IGluIHRoZSBzcHJpdGVzaGVldCBsb2FkaW5nIHF1ZXVlXG4gICAgICogQHBhcmFtIG9uRmluaXNoTG9hZGluZyBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBzcHJpdGVzaGVldHMgYXJlIGRvbmUgbG9hZGluZ1xuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZFNwcml0ZXNoZWV0c0Zyb21RdWV1ZShvbkZpbmlzaExvYWRpbmc6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldExvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkID0gMDtcblxuICAgICAgICAvLyBJZiBubyBpdGVtcyB0byBsb2FkLCB3ZSdyZSBmaW5pc2hlZFxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZCA9PT0gMCl7XG4gICAgICAgICAgICBvbkZpbmlzaExvYWRpbmcoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlKHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWUuaGFzSXRlbXMoKSl7XG4gICAgICAgICAgICBsZXQgc3ByaXRlc2hlZXQgPSB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZFNwcml0ZXNoZWV0KHNwcml0ZXNoZWV0LmtleSwgc3ByaXRlc2hlZXQucGF0aCwgb25GaW5pc2hMb2FkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGEgc2luZ3VsYXIgc3ByaXRlc2hlZXQgXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBzcHJpdGVzaGVldCB0byBsb2FkXG4gICAgICogQHBhcmFtIHBhdGhUb1Nwcml0ZXNoZWV0SlNPTiBUaGUgcGF0aCB0byB0aGUgc3ByaXRlc2hlZXQgSlNPTiBmaWxlXG4gICAgICogQHBhcmFtIGNhbGxiYWNrSWZMYXN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3Qgc3ByaXRlc2hlZXRcbiAgICAgKi9cbiAgICBwcml2YXRlIGxvYWRTcHJpdGVzaGVldChrZXk6IHN0cmluZywgcGF0aFRvU3ByaXRlc2hlZXRKU09OOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZShwYXRoVG9TcHJpdGVzaGVldEpTT04sIChmaWxlVGV4dDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBsZXQgc3ByaXRlc2hlZXQgPSA8U3ByaXRlc2hlZXQ+SlNPTi5wYXJzZShmaWxlVGV4dCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFdlIGNhbiBwYXJzZSB0aGUgb2JqZWN0IGxhdGVyIC0gaXQncyBtdWNoIGZhc3RlciB0aGFuIGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlc2hlZXRzLmFkZChrZXksIHNwcml0ZXNoZWV0KTtcblxuICAgICAgICAgICAgbGV0IHJlc291cmNlID0gbmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLlNQUklURVNIRUVUKTtcblxuICAgICAgICAgICAgLy8gR3JhYiB0aGUgaW1hZ2Ugd2UgbmVlZCB0byBsb2FkIGFuZCBhZGQgaXQgdG8gdGhlIGltYWdlbG9hZGluZyBxdWV1ZVxuICAgICAgICAgICAgbGV0IHBhdGggPSBTdHJpbmdVdGlscy5nZXRQYXRoRnJvbUZpbGVQYXRoKHBhdGhUb1Nwcml0ZXNoZWV0SlNPTikgKyBzcHJpdGVzaGVldC5zcHJpdGVTaGVldEltYWdlO1xuICAgICAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IHNwcml0ZXNoZWV0Lm5hbWUsIHBhdGg6IHBhdGgsIGlzRGVwZW5kZW5jeTogdHJ1ZX0pO1xuXG4gICAgICAgICAgICByZXNvdXJjZS5hZGREZXBlbmRlbmN5KG5ldyBSZXNvdXJjZVJlZmVyZW5jZShzcHJpdGVzaGVldC5uYW1lLCBSZXNvdXJjZVR5cGUuSU1BR0UpKTtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChyZXNvdXJjZSk7XG5cbiAgICAgICAgICAgIC8vIEZpbmlzaCBsb2FkaW5nXG4gICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmdTcHJpdGVzaGVldChjYWxsYmFja0lmTGFzdCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGEgc3ByaXRlc2hlZXQuIENhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpZiB0aGlzIGlzIHRoZSBsYXN0IHNwcml0ZXNoZWV0IGJlaW5nIGxvYWRlZFxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IHNwcml0ZXNoZWV0IHRvIGxvYWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdTcHJpdGVzaGVldChjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQgKz0gMTtcblxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZCA9PT0gdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQpe1xuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIHNwcml0ZXNoZWV0c1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGFsbCBpbWFnZXMgY3VycmVudGx5IGluIHRoZSBpbWFnZSBsb2FkaW5nIHF1ZXVlXG4gICAgICogQHBhcmFtIG9uRmluaXNoTG9hZGluZyBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIGltYWdlcyB0byBsb2FkXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkSW1hZ2VzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZXNUb0xvYWQgPSB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQgPSAwO1xuXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfaW1hZ2VzVG9Mb2FkID09PSAwKXtcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUodGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcbiAgICAgICAgICAgIGxldCBpbWFnZSA9IHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgdGhpcy5sb2FkSW1hZ2UoaW1hZ2Uua2V5LCBpbWFnZS5wYXRoLCBpbWFnZS5pc0RlcGVuZGVuY3ksIG9uRmluaXNoTG9hZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIHNpbmd1bGFyIGltYWdlXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpbWFnZSB0byBsb2FkXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGltYWdlIHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tJZkxhc3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBpbWFnZVxuICAgICAqL1xuICAgIHB1YmxpYyBsb2FkSW1hZ2Uoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZywgaXNEZXBlbmRlbmN5OiBib29sZWFuLCBjYWxsYmFja0lmTGFzdDogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG5cbiAgICAgICAgaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gQWRkIHRvIGxvYWRlZCBpbWFnZXNcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VzLmFkZChrZXksIGltYWdlKTtcblxuICAgICAgICAgICAgLy8gSWYgbm90IGEgZGVwZW5kZW5jeSwgcHVzaCBpdCB0byB0aGUgdW5sb2FkIGxpc3QuIE90aGVyd2lzZSBpdCdzIG1hbmFnZWQgYnkgc29tZXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGlmKCFpc0RlcGVuZGVuY3kpe1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSU1BR0UpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgV2ViR0wgaXMgYWN0aXZlLCBjcmVhdGUgYSB0ZXh0dXJlXG4gICAgICAgICAgICBpZih0aGlzLmdsX1dlYkdMQWN0aXZlKXtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVdlYkdMVGV4dHVyZShrZXksIGltYWdlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmluaXNoIGltYWdlIGxvYWRcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ0ltYWdlKGNhbGxiYWNrSWZMYXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGltYWdlLnNyYyA9IHBhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluaXNoIGxvYWRpbmcgYW4gaW1hZ2UuIElmIHRoaXMgaXMgdGhlIGxhc3QgaW1hZ2UsIGl0IGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IGltYWdlXG4gICAgICovXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nSW1hZ2UoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkICs9IDE7XG5cbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfaW1hZ2VzVG9Mb2FkICl7XG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgaW1hZ2VzXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYWxsIGF1ZGlvIGN1cnJlbnRseSBpbiB0aGUgdGlsZW1hcCBsb2FkaW5nIHF1ZXVlXG4gICAgICogQHBhcmFtIG9uRmluaXNoTG9hZGluZyBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRpbGVtYXBzIGFyZSBkb25lIGxvYWRpbmdcbiAgICAgKi9cbiAgICBwcml2YXRlIGxvYWRBdWRpb0Zyb21RdWV1ZShvbkZpbmlzaExvYWRpbmc6IEZ1bmN0aW9uKXtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb1RvTG9hZCA9IHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGVkID0gMDtcblxuICAgICAgICAvLyBJZiBubyBpdGVtcyB0byBsb2FkLCB3ZSdyZSBmaW5pc2hlZFxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2F1ZGlvVG9Mb2FkID09PSAwKXtcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUodGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcbiAgICAgICAgICAgIGxldCBhdWRpbyA9IHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgdGhpcy5sb2FkQXVkaW8oYXVkaW8ua2V5LCBhdWRpby5wYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIHNpbmd1bGFyIGF1ZGlvIGZpbGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gdGhlIGF1ZGlvIGZpbGUgdG8gbG9hZFxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhdWRpbyBmaWxlIHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tJZkxhc3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBhdWRpbyBmaWxlIHRvIGxvYWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGxvYWRBdWRpbyhrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nLCBjYWxsYmFja0lmTGFzdDogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgbGV0IGF1ZGlvQ3R4ID0gQXVkaW9NYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0QXVkaW9Db250ZXh0KCk7XG5cbiAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBwYXRoLCB0cnVlKTtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXG4gICAgICAgIHJlcXVlc3Qub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgYXVkaW9DdHguZGVjb2RlQXVkaW9EYXRhKHJlcXVlc3QucmVzcG9uc2UsIChidWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gbGlzdCBvZiBhdWRpbyBidWZmZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0J1ZmZlcnMuYWRkKGtleSwgYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLkFVRElPKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5pc2ggbG9hZGluZyBzb3VuZFxuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ0F1ZGlvKGNhbGxiYWNrSWZMYXN0KTtcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT57XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJFcnJvciBsb2FkaW5nIHNvdW5kXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggbG9hZGluZyBhbiBhdWRpbyBmaWxlLiBDYWxscyB0aGUgY2FsbGJhY2sgZnVuY3RvbiBpZiB0aGlzIGlzIHRoZSBsYXN0IGF1ZGlvIHNhbXBsZSBiZWluZyBsb2FkZWQuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgYXVkaW8gZmlsZSB0byBsb2FkXG4gICAgICovXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nQXVkaW8oY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQgKz0gMTtcblxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X2F1ZGlvVG9Mb2FkKXtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUgbG9hZGluZyBhdWRpb1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGFsbCBvYmplY3RzIGN1cnJlbnRseSBpbiB0aGUgb2JqZWN0IGxvYWRpbmcgcXVldWVcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgb2JqZWN0cyB0byBsb2FkXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkT2JqZWN0c0Zyb21RdWV1ZShvbkZpbmlzaExvYWRpbmc6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvblRvTG9hZCA9IHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvbkxvYWRlZCA9IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9qc29uVG9Mb2FkID09PSAwKXtcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUodGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xuICAgICAgICAgICAgbGV0IG9iaiA9IHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRPYmplY3Qob2JqLmtleSwgb2JqLnBhdGgsIG9uRmluaXNoTG9hZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIHNpbmd1bGFyIG9iamVjdFxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgb2JqZWN0IHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgb2JqZWN0IHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tJZkxhc3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBvYmplY3RcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9hZE9iamVjdChrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nLCBjYWxsYmFja0lmTGFzdDogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2FkVGV4dEZpbGUocGF0aCwgKGZpbGVUZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGxldCBvYmogPSBKU09OLnBhcnNlKGZpbGVUZXh0KTtcbiAgICAgICAgICAgIHRoaXMuanNvbk9iamVjdHMuYWRkKGtleSwgb2JqKTtcblxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5KU09OKSk7XG5cbiAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ09iamVjdChjYWxsYmFja0lmTGFzdCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGFuIG9iamVjdC4gSWYgdGhpcyBpcyB0aGUgbGFzdCBvYmplY3QsIGl0IGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IG9iamVjdFxuICAgICAqL1xuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZ09iamVjdChjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGVkICs9IDE7XG5cbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9qc29uTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X2pzb25Ub0xvYWQpe1xuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIG9iamVjdHNcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAjIyMjIyMjIyMjIFdFQkdMIFNQRUNJRklDIEZVTkNUSU9OUyAjIyMjIyMjIyMjICovXG5cbiAgICBwdWJsaWMgZ2V0VGV4dHVyZShrZXk6IHN0cmluZyk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmdsX1RleHR1cmVzLmdldChrZXkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRTaGFkZXJQcm9ncmFtKGtleTogc3RyaW5nKTogV2ViR0xQcm9ncmFtIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMuZ2V0KGtleSkucHJvZ3JhbTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0QnVmZmVyKGtleTogc3RyaW5nKTogV2ViR0xCdWZmZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5nbF9CdWZmZXJzLmdldChrZXkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlV2ViR0xUZXh0dXJlKGltYWdlS2V5OiBzdHJpbmcsIGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIC8vIEdldCB0aGUgdGV4dHVyZSBJRFxuICAgICAgICBjb25zdCB0ZXh0dXJlSUQgPSB0aGlzLmdldFRleHR1cmVJRCh0aGlzLmdsX05leHRUZXh0dXJlSUQpO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgdGV4dHVyZVxuICAgICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5nbC5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICAgICAgLy8gU2V0IHVwIHRoZSB0ZXh0dXJlXG4gICAgICAgIC8vIEVuYWJsZSB0ZXh0dXJlMFxuICAgICAgICB0aGlzLmdsLmFjdGl2ZVRleHR1cmUodGV4dHVyZUlEKTtcblxuICAgICAgICAvLyBCaW5kIG91ciB0ZXh0dXJlIHRvIHRleHR1cmUgMFxuICAgICAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSB0ZXh0dXJlIHBhcmFtZXRlcnNcbiAgICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuZ2wuTElORUFSKTtcbiAgICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfUywgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcblxuICAgICAgICAvLyBTZXQgdGhlIHRleHR1cmUgaW1hZ2VcbiAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgdGV4dHVyZSB0byBvdXIgbWFwIHdpdGggdGhlIHNhbWUga2V5IGFzIHRoZSBpbWFnZVxuICAgICAgICB0aGlzLmdsX1RleHR1cmVzLmFkZChpbWFnZUtleSwgdGhpcy5nbF9OZXh0VGV4dHVyZUlEKTtcblxuICAgICAgICAvLyBJbmNyZW1lbnQgdGhlIGtleVxuICAgICAgICB0aGlzLmdsX05leHRUZXh0dXJlSUQgKz0gMTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRleHR1cmVJRChpZDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgLy8gU3RhcnQgd2l0aCA5IGNhc2VzIC0gdGhpcyBjYW4gYmUgZXhwYW5kZWQgaWYgbmVlZGVkLCBidXQgZm9yIHRoZSBiZXN0IHBlcmZvcm1hbmNlLFxuICAgICAgICAvLyBUZXh0dXJlcyBzaG91bGQgYmUgc3RpdGNoZWQgaW50byBhbiBhdGxhc1xuICAgICAgICBzd2l0Y2goaWQpe1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gdGhpcy5nbC5URVhUVVJFMDtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTE7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiB0aGlzLmdsLlRFWFRVUkUyO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gdGhpcy5nbC5URVhUVVJFMztcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTQ7XG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU1O1xuICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gdGhpcy5nbC5URVhUVVJFNjtcbiAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTc7XG4gICAgICAgICAgICBjYXNlIDg6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU4O1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgY3JlYXRlQnVmZmVyKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xuICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZ2xfQnVmZmVycy5hZGQoa2V5LCBidWZmZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5xdWV1ZXMgbG9hZGluZyBvZiBhIG5ldyBzaGFkZXIgcHJvZ3JhbVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgc2hhZGVyIHByb2dyYW1cbiAgICAgKiBAcGFyYW0gdlNoYWRlckZpbGVwYXRoIFxuICAgICAqIEBwYXJhbSBmU2hhZGVyRmlsZXBhdGggXG4gICAgICovXG4gICAgcHVibGljIHNoYWRlcihrZXk6IHN0cmluZywgdlNoYWRlckZpbGVwYXRoOiBzdHJpbmcsIGZTaGFkZXJGaWxlcGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGxldCBzcGxpdFBhdGggPSB2U2hhZGVyRmlsZXBhdGguc3BsaXQoXCIuXCIpO1xuICAgICAgICBsZXQgZW5kID0gc3BsaXRQYXRoW3NwbGl0UGF0aC5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZihlbmQgIT09IFwidnNoYWRlclwiKXtcbiAgICAgICAgICAgIHRocm93IGAke3ZTaGFkZXJGaWxlcGF0aH0gaXMgbm90IGEgdmFsaWQgdmVydGV4IHNoYWRlciAtIG11c3QgZW5kIGluIFwiLnZzaGFkZXJgO1xuICAgICAgICB9XG5cbiAgICAgICAgc3BsaXRQYXRoID0gZlNoYWRlckZpbGVwYXRoLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgZW5kID0gc3BsaXRQYXRoW3NwbGl0UGF0aC5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZihlbmQgIT09IFwiZnNoYWRlclwiKXtcbiAgICAgICAgICAgIHRocm93IGAke2ZTaGFkZXJGaWxlcGF0aH0gaXMgbm90IGEgdmFsaWQgdmVydGV4IHNoYWRlciAtIG11c3QgZW5kIGluIFwiLmZzaGFkZXJgO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBhdGhzID0gbmV3IEtleVBhdGhfU2hhZGVyKCk7XG4gICAgICAgIHBhdGhzLmtleSA9IGtleTtcbiAgICAgICAgcGF0aHMudnBhdGggPSB2U2hhZGVyRmlsZXBhdGg7XG4gICAgICAgIHBhdGhzLmZwYXRoID0gZlNoYWRlckZpbGVwYXRoO1xuXG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyTG9hZGluZ1F1ZXVlLmVucXVldWUocGF0aHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcbiAgICAgKi9cbiAgICAgcHVibGljIGtlZXBTaGFkZXIoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSU1BR0UpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2xfTG9hZFNoYWRlcnNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xuICAgICAgICB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zTG9hZGVkID0gMDtcblxuICAgICAgICAvLyBJZiB3ZWJHTCBpc24nYWN0aXZlIG9yIHRoZXJlIGFyZSBubyBpdGVtcyB0byBsb2FkLCB3ZSdyZSBmaW5pc2hlZFxuICAgICAgICBpZighdGhpcy5nbF9XZWJHTEFjdGl2ZSB8fCB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zVG9Mb2FkID09PSAwKXtcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUodGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUuaGFzSXRlbXMoKSl7XG4gICAgICAgICAgICBsZXQgc2hhZGVyID0gdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgdGhpcy5nbF9Mb2FkU2hhZGVyKHNoYWRlci5rZXksIHNoYWRlci52cGF0aCwgc2hhZGVyLmZwYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnbF9Mb2FkU2hhZGVyKGtleTogc3RyaW5nLCB2cGF0aDogc3RyaW5nLCBmcGF0aDogc3RyaW5nLCBjYWxsYmFja0lmTGFzdDogRnVuY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5sb2FkVGV4dEZpbGUodnBhdGgsICh2RmlsZVRleHQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdlNoYWRlciA9IHZGaWxlVGV4dDtcblxuICAgICAgICAgICAgdGhpcy5sb2FkVGV4dEZpbGUoZnBhdGgsIChmRmlsZVRleHQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZTaGFkZXIgPSBmRmlsZVRleHRcblxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIHByb2dyYW0gYW5kIHNoYWRlcnNcbiAgICAgICAgICAgICAgICBjb25zdCBbc2hhZGVyUHJvZ3JhbSwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0gPSB0aGlzLmNyZWF0ZVNoYWRlclByb2dyYW0odlNoYWRlciwgZlNoYWRlcik7XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSB3cmFwcGVyIHR5cGVcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9ncmFtV3JhcHBlciA9IG5ldyBXZWJHTFByb2dyYW1UeXBlKCk7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbVdyYXBwZXIucHJvZ3JhbSA9IHNoYWRlclByb2dyYW07XG4gICAgICAgICAgICAgICAgcHJvZ3JhbVdyYXBwZXIudmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyO1xuICAgICAgICAgICAgICAgIHByb2dyYW1XcmFwcGVyLmZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXI7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gb3VyIG1hcFxuICAgICAgICAgICAgICAgIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMuYWRkKGtleSwgcHJvZ3JhbVdyYXBwZXIpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5TSEFERVIpKTtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmlzaCBsb2FkaW5nXG4gICAgICAgICAgICAgICAgdGhpcy5nbF9GaW5pc2hMb2FkaW5nU2hhZGVyKGNhbGxiYWNrSWZMYXN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdsX0ZpbmlzaExvYWRpbmdTaGFkZXIoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNMb2FkZWQgKz0gMTtcblxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zVG9Mb2FkKXtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUgbG9hZGluZyBzaGFkZXJzXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVTaGFkZXJQcm9ncmFtKHZTaGFkZXJTb3VyY2U6IHN0cmluZywgZlNoYWRlclNvdXJjZTogc3RyaW5nKXtcbiAgICAgICAgY29uc3QgdmVydGV4U2hhZGVyID0gdGhpcy5sb2FkVmVydGV4U2hhZGVyKHZTaGFkZXJTb3VyY2UpO1xuICAgICAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IHRoaXMubG9hZEZyYWdtZW50U2hhZGVyKGZTaGFkZXJTb3VyY2UpO1xuICAgIFxuICAgICAgICBpZih2ZXJ0ZXhTaGFkZXIgPT09IG51bGwgfHwgZnJhZ21lbnRTaGFkZXIgPT09IG51bGwpe1xuICAgICAgICAgICAgLy8gV2UgaGFkIGEgcHJvYmxlbSBpbnRpYWxpemluZyAtIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBDcmVhdGUgYSBzaGFkZXIgcHJvZ3JhbVxuICAgICAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5nbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICAgIGlmKCFwcm9ncmFtKSB7XG4gICAgICAgICAgICAvLyBFcnJvciBjcmVhdGluZ1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGNyZWF0ZSBwcm9ncmFtXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gQXR0YWNoIG91ciB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlclxuICAgICAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICAgICAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgXG4gICAgICAgIC8vIExpbmtcbiAgICAgICAgdGhpcy5nbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgaWYoIXRoaXMuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCB0aGlzLmdsLkxJTktfU1RBVFVTKSl7XG4gICAgICAgICAgICAvLyBFcnJvciBsaW5raW5nXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gbGluayBwcm9ncmFtOiBcIiArIGVycm9yKTtcbiAgICBcbiAgICAgICAgICAgIC8vIENsZWFuIHVwXG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgICAgICAgICAgdGhpcy5nbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gV2Ugc3VjY2Vzc2Z1bGx5IGNyZWF0ZSBhIHByb2dyYW1cbiAgICAgICAgcmV0dXJuIFtwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXTtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBsb2FkVmVydGV4U2hhZGVyKHNoYWRlclNvdXJjZTogc3RyaW5nKTogV2ViR0xTaGFkZXJ7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRTaGFkZXIodGhpcy5nbC5WRVJURVhfU0hBREVSLCBzaGFkZXJTb3VyY2UpO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIGxvYWRGcmFnbWVudFNoYWRlcihzaGFkZXJTb3VyY2U6IHN0cmluZyk6IFdlYkdMU2hhZGVye1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgc2hhZGVyXG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRTaGFkZXIodGhpcy5nbC5GUkFHTUVOVF9TSEFERVIsIHNoYWRlclNvdXJjZSk7XHRcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBsb2FkU2hhZGVyKHR5cGU6IG51bWJlciwgc2hhZGVyU291cmNlOiBzdHJpbmcpOiBXZWJHTFNoYWRlcntcbiAgICAgICAgY29uc3Qgc2hhZGVyID0gdGhpcy5nbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gICAgXG4gICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGNyZWF0ZSB0aGUgc2hhZGVyLCBlcnJvclxuICAgICAgICBpZihzaGFkZXIgPT09IG51bGwpe1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5hYmxlIHRvIGNyZWF0ZSBzaGFkZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBBZGQgdGhlIHNvdXJjZSB0byB0aGUgc2hhZGVyIGFuZCBjb21waWxlXG4gICAgICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcbiAgICAgICAgdGhpcy5nbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSB3ZXJlIG5vIGVycm9ycyBkdXJpbmcgdGhpcyBwcm9jZXNzXG4gICAgICAgIGlmKCF0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIHRoaXMuZ2wuQ09NUElMRV9TVEFUVVMpKXtcbiAgICAgICAgICAgIC8vIE5vdCBjb21waWxlZCAtIGVycm9yXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGNvbXBpbGUgc2hhZGVyOiBcIiArIGVycm9yKTtcbiAgICBcbiAgICAgICAgICAgIC8vIENsZWFuIHVwXG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gU3VjZXNzLCBzbyByZXR1cm4gdGhlIHNoYWRlclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xuICAgIH1cblxuICAgIC8qICMjIyMjIyMjIyMgR0VORVJBTCBMT0FESU5HIEZVTkNUSU9OUyAjIyMjIyMjIyMjICovXG5cbiAgICBwcml2YXRlIGxvYWRUZXh0RmlsZSh0ZXh0RmlsZVBhdGg6IHN0cmluZywgY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgICAgIGxldCB4b2JqOiBYTUxIdHRwUmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4b2JqLm92ZXJyaWRlTWltZVR5cGUoXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICB4b2JqLm9wZW4oJ0dFVCcsIHRleHRGaWxlUGF0aCwgdHJ1ZSk7XG4gICAgICAgIHhvYmoub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCh4b2JqLnJlYWR5U3RhdGUgPT0gNCkgJiYgKHhvYmouc3RhdHVzID09IDIwMCkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh4b2JqLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhvYmouc2VuZChudWxsKTtcbiAgICB9XG5cbiAgICAvKiAjIyMjIyMjIyMjIExPQURJTkcgQkFSIElORk8gIyMjIyMjIyMjIyAqL1xuXG4gICAgcHJpdmF0ZSBnZXRMb2FkUGVyY2VudCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gKHRoaXMubG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQvdGhpcy5sb2Fkb25seV90aWxlbWFwc1RvTG9hZFxuICAgICAgICAgICAgKyB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZC90aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZFxuICAgICAgICAgICAgKyB0aGlzLmxvYWRvbmx5X2ltYWdlc0xvYWRlZC90aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZFxuICAgICAgICAgICAgKyB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGVkL3RoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQpXG4gICAgICAgICAgICAvIHRoaXMubG9hZG9ubHlfdHlwZXNUb0xvYWQ7XG4gICAgfVxuXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmKHRoaXMubG9hZGluZyl7XG4gICAgICAgICAgICBpZih0aGlzLm9uTG9hZFByb2dyZXNzKXtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTG9hZFByb2dyZXNzKHRoaXMuZ2V0TG9hZFBlcmNlbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZih0aGlzLmp1c3RMb2FkZWQpe1xuICAgICAgICAgICAgdGhpcy5qdXN0TG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZih0aGlzLm9uTG9hZENvbXBsZXRlKXtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTG9hZENvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSByZWZlcmVuY2UgdG8gYSByZXNvdXJjZS5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgdGhlIGV4ZW1wdGlvbiBsaXN0IHRvIGFzc3VyZSBhc3NldHMgYW5kIHRoZWlyIGRlcGVuZGVuY2llcyBkb24ndCBnZXRcbiAqIGRlc3Ryb3llZCBpZiB0aGV5IGFyZSBzdGlsbCBuZWVkZWQuXG4gKi9cbmNsYXNzIFJlc291cmNlUmVmZXJlbmNlIHtcbiAgICBrZXk6IHN0cmluZztcbiAgICByZXNvdXJjZVR5cGU6IFJlc291cmNlVHlwZTtcbiAgICBkZXBlbmRlbmNpZXM6IEFycmF5PFJlc291cmNlUmVmZXJlbmNlPjtcblxuICAgIGNvbnN0cnVjdG9yKGtleTogc3RyaW5nLCByZXNvdXJjZVR5cGU6IFJlc291cmNlVHlwZSl7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnJlc291cmNlVHlwZSA9IHJlc291cmNlVHlwZTtcbiAgICAgICAgdGhpcy4gZGVwZW5kZW5jaWVzID0gbmV3IEFycmF5KCk7XG4gICAgfVxuXG4gICAgYWRkRGVwZW5kZW5jeShyZXNvdXJjZTogUmVzb3VyY2VSZWZlcmVuY2UpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMucHVzaChyZXNvdXJjZSk7XG4gICAgfVxufVxuXG5cbmVudW0gUmVzb3VyY2VUeXBlIHtcbiAgICBJTUFHRSA9IFwiSU1BR0VcIixcbiAgICBUSUxFTUFQID0gXCJUSUxFTUFQXCIsXG4gICAgU1BSSVRFU0hFRVQgPSBcIlNQUklURVNIRUVUXCIsXG4gICAgQVVESU8gPSBcIkFVRElPXCIsXG4gICAgSlNPTiA9IFwiSlNPTlwiLFxuICAgIFNIQURFUiA9IFwiU0hBREVSXCJcbn1cblxuLyoqXG4gKiBBIHBhaXIgcmVwcmVzZW50aW5nIGEga2V5IGFuZCB0aGUgcGF0aCBvZiB0aGUgcmVzb3VyY2UgdG8gbG9hZFxuICovXG5jbGFzcyBLZXlQYXRoUGFpciB7XG4gICAga2V5OiBzdHJpbmc7XG4gICAgcGF0aDogc3RyaW5nO1xuICAgIGlzRGVwZW5kZW5jeT86IGJvb2xlYW4gPSBmYWxzZTtcbn1cblxuY2xhc3MgS2V5UGF0aF9TaGFkZXIge1xuICAgIGtleTogc3RyaW5nO1xuICAgIHZwYXRoOiBzdHJpbmc7XG4gICAgZnBhdGg6IHN0cmluZztcbn0iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lXCI7XG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRcIjtcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljXCI7XG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XG5pbXBvcnQgeyBHcmFwaGljVHlwZSB9IGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXNcIjtcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xuaW1wb3J0IFBvaW50IGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9Qb2ludFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgQnV0dG9uIGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvblwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XG5pbXBvcnQgU2xpZGVyIGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1NsaWRlclwiO1xuaW1wb3J0IFRleHRJbnB1dCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9UZXh0SW5wdXRcIjtcbmltcG9ydCBSZWN0IGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgTGluZSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvTGluZVwiO1xuaW1wb3J0IFBhcnRpY2xlIGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9QYXJ0aWNsZVwiO1xuXG4vLyBAaWdub3JlUGFnZVxuXG4vKipcbiAqIEEgZmFjdG9yeSB0aGF0IGFic3RyYWN0cyBhZGRpbmcgQHJlZmVyZW5jZVtDYW52YXNOb2RlXXMgdG8gdGhlIEByZWZlcmVuY2VbU2NlbmVdLlxuICogQWNjZXNzIG1ldGhvZHMgaW4gdGhpcyBmYWN0b3J5IHRocm91Z2ggU2NlbmUuYWRkLlttZXRob2ROYW1lXSgpLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYW52YXNOb2RlRmFjdG9yeSB7XG5cdHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XG5cdHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcblxuXHRpbml0KHNjZW5lOiBTY2VuZSk6IHZvaWQge1xuXHRcdHRoaXMuc2NlbmUgPSBzY2VuZTtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gaW5zdGFuY2Ugb2YgYSBVSUVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgc2NlbmUgLSBpLmUuIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgVUlFbGVtZW50XG5cdCAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIFVJRWxlbWVudCB0byBhZGRcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgdG8gYWRkIHRoZSBVSUVsZW1lbnQgdG9cblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGZlZWQgdG8gdGhlIGNvbnN0cnVjdG9yXG5cdCAqIEByZXR1cm5zIEEgbmV3IFVJRWxlbWVudFxuXHQgKi9cblx0YWRkVUlFbGVtZW50ID0gKHR5cGU6IHN0cmluZyB8IFVJRWxlbWVudFR5cGUsIGxheWVyTmFtZTogc3RyaW5nLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFVJRWxlbWVudCA9PiB7XG5cdFx0Ly8gR2V0IHRoZSBsYXllclxuXHRcdGxldCBsYXllciA9IHRoaXMuc2NlbmUuZ2V0TGF5ZXIobGF5ZXJOYW1lKTtcblxuXHRcdGxldCBpbnN0YW5jZTogVUlFbGVtZW50O1xuXG5cdFx0c3dpdGNoKHR5cGUpe1xuXHRcdFx0Y2FzZSBVSUVsZW1lbnRUeXBlLkJVVFRPTjpcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkQnV0dG9uKG9wdGlvbnMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFVJRWxlbWVudFR5cGUuTEFCRUw6XG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZExhYmVsKG9wdGlvbnMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFVJRWxlbWVudFR5cGUuU0xJREVSOlxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRTbGlkZXIob3B0aW9ucyk7XG5cdFx0XHRicmVhaztcblx0XHRcdGNhc2UgVUlFbGVtZW50VHlwZS5URVhUX0lOUFVUOlxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRUZXh0SW5wdXQob3B0aW9ucyk7XG5cdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IGBVSUVsZW1lbnRUeXBlICcke3R5cGV9JyBkb2VzIG5vdCBleGlzdCwgb3IgaXMgcmVnaXN0ZXJlZCBpbmNvcnJlY3RseS5gXG5cdFx0fVxuXG5cdFx0aW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XG5cdFx0aW5zdGFuY2UuaWQgPSB0aGlzLnNjZW5lLmdlbmVyYXRlSWQoKTtcblx0XHR0aGlzLnNjZW5lLmdldFNjZW5lR3JhcGgoKS5hZGROb2RlKGluc3RhbmNlKTtcblxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxuXHRcdGxheWVyLmFkZE5vZGUoaW5zdGFuY2UpXG5cblx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIHNwcml0ZSB0byB0aGUgY3VycmVudCBzY2VuZVxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRoZSBzcHJpdGUgd2lsbCByZXByZXNlbnRcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBzcHJpdGVcblx0ICogQHJldHVybnMgQSBuZXcgU3ByaXRlXG5cdCAqL1xuXHRhZGRTcHJpdGUgPSAoa2V5OiBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nKTogU3ByaXRlID0+IHtcblx0XHRsZXQgbGF5ZXIgPSB0aGlzLnNjZW5lLmdldExheWVyKGxheWVyTmFtZSk7XG5cblx0XHRsZXQgaW5zdGFuY2UgPSBuZXcgU3ByaXRlKGtleSk7XG5cblx0XHQvLyBBZGQgaW5zdGFuY2UgdG8gc2NlbmVcblx0XHRpbnN0YW5jZS5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcblx0XHRpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xuXG5cdFx0aWYoISh0aGlzLnNjZW5lLmlzUGFyYWxsYXhMYXllcihsYXllck5hbWUpIHx8IHRoaXMuc2NlbmUuaXNVSUxheWVyKGxheWVyTmFtZSkpKXtcblx0XHRcdHRoaXMuc2NlbmUuZ2V0U2NlbmVHcmFwaCgpLmFkZE5vZGUoaW5zdGFuY2UpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBBZGQgaW5zdGFuY2UgdG8gbGF5ZXJcblx0XHRsYXllci5hZGROb2RlKGluc3RhbmNlKTtcblxuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIEFuaW1hdGVkU3ByaXRlIHRvIHRoZSBjdXJyZW50IHNjZW5lXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdGhlIHNwcml0ZSB3aWxsIHJlcHJlc2VudFxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIHNwcml0ZVxuXHQgKiBAcmV0dXJucyBBIG5ldyBBbmltYXRlZFNwcml0ZVxuXHQgKi9cblx0YWRkQW5pbWF0ZWRTcHJpdGUgPSAoa2V5OiBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nKTogQW5pbWF0ZWRTcHJpdGUgPT4ge1xuXHRcdGxldCBsYXllciA9IHRoaXMuc2NlbmUuZ2V0TGF5ZXIobGF5ZXJOYW1lKTtcblx0XHRsZXQgc3ByaXRlc2hlZXQgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTcHJpdGVzaGVldChrZXkpO1xuXHRcdGxldCBpbnN0YW5jZSA9IG5ldyBBbmltYXRlZFNwcml0ZShzcHJpdGVzaGVldCk7XG5cblx0XHQvLyBBZGQgaW5zdGFuY2UgZm8gc2NlbmVcblx0XHRpbnN0YW5jZS5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcblx0XHRpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xuXHRcdFxuXHRcdGlmKCEodGhpcy5zY2VuZS5pc1BhcmFsbGF4TGF5ZXIobGF5ZXJOYW1lKSB8fCB0aGlzLnNjZW5lLmlzVUlMYXllcihsYXllck5hbWUpKSl7XG5cdFx0XHR0aGlzLnNjZW5lLmdldFNjZW5lR3JhcGgoKS5hZGROb2RlKGluc3RhbmNlKTtcblx0XHR9XG5cblx0XHQvLyBBZGQgaW5zdGFuY2UgdG8gbGF5ZXJcblx0XHRsYXllci5hZGROb2RlKGluc3RhbmNlKTtcblxuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbmV3IGdyYXBoaWMgZWxlbWVudCB0byB0aGUgY3VycmVudCBTY2VuZVxuXHQgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBncmFwaGljIHRvIGFkZFxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIGdyYXBoaWNcblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIGdyYXBoaWMgY29uc3RydWN0b3Jcblx0ICogQHJldHVybnMgQSBuZXcgR3JhcGhpY1xuXHQgKi9cblx0YWRkR3JhcGhpYyA9ICh0eXBlOiBHcmFwaGljVHlwZSB8IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogR3JhcGhpYyA9PiB7XG5cdFx0Ly8gR2V0IHRoZSBsYXllclxuXHRcdGxldCBsYXllciA9IHRoaXMuc2NlbmUuZ2V0TGF5ZXIobGF5ZXJOYW1lKTtcblxuXHRcdGxldCBpbnN0YW5jZTogR3JhcGhpYztcblxuXHRcdHN3aXRjaCh0eXBlKXtcblx0XHRcdGNhc2UgR3JhcGhpY1R5cGUuUE9JTlQ6XG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZFBvaW50KG9wdGlvbnMpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgR3JhcGhpY1R5cGUuTElORTpcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkTGluZShvcHRpb25zKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIEdyYXBoaWNUeXBlLlJFQ1Q6XG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZFJlY3Qob3B0aW9ucyk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBHcmFwaGljVHlwZS5QQVJUSUNMRTpcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkUGFydGljbGUob3B0aW9ucyk7XG5cdFx0XHRcdGJyZWFrO1x0XHRcdFx0XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBgR3JhcGhpY1R5cGUgJyR7dHlwZX0nIGRvZXMgbm90IGV4aXN0LCBvciBpcyByZWdpc3RlcmVkIGluY29ycmVjdGx5LmBcblx0XHR9XG5cblx0XHQvLyBBZGQgaW5zdGFuY2UgdG8gc2NlbmVcblx0XHRpbnN0YW5jZS5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcblx0XHRpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xuXG5cdFx0aWYoISh0aGlzLnNjZW5lLmlzUGFyYWxsYXhMYXllcihsYXllck5hbWUpIHx8IHRoaXMuc2NlbmUuaXNVSUxheWVyKGxheWVyTmFtZSkpKXtcblx0XHRcdHRoaXMuc2NlbmUuZ2V0U2NlbmVHcmFwaCgpLmFkZE5vZGUoaW5zdGFuY2UpO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxuXHRcdGxheWVyLmFkZE5vZGUoaW5zdGFuY2UpO1xuXG5cdFx0cmV0dXJuIGluc3RhbmNlO1xuXHR9XG5cblx0LyogLS0tLS0tLS0tLSBCVUlMREVSUyAtLS0tLS0tLS0tICovXG5cblx0YnVpbGRCdXR0b24ob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBCdXR0b24ge1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJCdXR0b25cIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIkJ1dHRvblwiLCBvcHRpb25zLCBcInRleHRcIiwgXCJzdHJpbmdcIik7XG5cblx0XHRyZXR1cm4gbmV3IEJ1dHRvbihvcHRpb25zLnBvc2l0aW9uLCBvcHRpb25zLnRleHQpO1xuXHR9XG5cblx0YnVpbGRMYWJlbChvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IExhYmVsIHtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiTGFiZWxcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIkxhYmVsXCIsIG9wdGlvbnMsIFwidGV4dFwiLCBcInN0cmluZ1wiKTtcblxuXHRcdHJldHVybiBuZXcgTGFiZWwob3B0aW9ucy5wb3NpdGlvbiwgb3B0aW9ucy50ZXh0KVxuXHR9XG5cblx0YnVpbGRTbGlkZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IFNsaWRlciB7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlNsaWRlclwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcblxuXHRcdGxldCBpbml0VmFsdWUgPSAwO1xuXHRcdGlmKG9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRpbml0VmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgU2xpZGVyKG9wdGlvbnMucG9zaXRpb24sIGluaXRWYWx1ZSk7XG5cdH1cblxuXHRidWlsZFRleHRJbnB1dChvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogVGV4dElucHV0IHtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiVGV4dElucHV0XCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xuXG5cdFx0cmV0dXJuIG5ldyBUZXh0SW5wdXQob3B0aW9ucy5wb3NpdGlvbik7XG5cdH1cblxuXHRidWlsZFBvaW50KG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUG9pbnQge1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJQb2ludFwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcblxuXHRcdHJldHVybiBuZXcgUG9pbnQob3B0aW9ucy5wb3NpdGlvbik7XG5cdH1cblxuXHRidWlsZFBhcnRpY2xlKG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUG9pbnQge1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJQYXJ0aWNsZVwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiUGFydGljbGVcIiwgb3B0aW9ucywgXCJzaXplXCIsIFZlYzIsIFwiVmVjMlwiKTtcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiUGFydGljbGVcIiwgb3B0aW9ucywgXCJtYXNzXCIsIFwibnVtYmVyXCIsIFwibnVtYmVyXCIpO1xuXG5cdFx0Ly9DaGFuZ2VkIGZvciB0ZXN0aW5nXG5cdFx0cmV0dXJuIG5ldyBQYXJ0aWNsZShvcHRpb25zLnBvc2l0aW9uLCBvcHRpb25zLnNpemUsIG9wdGlvbnMubWFzcyk7XG5cdH1cblxuXHRidWlsZExpbmUob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQb2ludCB7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIkxpbmVcIiwgb3B0aW9ucywgXCJzdGFydFwiLCBWZWMyLCBcIlZlYzJcIik7XG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIkxpbmVcIiwgb3B0aW9ucywgXCJlbmRcIiwgVmVjMiwgXCJWZWMyXCIpO1xuXG5cdFx0cmV0dXJuIG5ldyBMaW5lKG9wdGlvbnMuc3RhcnQsIG9wdGlvbnMuZW5kKTtcblx0fVxuXG5cdGJ1aWxkUmVjdChvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlY3Qge1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJSZWN0XCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJSZWN0XCIsIG9wdGlvbnMsIFwic2l6ZVwiLCBWZWMyLCBcIlZlYzJcIik7XG5cblx0XHRyZXR1cm4gbmV3IFJlY3Qob3B0aW9ucy5wb3NpdGlvbiwgb3B0aW9ucy5zaXplKTtcblx0fVxuXG5cdC8qIC0tLS0tLS0tLS0gRVJST1IgSEFORExJTkcgLS0tLS0tLS0tLSAqL1xuXG5cdGNoZWNrSWZQcm9wRXhpc3RzPFQ+KG9iamVjdE5hbWU6IHN0cmluZywgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiwgcHJvcDogc3RyaW5nLCB0eXBlOiAobmV3ICguLi5hcmdzOiBhbnkpID0+IFQpIHwgc3RyaW5nLCB0eXBlTmFtZT86IHN0cmluZyl7XG5cdFx0aWYoIW9wdGlvbnMgfHwgb3B0aW9uc1twcm9wXSA9PT0gdW5kZWZpbmVkKXtcblx0XHRcdC8vIENoZWNrIHRoYXQgdGhlIG9wdGlvbnMgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHlcblx0XHRcdHRocm93IGAke29iamVjdE5hbWV9IG9iamVjdCByZXF1aXJlcyBhcmd1bWVudCAke3Byb3B9IG9mIHR5cGUgJHt0eXBlTmFtZX0sIGJ1dCBub25lIHdhcyBwcm92aWRlZC5gO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBDaGVjayB0aGF0IHRoZSBwcm9wZXJ0eSBoYXMgdGhlIGNvcnJlY3QgdHlwZVxuXHRcdFx0aWYoKHR5cGVvZiB0eXBlKSA9PT0gXCJzdHJpbmdcIil7XG5cdFx0XHRcdGlmKCEodHlwZW9mIG9wdGlvbnNbcHJvcF0gPT09IHR5cGUpKXtcblx0XHRcdFx0XHR0aHJvdyBgJHtvYmplY3ROYW1lfSBvYmplY3QgcmVxdWlyZXMgYXJndW1lbnQgJHtwcm9wfSBvZiB0eXBlICR7dHlwZX0sIGJ1dCBwcm92aWRlZCAke3Byb3B9IHdhcyBub3Qgb2YgdHlwZSAke3R5cGV9LmA7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZih0eXBlIGluc3RhbmNlb2YgRnVuY3Rpb24pe1xuXHRcdFx0XHQvLyBJZiB0eXBlIGlzIGEgY29uc3RydWN0b3IsIGNoZWNrIGFnYWluc3QgdGhhdFxuXHRcdFx0XHRpZighKG9wdGlvbnNbcHJvcF0gaW5zdGFuY2VvZiB0eXBlKSl7XG5cdFx0XHRcdFx0dGhyb3cgYCR7b2JqZWN0TmFtZX0gb2JqZWN0IHJlcXVpcmVzIGFyZ3VtZW50ICR7cHJvcH0gb2YgdHlwZSAke3R5cGVOYW1lfSwgYnV0IHByb3ZpZGVkICR7cHJvcH0gd2FzIG5vdCBvZiB0eXBlICR7dHlwZU5hbWV9LmA7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IGAke29iamVjdE5hbWV9IG9iamVjdCByZXF1aXJlcyBhcmd1bWVudCAke3Byb3B9IG9mIHR5cGUgJHt0eXBlTmFtZX0sIGJ1dCBwcm92aWRlZCAke3Byb3B9IHdhcyBub3Qgb2YgdHlwZSAke3R5cGVOYW1lfS5gO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcbmltcG9ydCBDYW52YXNOb2RlRmFjdG9yeSBmcm9tIFwiLi9DYW52YXNOb2RlRmFjdG9yeVwiO1xuaW1wb3J0IFRpbGVtYXBGYWN0b3J5IGZyb20gXCIuL1RpbGVtYXBGYWN0b3J5XCI7XG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcFwiO1xuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRcIjtcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XG5pbXBvcnQgeyBHcmFwaGljVHlwZSB9IGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXNcIjtcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljXCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IExheWVyIGZyb20gXCIuLi9MYXllclwiO1xuXG4vKipcbiAqIFRoZSBtYW5hZ2VyIG9mIGFsbCBmYWN0b3JpZXMgdXNlZCBmb3IgYWRkaW5nIEByZWZlcmVuY2VbR2FtZU5vZGVdcyB0byB0aGUgQHJlZmVyZW5jZVtTY2VuZV0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhY3RvcnlNYW5hZ2VyIHtcblxuICAgIC8vIENvbnN0cnVjdG9ycyBhcmUgY2FsbGVkIGhlcmUgdG8gYWxsb3cgYXNzaWdubWVudCBvZiB0aGVpciBmdW5jdGlvbnMgdG8gZnVuY3Rpb25zIGluIHRoaXMgY2xhc3NcbiAgICBwcml2YXRlIGNhbnZhc05vZGVGYWN0b3J5OiBDYW52YXNOb2RlRmFjdG9yeSA9IG5ldyBDYW52YXNOb2RlRmFjdG9yeSgpO1xuICAgIHByaXZhdGUgdGlsZW1hcEZhY3Rvcnk6IFRpbGVtYXBGYWN0b3J5ID0gbmV3IFRpbGVtYXBGYWN0b3J5KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPil7XG4gICAgICAgIHRoaXMuY2FudmFzTm9kZUZhY3RvcnkuaW5pdChzY2VuZSk7XG4gICAgICAgIHRoaXMudGlsZW1hcEZhY3RvcnkuaW5pdChzY2VuZSwgdGlsZW1hcHMpO1xuICAgIH1cblxuICAgIC8vIEV4cG9zZSBhbGwgb2YgdGhlIGZhY3RvcmllcyB0aHJvdWdoIHRoZSBmYWN0b3J5IG1hbmFnZXJcbiAgICAvKipcblx0ICogQWRkcyBhbiBpbnN0YW5jZSBvZiBhIFVJRWxlbWVudCB0byB0aGUgY3VycmVudCBzY2VuZSAtIGkuZS4gYW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBVSUVsZW1lbnRcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgVUlFbGVtZW50IHRvIGFkZFxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciB0byBhZGQgdGhlIFVJRWxlbWVudCB0b1xuXHQgKiBAcGFyYW0gb3B0aW9ucyBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gZmVlZCB0byB0aGUgY29uc3RydWN0b3Jcblx0ICogQHJldHVybnMgQSBuZXcgVUlFbGVtZW50XG5cdCAqL1xuICAgIHVpRWxlbWVudCh0eXBlOiBzdHJpbmcgfCBVSUVsZW1lbnRUeXBlLCBsYXllck5hbWU6IHN0cmluZywgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBVSUVsZW1lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRVSUVsZW1lbnQodHlwZSwgbGF5ZXJOYW1lLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcblx0ICogQWRkcyBhIHNwcml0ZSB0byB0aGUgY3VycmVudCBzY2VuZVxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRoZSBzcHJpdGUgd2lsbCByZXByZXNlbnRcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBzcHJpdGVcblx0ICogQHJldHVybnMgQSBuZXcgU3ByaXRlXG5cdCAqL1xuXHRzcHJpdGUoa2V5OiBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nKTogU3ByaXRlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTm9kZUZhY3RvcnkuYWRkU3ByaXRlKGtleSwgbGF5ZXJOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcblx0ICogQWRkcyBhbiBBbmltYXRlZFNwcml0ZSB0byB0aGUgY3VycmVudCBzY2VuZVxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRoZSBzcHJpdGUgd2lsbCByZXByZXNlbnRcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBzcHJpdGVcblx0ICogQHJldHVybnMgQSBuZXcgQW5pbWF0ZWRTcHJpdGVcblx0ICovXG5cdGFuaW1hdGVkU3ByaXRlKGtleTogc3RyaW5nLCBsYXllck5hbWU6IHN0cmluZyk6IEFuaW1hdGVkU3ByaXRlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTm9kZUZhY3RvcnkuYWRkQW5pbWF0ZWRTcHJpdGUoa2V5LCBsYXllck5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBBZGRzIGEgbmV3IGdyYXBoaWMgZWxlbWVudCB0byB0aGUgY3VycmVudCBTY2VuZVxuXHQgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBncmFwaGljIHRvIGFkZFxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIGdyYXBoaWNcblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIGdyYXBoaWMgY29uc3RydWN0b3Jcblx0ICogQHJldHVybnMgQSBuZXcgR3JhcGhpY1xuXHQgKi9cblx0Z3JhcGhpYyh0eXBlOiBHcmFwaGljVHlwZSB8IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogR3JhcGhpYyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmFkZEdyYXBoaWModHlwZSwgbGF5ZXJOYW1lLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdGlsZW1hcCB0byB0aGUgc2NlbmVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCB0aWxlbWFwIHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGVzaXJlZCB0aWxlbWFwXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc2VuZCB0byB0aGUgdGlsZW1hcCBjb25zdHJ1Y3RvclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIExheWVycywgZWFjaCBvZiB3aGljaCBjb250YWlucyBhIGxheWVyIG9mIHRoZSB0aWxlbWFwIGFzIGl0cyBvd24gVGlsZW1hcCBpbnN0YW5jZS5cbiAgICAgKi9cblx0dGlsZW1hcChrZXk6IHN0cmluZywgc2NhbGU/OiBWZWMyKTogQXJyYXk8TGF5ZXI+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZW1hcEZhY3RvcnkuYWRkKGtleSwgc2NhbGUpO1xuICAgIH1cbn0iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lXCI7XG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcFwiO1xuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi8uLi9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xuaW1wb3J0IExheWVyIGZyb20gXCIuLi9MYXllclwiO1xuaW1wb3J0IFRpbGVzZXQgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlc2V0XCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCB7IFRpbGVkQ29sbGVjdGlvblRpbGUgfSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiO1xuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcbmltcG9ydCBQb3NpdGlvbkdyYXBoIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvR3JhcGhzL1Bvc2l0aW9uR3JhcGhcIjtcbmltcG9ydCBOYXZtZXNoIGZyb20gXCIuLi8uLi9QYXRoZmluZGluZy9OYXZtZXNoXCI7XG5cbi8vIEBpZ25vcmVQYWdlXG5cbi8qKlxuICogQSBmYWN0b3J5IHRoYXQgYWJzdHJhY3RzIGFkZGluZyBAcmVmZXJlbmNlW1RpbGVtYXBdcyB0byB0aGUgQHJlZmVyZW5jZVtTY2VuZV0uXG4gKiBBY2Nlc3MgbWV0aG9kcyBpbiB0aGlzIGZhY3RvcnkgdGhyb3VnaCBTY2VuZS5hZGQuW21ldGhvZE5hbWVdKCkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVtYXBGYWN0b3J5IHtcbiAgICBwcml2YXRlIHNjZW5lOiBTY2VuZTtcbiAgICBwcml2YXRlIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPjtcbiAgICBwcml2YXRlIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xuICAgIFxuICAgIGluaXQoc2NlbmU6IFNjZW5lLCB0aWxlbWFwczogQXJyYXk8VGlsZW1hcD4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLnRpbGVtYXBzID0gdGlsZW1hcHM7XG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyAtIFRoaXMgaXMgc3BlY2lmaWNhbGx5IGNhdGVyZWQgdG8gVGlsZWQgdGlsZW1hcHMgcmlnaHQgbm93LiBJbiB0aGUgZnV0dXJlLFxuICAgIC8vIGl0IHdvdWxkIGJlIGdvb2QgdG8gaGF2ZSBhIFwicGFyc2VUaWxlbWFwXCIgZnVuY3Rpb24gdGhhdCB3b3VsZCBjb252ZXJ0IHRoZSB0aWxlbWFwXG4gICAgLy8gZGF0YSBpbnRvIGEgc3RhbmRhcmQgZm9ybWF0LiBUaGlzIGNvdWxkIGFsbG93IGZvciBzdXBwb3J0IGZyb20gb3RoZXIgcHJvZ3JhbXNcbiAgICAvLyBvciB0aGUgZGV2ZWxvcG1lbnQgb2YgYW4gaW50ZXJuYWwgbGV2ZWwgYnVpbGRlciB0b29sXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRpbGVtYXAgdG8gdGhlIHNjZW5lXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBsb2FkZWQgdGlsZW1hcCB0byBsb2FkXG4gICAgICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRlc2lyZWQgdGlsZW1hcFxuICAgICAqIEBwYXJhbSBhcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIHRpbGVtYXAgY29uc3RydWN0b3JcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBMYXllcnMsIGVhY2ggb2Ygd2hpY2ggY29udGFpbnMgYSBsYXllciBvZiB0aGUgdGlsZW1hcCBhcyBpdHMgb3duIFRpbGVtYXAgaW5zdGFuY2UuXG4gICAgICovXG5cdGFkZCA9IChrZXk6IHN0cmluZywgc2NhbGU6IFZlYzIgPSBuZXcgVmVjMigxLCAxKSk6IEFycmF5PExheWVyPiA9PiB7XG4gICAgICAgIC8vIEdldCBUaWxlbWFwIERhdGFcbiAgICAgICAgbGV0IHRpbGVtYXBEYXRhID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0VGlsZW1hcChrZXkpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aWxlbWFwRGF0YSk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhpcyB0aWxlbWFwIHRvIGVpdGhlciBiZSBvcnRob2dyYXBoaWMgb3IgaXNvbWV0cmljXG4gICAgICAgIGxldCBjb25zdHI6IG5ldyguLi5hcmdzOiBhbnkpID0+IFRpbGVtYXA7XG4gICAgICAgIGlmKHRpbGVtYXBEYXRhLm9yaWVudGF0aW9uID09PSBcIm9ydGhvZ3JhcGhpY1wiKXtcbiAgICAgICAgICAgIGNvbnN0ciA9IE9ydGhvZ29uYWxUaWxlbWFwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gaXNvbWV0cmljIHRpbGVtYXAgc3VwcG9ydCByaWdodCBub3csIHNvIE9ydGhvZ3JhcGhpYyB0aWxlbWFwXG4gICAgICAgICAgICBjb25zdHIgPSBPcnRob2dvbmFsVGlsZW1hcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHJldHVybiB2YWx1ZSBhcnJheVxuICAgICAgICBsZXQgc2NlbmVMYXllcnMgPSBuZXcgQXJyYXk8TGF5ZXI+KCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFsbCBvZiB0aGUgdGlsZXNldHMgZm9yIHRoaXMgdGlsZW1hcFxuICAgICAgICBsZXQgdGlsZXNldHMgPSBuZXcgQXJyYXk8VGlsZXNldD4oKTtcblxuICAgICAgICBsZXQgY29sbGVjdGlvblRpbGVzID0gbmV3IEFycmF5PFRpbGVkQ29sbGVjdGlvblRpbGU+KCk7XG5cbiAgICAgICAgZm9yKGxldCB0aWxlc2V0IG9mIHRpbGVtYXBEYXRhLnRpbGVzZXRzKXtcbiAgICAgICAgICAgIGlmKHRpbGVzZXQuaW1hZ2Upe1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBzdGFuZGFyZCB0aWxlc2V0IGFuZCBub3QgYSBjb2xsZWN0aW9uLCBjcmVhdGUgYSB0aWxlc2V0IGZvciBpdC5cbiAgICAgICAgICAgICAgICAvLyBUT0RPIC0gV2UgYXJlIGlnbm9yaW5nIGNvbGxlY3Rpb24gdGlsZXNldHMgZm9yIG5vdy4gVGhpcyBpcyBsaWtlbHkgbm90IGEgZ3JlYXQgaWRlYSBpbiBwcmFjdGljZSxcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGVvcmV0aWNhbGx5IHNvbWVvbmUgY291bGQgd2FudCB0byB1c2Ugb25lIGZvciBhIHN0YW5kYXJkIHRpbGVtYXAuIFdlIGFyZSBhc3N1bWluZyBmb3Igbm93XG4gICAgICAgICAgICAgICAgLy8gdGhhdCB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoZW0gZm9yIG9iamVjdCBsYXllcnNcbiAgICAgICAgICAgICAgICB0aWxlc2V0cy5wdXNoKG5ldyBUaWxlc2V0KHRpbGVzZXQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGlsZXNldC50aWxlcy5mb3JFYWNoKHRpbGUgPT4gdGlsZS5pZCArPSB0aWxlc2V0LmZpcnN0Z2lkKTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uVGlsZXMucHVzaCguLi50aWxlc2V0LnRpbGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvb3Agb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSB0aWxlbWFwIGFuZCBjcmVhdGUgdGlsZWRsYXllcnMgb3Igb2JqZWN0IGxheWVyc1xuICAgICAgICBmb3IobGV0IGxheWVyIG9mIHRpbGVtYXBEYXRhLmxheWVycyl7XG5cbiAgICAgICAgICAgIGxldCBzY2VuZUxheWVyO1xuICAgICAgICAgICAgbGV0IGlzUGFyYWxsYXhMYXllciA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGRlcHRoID0gMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYobGF5ZXIucHJvcGVydGllcyl7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBwcm9wIG9mIGxheWVyLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgICAgICBpZihwcm9wLm5hbWUgPT09IFwiUGFyYWxsYXhcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1BhcmFsbGF4TGF5ZXIgPSBwcm9wLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIkRlcHRoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoaXNQYXJhbGxheExheWVyKXtcbiAgICAgICAgICAgICAgICBzY2VuZUxheWVyID0gdGhpcy5zY2VuZS5hZGRQYXJhbGxheExheWVyKGxheWVyLm5hbWUsIG5ldyBWZWMyKDEsIDEpLCBkZXB0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjZW5lTGF5ZXIgPSB0aGlzLnNjZW5lLmFkZExheWVyKGxheWVyLm5hbWUsIGRlcHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYobGF5ZXIudHlwZSA9PT0gXCJ0aWxlbGF5ZXJcIil7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHRpbGVtYXAgb2JqZWN0IGZvciB0aGUgbGF5ZXJcbiAgICAgICAgICAgICAgICBsZXQgdGlsZW1hcCA9IG5ldyBjb25zdHIodGlsZW1hcERhdGEsIGxheWVyLCB0aWxlc2V0cywgc2NhbGUpO1xuICAgICAgICAgICAgICAgIHRpbGVtYXAuaWQgPSB0aGlzLnNjZW5lLmdlbmVyYXRlSWQoKTtcbiAgICAgICAgICAgICAgICB0aWxlbWFwLnNldFNjZW5lKHRoaXMuc2NlbmUpO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aWxlbWFwIHRvIHNjZW5lXG4gICAgICAgICAgICAgICAgdGhpcy50aWxlbWFwcy5wdXNoKHRpbGVtYXApO1xuICAgIFxuICAgICAgICAgICAgICAgIHNjZW5lTGF5ZXIuYWRkTm9kZSh0aWxlbWFwKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBSZWdpc3RlciB0aWxlbWFwIHdpdGggcGh5c2ljcyBpZiBpdCdzIGNvbGxpZGFibGVcbiAgICAgICAgICAgICAgICBpZih0aWxlbWFwLmlzQ29sbGlkYWJsZSl7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVtYXAuYWRkUGh5c2ljcygpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKGxheWVyLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpdGVtIG9mIGxheWVyLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0ubmFtZSA9PT0gXCJHcm91cFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZW1hcC5zZXRHcm91cChpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgbGV0IGlzTmF2bWVzaFBvaW50cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBuYXZtZXNoTmFtZTtcbiAgICAgICAgICAgICAgICBsZXQgZWRnZXM7XG4gICAgICAgICAgICAgICAgaWYobGF5ZXIucHJvcGVydGllcyl7XG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgcHJvcCBvZiBsYXllci5wcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHByb3AubmFtZSA9PT0gXCJOYXZtZXNoUG9pbnRzXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTmF2bWVzaFBvaW50cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIm5hbWVcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2bWVzaE5hbWUgPSBwcm9wLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJlZGdlc1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlcyA9IHByb3AudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihpc05hdm1lc2hQb2ludHMpe1xuICAgICAgICAgICAgICAgICAgICBsZXQgZyA9IG5ldyBQb3NpdGlvbkdyYXBoKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBvYmogb2YgbGF5ZXIub2JqZWN0cyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBnLmFkZFBvc2l0aW9uZWROb2RlKG5ldyBWZWMyKG9iai54LCBvYmoueSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBlZGdlIG9mIGVkZ2VzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGcuYWRkRWRnZShlZGdlLmZyb20sIGVkZ2UudG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5nZXROYXZpZ2F0aW9uTWFuYWdlcigpLmFkZE5hdmlnYWJsZUVudGl0eShuYXZtZXNoTmFtZSwgbmV3IE5hdm1lc2goZykpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExheWVyIGlzIGFuIG9iamVjdCBsYXllciwgc28gYWRkIGVhY2ggb2JqZWN0IGFzIGEgc3ByaXRlIHRvIGEgbmV3IGxheWVyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBvYmogb2YgbGF5ZXIub2JqZWN0cyl7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG9iaiBpcyBjb2xsaWRhYmxlXG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNQaHlzaWNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc0NvbGxpZGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzVHJpZ2dlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25FbnRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbkV4aXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHJpZ2dlckdyb3VwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gXCJcIjtcblxuICAgICAgICAgICAgICAgICAgICBpZihvYmoucHJvcGVydGllcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHByb3Agb2Ygb2JqLnByb3BlcnRpZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHByb3AubmFtZSA9PT0gXCJIYXNQaHlzaWNzXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNQaHlzaWNzID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIkNvbGxpZGFibGVcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29sbGlkYWJsZSA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJHcm91cFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAgPSBwcm9wLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiSXNUcmlnZ2VyXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1RyaWdnZXIgPSBwcm9wLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiVHJpZ2dlckdyb3VwXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyR3JvdXAgPSBwcm9wLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiVHJpZ2dlck9uRW50ZXJcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRW50ZXIgPSBwcm9wLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiVHJpZ2dlck9uRXhpdFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FeGl0ID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgc3ByaXRlOiBTcHJpdGU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgb2JqIGlzIGEgdGlsZSBmcm9tIGEgdGlsZXNldFxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHRpbGVzZXQgb2YgdGlsZXNldHMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGlsZXNldC5oYXNUaWxlKG9iai5naWQpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb2JqZWN0IGlzIGEgdGlsZSBmcm9tIHRoaXMgc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlS2V5ID0gdGlsZXNldC5nZXRJbWFnZUtleSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSB0aWxlc2V0LmdldEltYWdlT2Zmc2V0Rm9yVGlsZShvYmouZ2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUgPSB0aGlzLnNjZW5lLmFkZC5zcHJpdGUoaW1hZ2VLZXksIGxheWVyLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gdGlsZXNldC5nZXRUaWxlU2l6ZSgpLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnNldCgob2JqLnggKyBzaXplLngvMikqc2NhbGUueCwgKG9iai55IC0gc2l6ZS55LzIpKnNjYWxlLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zZXRJbWFnZU9mZnNldChvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zaXplLmNvcHkoc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNjYWxlLnNldChzY2FsZS54LCBzY2FsZS55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBpbiBhIHRpbGVzZXQsIG11c3QgY29ycmVzcG9uZCB0byBhIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaWYoIXNwcml0ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHRpbGUgb2YgY29sbGVjdGlvblRpbGVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihvYmouZ2lkID09PSB0aWxlLmlkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlS2V5ID0gdGlsZS5pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlID0gdGhpcy5zY2VuZS5hZGQuc3ByaXRlKGltYWdlS2V5LCBsYXllci5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnNldCgob2JqLnggKyB0aWxlLmltYWdld2lkdGgvMikqc2NhbGUueCwgKG9iai55IC0gdGlsZS5pbWFnZWhlaWdodC8yKSpzY2FsZS55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNjYWxlLnNldChzY2FsZS54LCBzY2FsZS55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3cgd2UgaGF2ZSBzcHJpdGUuIEFzc29jaWF0ZSBpdCB3aXRoIG91ciBwaHlzaWNzIG9iamVjdCBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgaWYoaGFzUGh5c2ljcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSBzcHJpdGUgYSBzdGF0aWMgcGh5c2ljcyBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5hZGRQaHlzaWNzKHNwcml0ZS5ib3VuZGFyeS5jbG9uZSgpLCBWZWMyLlpFUk8sIGlzQ29sbGlkYWJsZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2V0R3JvdXAoZ3JvdXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNUcmlnZ2VyICYmIHRyaWdnZXJHcm91cCAhPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNldFRyaWdnZXIodHJpZ2dlckdyb3VwLCBvbkVudGVyLCBvbkV4aXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgc2NlbmVMYXllcnMucHVzaChzY2VuZUxheWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY2VuZUxheWVycztcblx0fVxufSIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi9TY2VuZVwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vVXRpbHMvTWF0aFV0aWxzXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XG5cblxuLyoqXG4gKiBBIGxheWVyIGluIHRoZSBzY2VuZS4gTGF5ZXJzIGFyZSB1c2VkIGZvciBzb3J0aW5nIEByZWZlcmVuY2VbR2FtZU5vZGVdcyBieSBkZXB0aC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXIge1xuICAgIC8qKiBUaGUgc2NlbmUgdGhpcyBsYXllciBiZWxvbmdzIHRvICovXG4gICAgcHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcblxuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGlzIGxheWVyICovXG4gICAgcHJvdGVjdGVkIG5hbWU6IHN0cmluZztcblxuICAgIC8qKiBXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgcGF1c2VkIG9yIG5vdCAqL1xuICAgIHByb3RlY3RlZCBwYXVzZWQ6IGJvb2xlYW47XG5cbiAgICAvKiogV2hldGhlciB0aGlzIGxheWVyIGlzIGhpZGRlbiBmcm9tIGJlaW5nIHJlbmRlcmVkIG9yIG5vdCAqL1xuICAgIHByb3RlY3RlZCBoaWRkZW46IGJvb2xlYW47XG5cbiAgICAvKiogVGhlIGdsb2JhbCBhbHBoYSBsZXZlbCBvZiB0aGlzIGxheWVyICovXG4gICAgcHJvdGVjdGVkIGFscGhhOiBudW1iZXI7XG5cbiAgICAvKiogQW4gYXJyYXkgb2YgdGhlIEdhbWVOb2RlcyB0aGF0IGJlbG9uZyB0byB0aGlzIGxheWVyICovXG4gICAgcHJvdGVjdGVkIGl0ZW1zOiBBcnJheTxHYW1lTm9kZT47XG5cbiAgICAvKiogV2hldGhlciBvciBub3QgdGhpcyBsYXllciBzaG91bGQgYmUgeXNvcnRlZCAqL1xuICAgIHByb3RlY3RlZCB5U29ydDogYm9vbGVhbjtcblxuICAgIC8qKiBUaGUgZGVwdGggb2YgdGhpcyBsYXllciBjb21wYXJlZCB0byBvdGhlciBsYXllcnMgKi9cbiAgICBwcm90ZWN0ZWQgZGVwdGg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgbGF5ZXIuIFRvIGRvIHRoaXMgaW4gYSBnYW1lLCB1c2UgdGhlIGFkZExheWVyKCkgbWV0aG9kIGluIEByZWZyZW5jZVtTY2VuZV1cbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIHNjZW5lIHRvIGFkZCB0aGUgbGF5ZXIgdG9cbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIG5hbWU6IHN0cmluZyl7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbHBoYSA9IDE7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy55U29ydCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyZWl2ZXMgdGhlIG5hbWUgb2YgdGhlIGxheWVyXG4gICAgICogQHJldHVybnMgVGhlIG5hbWUgb2YgdGhlIGxheWVyXG4gICAgICovXG4gICAgZ2V0TmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdXNlcy9VbnBhdXNlcyB0aGUgbGF5ZXIuIEFmZmVjdHMgYWxsIGVsZW1lbnRzIGluIHRoaXMgbGF5ZXJcbiAgICAgKiBAcGFyYW0gcGF1c2VWYWx1ZSBUcnVlIGlmIHRoZSBsYXllciBzaG91bGQgYmUgcGF1c2VkLCBmYWxzZSBpZiBub3RcbiAgICAgKi9cbiAgICBzZXRQYXVzZWQocGF1c2VWYWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IHBhdXNlVmFsdWU7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGxheWVyIGlzIHBhdXNlZFxuICAgICAqL1xuICAgIGlzUGF1c2VkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXVzZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAcGFyYW0gYWxwaGEgVGhlIG5ldyBvcGFjaXR5IHZhbHVlIGluIHRoZSByYW5nZSBbMCwgMV1cbiAgICAgKi9cbiAgICBzZXRBbHBoYShhbHBoYTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYWxwaGEgPSBNYXRoVXRpbHMuY2xhbXAoYWxwaGEsIDAsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyXG4gICAgICogQHJldHVybnMgVGhlIG9wYWNpdHlcbiAgICAgKi9cbiAgICBnZXRBbHBoYSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5hbHBoYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsYXllcidzIGhpZGRlbiB2YWx1ZS4gSWYgaGlkZGVuLCBhIGxheWVyIHdpbGwgbm90IGJlIHJlbmRlcmVkLCBidXQgd2lsbCBzdGlsbCB1cGRhdGVcbiAgICAgKiBAcGFyYW0gaGlkZGVuIFRoZSBoaWRkZW4gdmFsdWUgb2YgdGhlIGxheWVyXG4gICAgICovXG4gICAgc2V0SGlkZGVuKGhpZGRlbjogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmhpZGRlbiA9IGhpZGRlbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoaWRlZW4gdmFsdWUgb2YgdGhlIGx5YWVyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc2NlbmUgaXMgaGlkZGVuLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBpc0hpZGRlbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlkZGVuO1xuICAgIH1cblxuICAgIC8qKiBQYXVzZXMgdGhpcyBzY2VuZSBhbmQgaGlkZXMgaXQgKi9cbiAgICBkaXNhYmxlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiogVW5wYXVzZXMgdGhpcyBsYXllciBhbmQgbWFrZXMgaXQgdmlzaWJsZSAqL1xuICAgIGVuYWJsZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBzY2VuZSB3aWxsIHlTb3J0IGF1dG9tYXRpY2FsbHkuXG4gICAgICogeVNvcnRpbmcgbWVhbnMgdGhhdCBDYW52YXNOb2RlcyBvbiB0aGlzIGxheWVyIHdpbGwgaGF2ZSB0aGVpciBkZXB0aCBzb3J0ZWQgZGVwZW5kaW5nIG9uIHRoZWlyIHktdmFsdWUuXG4gICAgICogVGhpcyBtZWFucyB0aGF0IGlmIGFuIG9iamVjdCBpcyBcImhpZ2hlclwiIGluIHRoZSBzY2VuZSwgaXQgd2lsbCBzb3J0IGJlaGluZCBvYmplY3RzIHRoYXQgYXJlIFwibG93ZXJcIi5cbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgMy80IHZpZXcgZ2FtZXMsIG9yIHNpbWlsYXIgc2l0dWF0aW9ucywgd2hlcmUgeW91IHNvbWV0aW1lcyB3YW50IHRvIGJlIGluIGZyb250IG9mIG9iamVjdHMsXG4gICAgICogYW5kIG90aGVyIHRpbWVzIHdhbnQgdG8gYmUgYmVoaW5kIHRoZSBzYW1lIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHlTb3J0IFRydWUgaWYgeVNvcnRpbmcgc2hvdWxkIGJlIGFjdGl2ZSwgZmFsc2UgaWYgbm90XG4gICAgICovXG4gICAgc2V0WVNvcnQoeVNvcnQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy55U29ydCA9IHlTb3J0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHlTb3J0IHN0YXR1cyBvZiB0aGUgc2NlbmVcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHlTb3J0aW5nIGlzIG9jY3VycmluZywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgZ2V0WVNvcnQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnlTb3J0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRlcHRoIG9mIHRoZSBsYXllciBjb21wYXJlZCB0byBvdGhlciBsYXllcnMuIEEgbGFyZ2VyIG51bWJlciBtZWFucyB0aGUgbGF5ZXIgd2lsbCBiZSBjbG9zZXIgdG8gdGhlIHNjcmVlbi5cbiAgICAgKiBAcGFyYW0gZGVwdGggVGhlIGRlcHRoIG9mIHRoZSBsYXllci5cbiAgICAgKi9cbiAgICBzZXREZXB0aChkZXB0aDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGRlcHRoIG9mIHRoZSBsYXllci5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGVwdGhcbiAgICAgKi9cbiAgICBnZXREZXB0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXB0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbm9kZSB0byB0aGlzIGxheWVyXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gYWRkIHRvIHRoaXMgbGF5ZXIuXG4gICAgICovXG4gICAgYWRkTm9kZShub2RlOiBHYW1lTm9kZSk6IHZvaWQge1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2gobm9kZSk7XG4gICAgICAgIG5vZGUuc2V0TGF5ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGlzIGxheWVyXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSB3YXMgcmVtb3ZlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgcmVtb3ZlTm9kZShub2RlOiBHYW1lTm9kZSk6IHZvaWQge1xuICAgICAgICAvLyBGaW5kIGFuZCByZW1vdmUgdGhlIG5vZGVcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5pdGVtcy5pbmRleE9mKG5vZGUpO1xuXG4gICAgICAgIGlmKGluZGV4ICE9PSAtMSl7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBub2RlLnNldExheWVyKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyZWl2ZXMgYWxsIEdhbWVOb2RlcyBmcm9tIHRoaXMgbGF5ZXJcbiAgICAgKiBAcmV0dXJucyBhbiBBcnJheSB0aGF0IGNvbnRhaW5zIGFsbCBvZiB0aGUgR2FtZU5vZGVzIGluIHRoaXMgbGF5ZXIuXG4gICAgICovXG4gICAgZ2V0SXRlbXMoKTogQXJyYXk8R2FtZU5vZGU+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXM7XG4gICAgfVxufSIsImltcG9ydCBMYXllciBmcm9tIFwiLi4vTGF5ZXJcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZVwiO1xuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiBvZiBhIExheWVyIHRoYXQgaGFzIGEgcGFyYWxsYXggdmFsdWUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcmFsbGF4TGF5ZXIgZXh0ZW5kcyBMYXllciB7XG5cdC8qKiBUaGUgdmFsdWUgb2YgdGhlIHBhcmFsbGF4IG9mIHRoZSBMYXllciAqL1xuXHRwYXJhbGxheDogVmVjMjtcblx0XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IFBhcmFsbGF4TGF5ZXIuXG5cdCAqIFVzZSBhZGRQYXJhbGxheExheWVyKCkgaW4gQHJlZmVyZW5jZVtTY2VuZV0gdG8gYWRkIGEgbGF5ZXIgb2YgdGhpcyB0eXBlIHRvIHlvdXIgZ2FtZS5cblx0ICogQHBhcmFtIHNjZW5lIFRoZSBTY2VuZSB0byBhZGQgdGhpcyBQYXJhbGxheExheWVyIHRvXG5cdCAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBQYXJhbGxheExheWVyXG5cdCAqIEBwYXJhbSBwYXJhbGxheCBUaGUgcGFyYWxsYXggbGV2ZWxcblx0ICovXG5cdGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgbmFtZTogc3RyaW5nLCBwYXJhbGxheDogVmVjMil7XG5cdFx0c3VwZXIoc2NlbmUsIG5hbWUpO1xuXHRcdHRoaXMucGFyYWxsYXggPSBwYXJhbGxheDtcblx0fVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZVwiO1xuaW1wb3J0IFBhcmFsbGF4TGF5ZXIgZnJvbSBcIi4vUGFyYWxsYXhMYXllclwiO1xuXG4vKipcbiAqIEEgTGF5ZXIgc3RyaWN0bHkgdG8gYmUgdXNlZCBmb3IgbWFuYWdpbmcgVUlFbGVtZW50cy5cbiAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgYSBMYXllciB0aGF0IGFsd2F5cyBzdGF5cyBpbiB0aGUgc2FtZSBwbGFjZSxcbiAqIGFuZCB0aHVzIHJlbmRlcnMgdGhpbmdzIGxpa2UgYSBIVUQgb3IgYW4gaW52ZW50b3J5IHdpdGhvdXQgdGFraW5nIGludG8gY29uc2lkZXJhdGlvbiB0aGUgXFxyZWZlcmVuY2VbVmlld3BvcnRdIHNjcm9sbC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVUlMYXllciBleHRlbmRzIFBhcmFsbGF4TGF5ZXIge1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBVSUxheWVyLlxuXHQgKiBVc2UgYWRkVUlMYXllcigpIGluIEByZWZlcmVuY2VbU2NlbmVdIHRvIGFkZCBhIGxheWVyIG9mIHRoaXMgdHlwZSB0byB5b3VyIGdhbWUuXG5cdCAqIEBwYXJhbSBzY2VuZSBUaGUgU2NlbmUgdG8gYWRkIHRoaXMgVUlMYXllciB0b1xuXHQgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgVUlMYXllclxuXHQgKi9cblx0Y29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCBuYW1lOiBzdHJpbmcpe1xuXHRcdHN1cGVyKHNjZW5lLCBuYW1lLCBWZWMyLlpFUk8pO1xuXHR9XG59IiwiaW1wb3J0IExheWVyIGZyb20gXCIuL0xheWVyXCI7XG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4uL1NjZW5lR3JhcGgvVmlld3BvcnRcIjtcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IFNjZW5lR3JhcGggZnJvbSBcIi4uL1NjZW5lR3JhcGgvU2NlbmVHcmFwaFwiO1xuaW1wb3J0IFBoeXNpY3NNYW5hZ2VyIGZyb20gXCIuLi9QaHlzaWNzL1BoeXNpY3NNYW5hZ2VyXCI7XG5pbXBvcnQgQmFzaWNQaHlzaWNzTWFuYWdlciBmcm9tIFwiLi4vUGh5c2ljcy9CYXNpY1BoeXNpY3NNYW5hZ2VyXCI7XG5pbXBvcnQgU2NlbmVHcmFwaEFycmF5IGZyb20gXCIuLi9TY2VuZUdyYXBoL1NjZW5lR3JhcGhBcnJheVwiO1xuaW1wb3J0IEZhY3RvcnlNYW5hZ2VyIGZyb20gXCIuL0ZhY3Rvcmllcy9GYWN0b3J5TWFuYWdlclwiO1xuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCBHYW1lIGZyb20gXCIuLi9Mb29wL0dhbWVcIjtcbmltcG9ydCBTY2VuZU1hbmFnZXIgZnJvbSBcIi4vU2NlbmVNYW5hZ2VyXCI7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uL0V2ZW50cy9FbWl0dGVyXCI7XG5pbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xuaW1wb3J0IE5hdmlnYXRpb25NYW5hZ2VyIGZyb20gXCIuLi9QYXRoZmluZGluZy9OYXZpZ2F0aW9uTWFuYWdlclwiO1xuaW1wb3J0IEFJTWFuYWdlciBmcm9tIFwiLi4vQUkvQUlNYW5hZ2VyXCI7XG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XG5pbXBvcnQgUGFyYWxsYXhMYXllciBmcm9tIFwiLi9MYXllcnMvUGFyYWxsYXhMYXllclwiO1xuaW1wb3J0IFVJTGF5ZXIgZnJvbSBcIi4vTGF5ZXJzL1VJTGF5ZXJcIjtcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgU2NlbmVPcHRpb25zIGZyb20gXCIuL1NjZW5lT3B0aW9uc1wiO1xuaW1wb3J0IFJlbmRlcmluZ01hbmFnZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9SZW5kZXJpbmdNYW5hZ2VyXCI7XG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XG5pbXBvcnQgVGltZXJNYW5hZ2VyIGZyb20gXCIuLi9UaW1pbmcvVGltZXJNYW5hZ2VyXCI7XG5pbXBvcnQgVHdlZW5NYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvQW5pbWF0aW9ucy9Ud2Vlbk1hbmFnZXJcIjtcbmltcG9ydCBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9BbmltYXRpb25zL1BhcnRpY2xlU3lzdGVtTWFuYWdlclwiO1xuXG4vKipcbiAqIFNjZW5lcyBhcmUgdGhlIG1haW4gY29udGFpbmVyIGluIHRoZSBnYW1lIGVuZ2luZS5cbiAqIFlvdXIgbWFpbiBzY2VuZSBpcyB0aGUgY3VycmVudCBsZXZlbCBvciBtZW51IG9mIHRoZSBnYW1lLCBhbmQgd2lsbCBjb250YWluIGFsbCBvZiB0aGUgR2FtZU5vZGVzIG5lZWRlZC5cbiAqIFNjZW5lcyBwcm92aWRlIGFuIGVhc3kgd2F5IHRvIGxvYWQgYXNzZXRzLCBhZGQgYXNzZXRzIHRvIHRoZSBnYW1lIHdvcmxkLCBhbmQgdW5sb2FkIGFzc2V0cyxcbiAqIGFuZCBoYXZlIGxpZmVjeWNsZSBtZXRob2RzIGV4cG9zZWQgZm9yIHRoZXNlIGZ1bmN0aW9ucy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmUgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIGdhbWUgd29ybGQuICovXG4gICAgcHJvdGVjdGVkIHdvcmxkU2l6ZTogVmVjMjtcblxuICAgIC8qKiBUaGUgdmlld3BvcnQuICovXG4gICAgcHJvdGVjdGVkIHZpZXdwb3J0OiBWaWV3cG9ydDtcblxuICAgIC8qKiBBIGZsYWcgdGhhdCByZXByZXNlbnRzIHdoZXRoZXIgdGhpcyBzY2VuZSBpcyBydW5uaW5nIG9yIG5vdC4gKi9cbiAgICBwcm90ZWN0ZWQgcnVubmluZzogYm9vbGVhbjtcblxuICAgIC8qKiBUaGUgbWFuYWdlciBvZiB0aGlzIHNjZW5lLiAqL1xuICAgIHByb3RlY3RlZCBzY2VuZU1hbmFnZXI6IFNjZW5lTWFuYWdlcjtcblxuICAgIC8qKiBUaGUgcmVjZWl2ZXIgZm9yIHRoaXMgc2NlbmUuICovXG4gICAgcHJvdGVjdGVkIHJlY2VpdmVyOiBSZWNlaXZlcjtcblxuICAgIC8qKiBUaGUgZW1pdHRlciBmb3IgdGhpcyBzY2VuZS4gKi9cbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcblxuICAgIC8qKiBUaGlzIGxpc3Qgb2YgdGlsZW1hcHMgaW4gdGhpcyBzY2VuZS4gKi9cbiAgICBwcm90ZWN0ZWQgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+O1xuXG4gICAgLyoqIEEgbWFwIGZyb20gbGF5ZXIgbmFtZXMgdG8gdGhlIGxheWVycyB0aGVtc2VsdmVzICovXG4gICAgcHJvdGVjdGVkIGxheWVyczogTWFwPExheWVyPjtcblxuICAgIC8qKiBBIG1hcCBmcm9tIHBhcmFsbGF4IGxheWVyIG5hbWVzIHRvIHRoZSBwYXJhbGxheCBsYXllcnMgdGhlbXNlbHZlcyAqL1xuICAgIHByb3RlY3RlZCBwYXJhbGxheExheWVyczogTWFwPFBhcmFsbGF4TGF5ZXI+O1xuXG4gICAgLyoqIEEgbWFwIGZyb20gdWlMYXllciBuYW1lcyB0byB0aGUgdWlMYXllcnMgdGhlbXNlbHZlcyAqL1xuICAgIHByb3RlY3RlZCB1aUxheWVyczogTWFwPFVJTGF5ZXI+O1xuXG4gICAgLyoqIFRoZSBzY2VuZSBncmFwaCBvZiB0aGUgU2NlbmUqL1xuICAgIHByb3RlY3RlZCBzY2VuZUdyYXBoOiBTY2VuZUdyYXBoO1xuXG4gICAgLyoqIFRoZSBwaHlzaWNzIG1hbmFnZXIgb2YgdGhlIFNjZW5lICovXG4gICAgcHJvdGVjdGVkIHBoeXNpY3NNYW5hZ2VyOiBQaHlzaWNzTWFuYWdlcjtcbiAgICBcbiAgICAvKiogVGhlIG5hdmlnYXRpb24gbWFuYWdlciBvZiB0aGUgU2NlbmUgKi9cbiAgICBwcm90ZWN0ZWQgbmF2TWFuYWdlcjogTmF2aWdhdGlvbk1hbmFnZXI7XG5cbiAgICAvKiogVGhlIEFJIG1hbmFnZXIgb2YgdGhlIFNjZW5lICovXG4gICAgcHJvdGVjdGVkIGFpTWFuYWdlcjogQUlNYW5hZ2VyO1xuXG4gICAgLyoqIFRoZSByZW5kZXJpbmdNYW5hZ2VyIG9mIHRoZSBzY2VuZSAqL1xuICAgIHByb3RlY3RlZCByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyO1xuXG4gICAgLyoqIEFuIGludGVyZmFjZSB0aGF0IGFsbG93cyB0aGUgYWRkaW5nIG9mIGRpZmZlcmVudCBub2RlcyB0byB0aGUgc2NlbmUgKi9cbiAgICBwdWJsaWMgYWRkOiBGYWN0b3J5TWFuYWdlcjtcblxuICAgIC8qKiBBbiBpbnRlcmZhY2UgdGhhdCBhbGxvd3MgdGhlIGxvYWRpbmcgb2YgZGlmZmVyZW50IGZpbGVzIGZvciB1c2UgaW4gdGhlIHNjZW5lLiBBbiBhbGlhcyBmb3IgcmVzb3VyY2VNYW5hZ2VyICovXG4gICAgcHVibGljIGxvYWQ6IFJlc291cmNlTWFuYWdlcjtcblxuICAgIC8qKiBBbiBpbnRlcmZhY2UgdGhhdCBhbGxvd3MgdGhlIGxvYWRpbmcgYW5kIHVubG9hZGluZyBvZiBkaWZmZXJlbnQgZmlsZXMgZm9yIHVzZSBpbiB0aGUgc2NlbmUgKi9cbiAgICBwdWJsaWMgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XG5cbiAgICAvKiogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhpcyBzY2VuZSAqL1xuICAgIHB1YmxpYyBzY2VuZU9wdGlvbnM6IFNjZW5lT3B0aW9ucztcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2NlbmUuIFRvIGFkZCBhIG5ldyBTY2VuZSBpbiB5b3VyIGdhbWUsIHVzZSBjaGFuZ2VUb1NjZW5lKCkgaW4gQHJlZmVyZW5jZVtTY2VuZU1hbmFnZXJdXG4gICAgICogQHBhcmFtIHZpZXdwb3J0IFRoZSB2aWV3cG9ydCBvZiB0aGUgZ2FtZVxuICAgICAqIEBwYXJhbSBzY2VuZU1hbmFnZXIgVGhlIFNjZW5lTWFuYWdlciB0aGF0IG93bnMgdGhpcyBTY2VuZVxuICAgICAqIEBwYXJhbSByZW5kZXJpbmdNYW5hZ2VyIFRoZSBSZW5kZXJpbmdNYW5hZ2VyIHRoYXQgd2lsbCBoYW5kbGUgdGhpcyBTY2VuZSdzIHJlbmRlcmluZ1xuICAgICAqIEBwYXJhbSBnYW1lIFRoZSBpbnN0YW5jZSBvZiB0aGUgR2FtZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBTY2VuZSBpbml0aWFsaXphdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZpZXdwb3J0OiBWaWV3cG9ydCwgc2NlbmVNYW5hZ2VyOiBTY2VuZU1hbmFnZXIsIHJlbmRlcmluZ01hbmFnZXI6IFJlbmRlcmluZ01hbmFnZXIsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pe1xuICAgICAgICB0aGlzLnNjZW5lT3B0aW9ucyA9IFNjZW5lT3B0aW9ucy5wYXJzZShvcHRpb25zID09PSB1bmRlZmluZWQgPyB7fSA6IG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMud29ybGRTaXplID0gbmV3IFZlYzIoNTAwLCA1MDApO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIHRoaXMudmlld3BvcnQuc2V0Qm91bmRzKDAsIDAsIDI1NjAsIDEyODApO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIgPSBzY2VuZU1hbmFnZXI7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcblxuICAgICAgICB0aGlzLnRpbGVtYXBzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuc2NlbmVHcmFwaCA9IG5ldyBTY2VuZUdyYXBoQXJyYXkodGhpcy52aWV3cG9ydCwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5sYXllcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudWlMYXllcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGFyYWxsYXhMYXllcnMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5waHlzaWNzTWFuYWdlciA9IG5ldyBCYXNpY1BoeXNpY3NNYW5hZ2VyKHRoaXMuc2NlbmVPcHRpb25zLnBoeXNpY3MpO1xuICAgICAgICB0aGlzLm5hdk1hbmFnZXIgPSBuZXcgTmF2aWdhdGlvbk1hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5haU1hbmFnZXIgPSBuZXcgQUlNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlciA9IHJlbmRlcmluZ01hbmFnZXI7XG5cbiAgICAgICAgdGhpcy5hZGQgPSBuZXcgRmFjdG9yeU1hbmFnZXIodGhpcywgdGhpcy50aWxlbWFwcyk7XG5cbiAgICAgICAgdGhpcy5sb2FkID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKClcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSB0aGlzLmxvYWQ7XG5cbiAgICAgICAgLy8gR2V0IHRoZSB0aW1lciBtYW5hZ2VyIGFuZCBjbGVhciBhbnkgZXhpc3RpbmcgdGltZXJzXG4gICAgICAgIFRpbWVyTWFuYWdlci5nZXRJbnN0YW5jZSgpLmNsZWFyVGltZXJzKCk7XG4gICAgfVxuXG4gICAgLyoqIEEgbGlmZWN5Y2xlIG1ldGhvZCB0aGF0IGdldHMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIGEgbmV3IHNjZW5lIGlzIGNyZWF0ZWQsIGJlZm9yZSBhbnl0aGluZyBlbHNlLiAqL1xuICAgIGluaXRTY2VuZShpbml0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7fVxuXG4gICAgLyoqIEEgbGlmZWN5Y2xlIG1ldGhvZCB0aGF0IGdldHMgY2FsbGVkIHdoZW4gYSBuZXcgc2NlbmUgaXMgY3JlYXRlZC4gTG9hZCBhbGwgZmlsZXMgeW91IHdpc2ggdG8gYWNjZXNzIGluIHRoZSBzY2VuZSBoZXJlLiAqL1xuICAgIGxvYWRTY2VuZSgpOiB2b2lkIHt9XG5cbiAgICAvKiogQSBsaWZlY3ljbGUgbWV0aG9kIGNhbGxlZCBzdHJpY3RseSBhZnRlciBsb2FkU2NlbmUoKS4gQ3JlYXRlIGFueSBnYW1lIG9iamVjdHMgeW91IHdpc2ggdG8gdXNlIGluIHRoZSBzY2VuZSBoZXJlLiAqL1xuICAgIHN0YXJ0U2NlbmUoKTogdm9pZCB7fVxuXG4gICAgLyoqXG4gICAgICogQSBsaWZlY3ljbGUgbWV0aG9kIGNhbGxlZCBldmVyeSBmcmFtZSBvZiB0aGUgZ2FtZS4gVGhpcyBpcyB3aGVyZSB5b3UgY2FuIGR5bmFtaWNhbGx5IGRvIHRoaW5ncyBsaWtlIGFkZCBpbiBuZXcgZW5lbWllc1xuICAgICAqIEBwYXJhbSBkZWx0YSBUaGUgdGltZSB0aGlzIGZyYW1lIHJlcHJlc2VudHNcbiAgICAgKi9cbiAgICB1cGRhdGVTY2VuZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge31cblxuICAgIC8qKiBBIGxpZmVjeWNsZSBtZXRob2QgdGhhdCBnZXRzIGNhbGxlZCBvbiBzY2VuZSBkZXN0cnVjdGlvbi4gU3BlY2lmeSB3aGljaCBmaWxlcyB5b3Ugbm8gbG9uZ2VyIG5lZWQgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi4gKi9cbiAgICB1bmxvYWRTY2VuZSgpOiB2b2lkIHt9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy51cGRhdGVTY2VuZShkZWx0YVQpO1xuXG4gICAgICAgIC8vIERvIHRpbWUgdXBkYXRlc1xuICAgICAgICBUaW1lck1hbmFnZXIuZ2V0SW5zdGFuY2UoKS51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICAvLyBEbyBhbGwgQUkgdXBkYXRlc1xuICAgICAgICB0aGlzLmFpTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICAvLyBVcGRhdGUgYWxsIHBoeXNpY3Mgb2JqZWN0c1xuICAgICAgICB0aGlzLnBoeXNpY3NNYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgY2FudmFzIG9iamVjdHNcbiAgICAgICAgdGhpcy5zY2VuZUdyYXBoLnVwZGF0ZShkZWx0YVQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgdGlsZW1hcHNcbiAgICAgICAgdGhpcy50aWxlbWFwcy5mb3JFYWNoKHRpbGVtYXAgPT4ge1xuICAgICAgICAgICAgaWYoIXRpbGVtYXAuZ2V0TGF5ZXIoKS5pc1BhdXNlZCgpKXtcbiAgICAgICAgICAgICAgICB0aWxlbWFwLnVwZGF0ZShkZWx0YVQpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgYWxsIHR3ZWVuc1xuICAgICAgICBUd2Vlbk1hbmFnZXIuZ2V0SW5zdGFuY2UoKS51cGRhdGUoZGVsdGFUKTtcblxuICAgICAgICAvLyBVcGRhdGUgYWxsIHBhcnRpY2xlIHN5c3RlbXNcbiAgICAgICAgUGFydGljbGVTeXN0ZW1NYW5hZ2VyLmdldEluc3RhbmNlKCkudXBkYXRlKGRlbHRhVCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHZpZXdwb3J0XG4gICAgICAgIHRoaXMudmlld3BvcnQudXBkYXRlKGRlbHRhVCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdHMgcmVuZGVyYWJsZSBzZXRzIGFuZCBjb29yZGluYXRlcyB3aXRoIHRoZSBSZW5kZXJpbmdNYW5hZ2VyIHRvIGRyYXcgdGhlIFNjZW5lXG4gICAgICovXG4gICAgcmVuZGVyKCk6IHZvaWQge1xuICAgICAgICAvLyBHZXQgdGhlIHZpc2libGUgc2V0IG9mIG5vZGVzXG4gICAgICAgIGxldCB2aXNpYmxlU2V0ID0gdGhpcy5zY2VuZUdyYXBoLmdldFZpc2libGVTZXQoKTtcblxuICAgICAgICAvLyBBZGQgcGFyYWxsYXggbGF5ZXIgaXRlbXMgdG8gdGhlIHZpc2libGUgc2V0ICh3ZSdyZSByZW5kZXJpbmcgdGhlbSBhbGwgZm9yIG5vdylcbiAgICAgICAgdGhpcy5wYXJhbGxheExheWVycy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgcExheWVyID0gdGhpcy5wYXJhbGxheExheWVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGZvcihsZXQgbm9kZSBvZiBwTGF5ZXIuZ2V0SXRlbXMoKSl7XG4gICAgICAgICAgICAgICAgaWYobm9kZSBpbnN0YW5jZW9mIENhbnZhc05vZGUpe1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlU2V0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTZW5kIHRoZSB2aXNpYmxlIHNldCwgdGlsZW1hcHMsIGFuZCB1aUxheWVycyB0byB0aGUgcmVuZGVyZXJcbiAgICAgICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyLnJlbmRlcih2aXNpYmxlU2V0LCB0aGlzLnRpbGVtYXBzLCB0aGlzLnVpTGF5ZXJzKTtcblxuICAgICAgICBsZXQgbm9kZXMgPSB0aGlzLnNjZW5lR3JhcGguZ2V0QWxsTm9kZXMoKTtcbiAgICAgICAgdGhpcy50aWxlbWFwcy5mb3JFYWNoKHRpbGVtYXAgPT4gdGlsZW1hcC52aXNpYmxlID8gbm9kZXMucHVzaCh0aWxlbWFwKSA6IDApO1xuICAgICAgICBEZWJ1Zy5zZXROb2Rlcyhub2Rlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2NlbmUgYXMgcnVubmluZyBvciBub3RcbiAgICAgKiBAcGFyYW0gcnVubmluZyBUcnVlIGlmIHRoZSBTY2VuZSBzaG91bGQgYmUgcnVubmluZywgZmFsc2UgaWYgbm90XG4gICAgICovXG4gICAgc2V0UnVubmluZyhydW5uaW5nOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHJ1bm5pbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgU2NlbmUgaXMgcnVubmluZ1xuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHNjZW5lIGlzIHJ1bm5pbmcsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGlzUnVubmluZygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVubmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgbm9kZSBmcm9tIHRoaXMgU2NlbmVcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcbiAgICAgKi9cbiAgICByZW1vdmUobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gdGhlIHNjZW5lIGdyYXBoXG4gICAgICAgIGlmKG5vZGUgaW5zdGFuY2VvZiBDYW52YXNOb2RlKXtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVHcmFwaC5yZW1vdmVOb2RlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKiogRGVzdHJveXMgdGhpcyBzY2VuZSBhbmQgYWxsIG5vZGVzIGluIGl0ICovXG4gICAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMuc2NlbmVHcmFwaC5nZXRBbGxOb2RlcygpKXtcbiAgICAgICAgICAgIG5vZGUuZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGxldCB0aWxlbWFwIG9mIHRoaXMudGlsZW1hcHMpe1xuICAgICAgICAgICAgdGlsZW1hcC5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlY2VpdmVyLmRlc3Ryb3koKTtcblxuICAgICAgICBkZWxldGUgdGhpcy5zY2VuZUdyYXBoO1xuICAgICAgICBkZWxldGUgdGhpcy5waHlzaWNzTWFuYWdlcjtcbiAgICAgICAgZGVsZXRlIHRoaXMubmF2TWFuYWdlcjtcbiAgICAgICAgZGVsZXRlIHRoaXMuYWlNYW5hZ2VyO1xuICAgICAgICBkZWxldGUgdGhpcy5yZWNlaXZlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGxheWVyIHRvIHRoZSBzY2VuZSBhbmQgcmV0dXJucyBpdFxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBuZXcgbGF5ZXJcbiAgICAgKiBAcGFyYW0gZGVwdGggVGhlIGRlcHRoIG9mIHRoZSBsYXllclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIExheWVyXG4gICAgICovXG4gICAgYWRkTGF5ZXIobmFtZTogc3RyaW5nLCBkZXB0aD86IG51bWJlcik6IExheWVyIHtcbiAgICAgICAgaWYodGhpcy5sYXllcnMuaGFzKG5hbWUpIHx8IHRoaXMucGFyYWxsYXhMYXllcnMuaGFzKG5hbWUpIHx8IHRoaXMudWlMYXllcnMuaGFzKG5hbWUpKXtcbiAgICAgICAgICAgIHRocm93IGBMYXllciB3aXRoIG5hbWUgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2A7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGF5ZXIgPSBuZXcgTGF5ZXIodGhpcywgbmFtZSk7XG5cbiAgICAgICAgdGhpcy5sYXllcnMuYWRkKG5hbWUsIGxheWVyKTtcblxuICAgICAgICBpZihkZXB0aCl7XG4gICAgICAgICAgICBsYXllci5zZXREZXB0aChkZXB0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBwYXJhbGxheCBsYXllciB0byB0aGlzIHNjZW5lIGFuZCByZXR1cm5zIGl0XG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHBhcmFsbGF4IGxheWVyXG4gICAgICogQHBhcmFtIHBhcmFsbGF4IFRoZSBwYXJhbGxheCBsZXZlbFxuICAgICAqIEBwYXJhbSBkZXB0aCBUaGUgZGVwdGggb2YgdGhlIGxheWVyXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgUGFyYWxsYXhMYXllclxuICAgICAqL1xuICAgIGFkZFBhcmFsbGF4TGF5ZXIobmFtZTogc3RyaW5nLCBwYXJhbGxheDogVmVjMiwgZGVwdGg/OiBudW1iZXIpOiBQYXJhbGxheExheWVyIHtcbiAgICAgICAgaWYodGhpcy5sYXllcnMuaGFzKG5hbWUpIHx8IHRoaXMucGFyYWxsYXhMYXllcnMuaGFzKG5hbWUpIHx8IHRoaXMudWlMYXllcnMuaGFzKG5hbWUpKXtcbiAgICAgICAgICAgIHRocm93IGBMYXllciB3aXRoIG5hbWUgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2A7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGF5ZXIgPSBuZXcgUGFyYWxsYXhMYXllcih0aGlzLCBuYW1lLCBwYXJhbGxheCk7XG5cbiAgICAgICAgdGhpcy5wYXJhbGxheExheWVycy5hZGQobmFtZSwgbGF5ZXIpO1xuXG4gICAgICAgIGlmKGRlcHRoKXtcbiAgICAgICAgICAgIGxheWVyLnNldERlcHRoKGRlcHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IFVJTGF5ZXIgdG8gdGhlIHNjZW5lXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIG5ldyBVSWxheWVyXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgVUlMYXllclxuICAgICAqL1xuICAgIGFkZFVJTGF5ZXIobmFtZTogc3RyaW5nKTogVUlMYXllciB7XG4gICAgICAgIGlmKHRoaXMubGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKSl7XG4gICAgICAgICAgICB0aHJvdyBgTGF5ZXIgd2l0aCBuYW1lICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxheWVyID0gbmV3IFVJTGF5ZXIodGhpcywgbmFtZSk7XG5cbiAgICAgICAgdGhpcy51aUxheWVycy5hZGQobmFtZSwgbGF5ZXIpO1xuXG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGF5ZXIgZnJvbSB0aGUgc2NlbmUgYnkgbmFtZSBpZiBpdCBleGlzdHMuXG4gICAgICogVGhpcyBjYW4gYmUgYSBMYXllciBvciBhbnkgb2YgaXRzIHN1YmNsYXNzZXNcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAcmV0dXJucyBUaGUgTGF5ZXIgZm91bmQgd2l0aCB0aGF0IG5hbWVcbiAgICAgKi9cbiAgICBnZXRMYXllcihuYW1lOiBzdHJpbmcpOiBMYXllciB7XG4gICAgICAgIGlmKHRoaXMubGF5ZXJzLmhhcyhuYW1lKSl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXllcnMuZ2V0KG5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYodGhpcy5wYXJhbGxheExheWVycy5oYXMobmFtZSkpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyYWxsYXhMYXllcnMuZ2V0KG5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYodGhpcy51aUxheWVycy5oYXMobmFtZSkpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudWlMYXllcnMuZ2V0KG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgYFJlcXVlc3RlZCBsYXllciAke25hbWV9IGRvZXMgbm90IGV4aXN0LmA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBsYXllciBpcyBhIFBhcmFsbGF4TGF5ZXJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoaXMgbGF5ZXIgaXMgYSBQYXJhbGxheExheWVyXG4gICAgICovXG4gICAgaXNQYXJhbGxheExheWVyKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbGxheExheWVycy5oYXMobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbGF5ZXIgaXMgYSBVSUxheWVyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGlzIGxheWVyIGlzIFBhcmFsbGF4TGF5ZXJcbiAgICAgKi9cbiAgICBpc1VJTGF5ZXIobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKTtcbiAgICB9ICAgIFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gb2YgdGhpcyBub2RlIHdpdGggcmVzcGVjdCB0byBjYW1lcmEgc3BhY2UgKGR1ZSB0byB0aGUgdmlld3BvcnQgbW92aW5nKS5cbiAgICAgKiBUaGlzIHZhbHVlIGlzIGFmZmVjdGVkIGJ5IHRoZSBwYXJhbGxheCBsZXZlbCBvZiB0aGUgQHJlZmVyZW5jZVtMYXllcl0gdGhlIG5vZGUgaXMgb24uXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gY2hlY2sgdGhlIHZpZXdwb3J0IHdpdGggcmVzcGVjdCB0b1xuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSB0cmFuc2xhdGlvbiBvZiB2aWV3cG9ydCB3aXRoIHJlc3BlY3QgdG8gdGhpcyBub2RlLlxuICAgICAqL1xuICAgIGdldFZpZXdUcmFuc2xhdGlvbihub2RlOiBHYW1lTm9kZSk6IFZlYzIge1xuICAgICAgICBsZXQgbGF5ZXIgPSBub2RlLmdldExheWVyKCk7XG5cbiAgICAgICAgaWYobGF5ZXIgaW5zdGFuY2VvZiBQYXJhbGxheExheWVyIHx8IGxheWVyIGluc3RhbmNlb2YgVUlMYXllcil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydC5nZXRPcmlnaW4oKS5tdWx0KGxheWVyLnBhcmFsbGF4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0LmdldE9yaWdpbigpO1xuICAgICAgICB9XG5cdH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNjYWxlIGxldmVsIG9mIHRoZSB2aWV3XG4gICAgICogQHJldHVybnMgVGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXdwb3J0XG4gICAgKi9cblx0Z2V0Vmlld1NjYWxlKCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMudmlld3BvcnQuZ2V0Wm9vbUxldmVsKCk7XG5cdH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFZpZXdwb3J0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNjZW5lXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgVmlld3BvcnRcbiAgICAgKi9cbiAgICBnZXRWaWV3cG9ydCgpOiBWaWV3cG9ydCB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHdvcmxkIHNpemUgb2YgdGhpcyBTY2VuZVxuICAgICAqIEByZXR1cm5zIFRoZSB3b3JsZCBzaXplIGluIGEgVmVjMlxuICAgICAqL1xuICAgIGdldFdvcmxkU2l6ZSgpOiBWZWMyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud29ybGRTaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFNjZW5lR3JhcGggYXNzb2NpYXRlZCB3aXRoIHRoaXMgU2NlbmVcbiAgICAgKiBAcmV0dXJucyBUaGUgU2NlbmVHcmFwaFxuICAgICAqL1xuICAgIGdldFNjZW5lR3JhcGgoKTogU2NlbmVHcmFwaCB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjZW5lR3JhcGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgUGh5c2ljc01hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgU2NlbmVcbiAgICAgKiBAcmV0dXJucyBUaGUgUGh5c2ljc01hbmFnZXJcbiAgICAgKi9cbiAgICBnZXRQaHlzaWNzTWFuYWdlcigpOiBQaHlzaWNzTWFuYWdlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnBoeXNpY3NNYW5hZ2VyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIE5hdmlnYXRpb25NYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFNjZW5lXG4gICAgICogQHJldHVybnMgVGhlIE5hdmlnYXRpb25NYW5hZ2VyXG4gICAgICovXG4gICAgZ2V0TmF2aWdhdGlvbk1hbmFnZXIoKTogTmF2aWdhdGlvbk1hbmFnZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZNYW5hZ2VyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEFJTWFuYWdlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBTY2VuZVxuICAgICAqIEByZXR1cm5zIFRoZSBBSU1hbmFnZXJcbiAgICAgKi9cbiAgICBnZXRBSU1hbmFnZXIoKTogQUlNYW5hZ2VyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWlNYW5hZ2VyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBJRCBmb3IgYSBHYW1lTm9kZVxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgSURcbiAgICAgKi9cbiAgICBnZW5lcmF0ZUlkKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjZW5lTWFuYWdlci5nZW5lcmF0ZUlkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgVGlsZW1hcCBpbiB0aGlzIFNjZW5lXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFRpbGVtYXBcbiAgICAgKiBAcmV0dXJucyBUaGUgVGlsZW1hcCwgaWYgb25lIHRoaXMgbmFtZSBleGlzdHMsIG90aGVyd2lzZSBudWxsXG4gICAgICovXG4gICAgZ2V0VGlsZW1hcChuYW1lOiBzdHJpbmcpOiBUaWxlbWFwIHtcbiAgICAgICAgZm9yKGxldCB0aWxlbWFwIG9mIHRoaXMgLnRpbGVtYXBzKXtcbiAgICAgICAgICAgIGlmKHRpbGVtYXAubmFtZSA9PT0gbmFtZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbGVtYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59IiwiaW1wb3J0IFNjZW5lIGZyb20gXCIuL1NjZW5lXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4uL1NjZW5lR3JhcGgvVmlld3BvcnRcIjtcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlclwiO1xuaW1wb3J0IE1lbW9yeVV0aWxzIGZyb20gXCIuLi9VdGlscy9NZW1vcnlVdGlsc1wiO1xuXG4vKipcbiAqIFRoZSBTY2VuZU1hbmFnZXIgYWN0cyBhcyBhbiBpbnRlcmZhY2UgdG8gY3JlYXRlIFNjZW5lcywgYW5kIGhhbmRsZXMgdGhlIGxpZmVjeWNsZSBtZXRob2RzIG9mIFNjZW5lcy5cbiAqIEl0IGdpdmVzIFNjZW5lcyBhY2Nlc3MgdG8gaW5mb3JtYXRpb24gdGhleSBuZWVkIGZyb20gdGhlIEByZWZlcmVuY2VbR2FtZV0gY2xhc3Mgd2hpbGUga2VlcGluZyBhIGxheWVyIG9mIHNlcGFyYXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lTWFuYWdlciB7XG5cdC8qKiBUaGUgY3VycmVudCBTY2VuZSBvZiB0aGUgZ2FtZSAqL1xuXHRwcm90ZWN0ZWQgY3VycmVudFNjZW5lOiBTY2VuZTtcblxuXHQvKiogVGhlIFZpZXdwb3J0IG9mIHRoZSBnYW1lICovXG5cdHByb3RlY3RlZCB2aWV3cG9ydDogVmlld3BvcnQ7XG5cblx0LyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBSZXNvdXJjZU1hbmFnZXIgKi9cblx0cHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xuXG5cdC8qKiBBIGNvdW50ZXIgdG8ga2VlcCB0cmFjayBvZiBnYW1lIGlkcyAqL1xuXHRwcm90ZWN0ZWQgaWRDb3VudGVyOiBudW1iZXI7XG5cblx0LyoqIFRoZSBSZW5kZXJpbmdNYW5hZ2VyIG9mIHRoZSBnYW1lICovXG5cdHByb3RlY3RlZCByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyO1xuXG5cdC8qKiBGb3IgY29uc2lzdGVuY3ksIG9ubHkgY2hhbmdlIHNjZW5lcyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB1cGRhdGUgY3ljbGUgKi9cblx0cHJvdGVjdGVkIHBlbmRpbmdTY2VuZTogU2NlbmU7XG5cdHByb3RlY3RlZCBwZW5kaW5nU2NlbmVJbml0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IFNjZW5lTWFuYWdlclxuXHQgKiBAcGFyYW0gdmlld3BvcnQgVGhlIFZpZXdwb3J0IG9mIHRoZSBnYW1lXG5cdCAqIEBwYXJhbSBnYW1lIFRoZSBHYW1lIGluc3RhbmNlXG5cdCAqIEBwYXJhbSByZW5kZXJpbmdNYW5hZ2VyIFRoZSBSZW5kZXJpbmdNYW5hZ2VyIG9mIHRoZSBnYW1lXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih2aWV3cG9ydDogVmlld3BvcnQsIHJlbmRlcmluZ01hbmFnZXI6IFJlbmRlcmluZ01hbmFnZXIpe1xuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG5cdFx0dGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuXHRcdHRoaXMucmVuZGVyaW5nTWFuYWdlciA9IHJlbmRlcmluZ01hbmFnZXI7XG5cdFx0dGhpcy5pZENvdW50ZXIgPSAwO1xuXHRcdHRoaXMucGVuZGluZ1NjZW5lID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgYSBzY2VuZSBhcyB0aGUgbWFpbiBzY2VuZS5cblx0ICogVXNlIHRoaXMgbWV0aG9kIGlmIHlvdSd2ZSBjcmVhdGVkIGEgc3ViY2xhc3Mgb2YgU2NlbmUsIGFuZCB5b3Ugd2FudCB0byBhZGQgaXQgYXMgdGhlIG1haW4gU2NlbmUuXG5cdCAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBzY2VuZSB0byBhZGRcblx0ICogQHBhcmFtIGluaXQgQW4gb2JqZWN0IHRvIHBhc3MgdG8gdGhlIGluaXQgZnVuY3Rpb24gb2YgdGhlIG5ldyBzY2VuZVxuXHQgKi9cblx0cHVibGljIGNoYW5nZVRvU2NlbmU8VCBleHRlbmRzIFNjZW5lPihjb25zdHI6IG5ldyAoLi4uYXJnczogYW55KSA9PiBULCBpbml0PzogUmVjb3JkPHN0cmluZywgYW55Piwgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcblx0XHRjb25zb2xlLmxvZyhcIkNyZWF0aW5nIHRoZSBuZXcgc2NlbmUgLSBjaGFuZ2UgaXMgcGVuZGluZyB1bnRpbCBuZXh0IHVwZGF0ZVwiKTtcblx0XHR0aGlzLnBlbmRpbmdTY2VuZSA9IG5ldyBjb25zdHIodGhpcy52aWV3cG9ydCwgdGhpcywgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyLCBvcHRpb25zKTtcblx0XHR0aGlzLnBlbmRpbmdTY2VuZUluaXQgPSBpbml0O1xuXHR9XG5cblx0cHJvdGVjdGVkIGRvU2NlbmVDaGFuZ2UoKXtcblx0XHRjb25zb2xlLmxvZyhcIlBlcmZvcm1pbmcgc2NlbmUgY2hhbmdlXCIpO1xuXHRcdHRoaXMudmlld3BvcnQuc2V0Q2VudGVyKHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS54LCB0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueSk7XG5cdFx0XG5cdFx0aWYodGhpcy5jdXJyZW50U2NlbmUpe1xuXHRcdFx0Y29uc29sZS5sb2coXCJVbmxvYWRpbmcgb2xkIHNjZW5lXCIpXG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS51bmxvYWRTY2VuZSgpO1xuXG5cdFx0XHRjb25zb2xlLmxvZyhcIkRlc3Ryb3lpbmcgb2xkIHNjZW5lXCIpO1xuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdGNvbnNvbGUubG9nKFwiVW5sb2FkaW5nIG9sZCByZXNvdXJjZXMuLi5cIik7XG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIudW5sb2FkQWxsUmVzb3VyY2VzKCk7XG5cblx0XHQvLyBNYWtlIHRoZSBwZW5kaW5nIHNjZW5lIHRoZSBjdXJyZW50IG9uZVxuXHRcdHRoaXMuY3VycmVudFNjZW5lID0gdGhpcy5wZW5kaW5nU2NlbmU7XG5cblx0XHQvLyBNYWtlIHRoZSBwZW5kaW5nIHNjZW5lIG51bGxcblx0XHR0aGlzLnBlbmRpbmdTY2VuZSA9IG51bGw7XG5cblx0XHQvLyBJbml0IHRoZSBzY2VuZVxuXHRcdHRoaXMuY3VycmVudFNjZW5lLmluaXRTY2VuZSh0aGlzLnBlbmRpbmdTY2VuZUluaXQpO1xuXG5cdFx0Ly8gRW5xdWV1ZSBhbGwgc2NlbmUgYXNzZXQgbG9hZHNcblx0XHR0aGlzLmN1cnJlbnRTY2VuZS5sb2FkU2NlbmUoKTtcblxuXHRcdC8vIExvYWQgYWxsIGFzc2V0c1xuXHRcdGNvbnNvbGUubG9nKFwiU3RhcnRpbmcgU2NlbmUgTG9hZFwiKTtcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci5sb2FkUmVzb3VyY2VzRnJvbVF1ZXVlKCgpID0+IHtcblx0XHRcdGNvbnNvbGUubG9nKFwiU3RhcnRpbmcgU2NlbmVcIik7XG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5zdGFydFNjZW5lKCk7XG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5zZXRSdW5uaW5nKHRydWUpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5yZW5kZXJpbmdNYW5hZ2VyLnNldFNjZW5lKHRoaXMuY3VycmVudFNjZW5lKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRFxuXHQgKiBAcmV0dXJucyBBIG5ldyBJRFxuXHQgKi9cblx0cHVibGljIGdlbmVyYXRlSWQoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5pZENvdW50ZXIrKztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXJzIHRoZSBjdXJyZW50IFNjZW5lXG5cdCAqL1xuXHRwdWJsaWMgcmVuZGVyKCk6IHZvaWQge1xuXHRcdGlmKHRoaXMuY3VycmVudFNjZW5lKXtcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnJlbmRlcigpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBjdXJyZW50IFNjZW5lXG5cdCAqIEBwYXJhbSBkZWx0YVQgVGhlIHRpbWVzdGVwIG9mIHRoZSBTY2VuZVxuXHQgKi9cblx0cHVibGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcil7XG5cdFx0aWYodGhpcy5wZW5kaW5nU2NlbmUgIT09IG51bGwpe1xuXHRcdFx0dGhpcy5kb1NjZW5lQ2hhbmdlKCk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5jdXJyZW50U2NlbmUgJiYgdGhpcy5jdXJyZW50U2NlbmUuaXNSdW5uaW5nKCkpe1xuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUudXBkYXRlKGRlbHRhVCk7XG5cdFx0fVxuXHR9XG59IiwiaW1wb3J0IEFycmF5VXRpbHMgZnJvbSBcIi4uL1V0aWxzL0FycmF5VXRpbHNcIjtcblxuLy8gQGlnbm9yZVBhZ2VcblxuLyoqXG4gKiBUaGUgb3B0aW9ucyB0byBnaXZlIGEgQHJlZmVyZW5jZVtTY2VuZV0gZm9yIGluaXRpYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lT3B0aW9ucyB7XG4gICAgcGh5c2ljczoge1xuICAgICAgICBncm91cHM6IEFycmF5PHN0cmluZz4sXG4gICAgICAgIGNvbGxpc2lvbnM6IEFycmF5PEFycmF5PG51bWJlcj4+O1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogU2NlbmVPcHRpb25ze1xuICAgICAgICBsZXQgc09wdCA9IG5ldyBTY2VuZU9wdGlvbnMoKTtcblxuICAgICAgICBpZihvcHRpb25zLnBoeXNpY3MgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBzT3B0LnBoeXNpY3MgPSB7Z3JvdXBzOiB1bmRlZmluZWQsIGNvbGxpc2lvbnM6IHVuZGVmaW5lZH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzT3B0LnBoeXNpY3MgPSBvcHRpb25zLnBoeXNpY3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc09wdDtcbiAgICB9XG59IiwiaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuL1ZpZXdwb3J0XCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XG5cbi8qKlxuICogQW4gYWJzdHJhY3QgaW50ZXJmYWNlIG9mIGEgU2NlbmVHcmFwaC5cbiAqIEV4cG9zZXMgbWV0aG9kcyBmb3IgdXNlIGJ5IG90aGVyIGNvZGUsIGJ1dCBsZWF2ZXMgdGhlIGltcGxlbWVudGF0aW9uIHVwIHRvIHRoZSBzdWJjbGFzc2VzLlxuICogVGhlIFNjZW5lR3JhcGggbWFuYWdlcyB0aGUgcG9zaXRpb25zIG9mIGFsbCBHYW1lTm9kZXMsIGFuZCBjYW4gZWFzaWx5IHBydW5lIGEgdmlzaWJsZSBzZXQgZm9yIHJlbmRlcmluZy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU2NlbmVHcmFwaCB7XG5cdC8qKlx0QSByZWZlcmVuY2UgdG8gdGhlIHZpZXdwb3J0ICovXG5cdHByb3RlY3RlZCB2aWV3cG9ydDogVmlld3BvcnQ7XG5cdC8qKlx0QSBtYXAgb2YgQ2FudmFzTm9kZXMgaW4gdGhpcyBTY2VuZUdyYXBoICovXG5cdHByb3RlY3RlZCBub2RlTWFwOiBBcnJheTxDYW52YXNOb2RlPjtcblx0LyoqIEEgY291bnRlciBvZiBJRHMgZm9yIG5vZGVzIGluIHRoaXMgU2NlbmVHcmFwaCAqL1xuXHRwcm90ZWN0ZWQgaWRDb3VudGVyOiBudW1iZXI7XG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgU2NlbmUgdGhpcyBTY2VuZUdyYXBoIGJlbG9uZ3MgdG8gKi9cblx0cHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBTY2VuZUdyYXBoXG5cdCAqIEBwYXJhbSB2aWV3cG9ydCBUaGUgdmlld3BvcnRcblx0ICogQHBhcmFtIHNjZW5lIFRoZSBTY2VuZSB0aGlzIFNjZW5lR3JhcGggYmVsb25ncyB0b1xuXHQgKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWV3cG9ydDogVmlld3BvcnQsIHNjZW5lOiBTY2VuZSl7XG5cdFx0dGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuXHRcdHRoaXMuc2NlbmUgPSBzY2VuZTtcblx0XHR0aGlzLm5vZGVNYXAgPSBuZXcgQXJyYXkoKTtcblx0XHR0aGlzLmlkQ291bnRlciA9IDA7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBBZGQgYSBub2RlIHRvIHRoZSBTY2VuZUdyYXBoXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBDYW52YXNOb2RlIHRvIGFkZCB0byB0aGUgU2NlbmVHcmFwaFxuXHQgKiBAcmV0dXJucyBUaGUgU2NlbmVHcmFwaCBJRCBvZiB0aGlzIG5ld2x5IGFkZGVkIENhbnZhc05vZGVcblx0ICovXG4gICAgYWRkTm9kZShub2RlOiBDYW52YXNOb2RlKTogbnVtYmVyIHtcblx0XHR0aGlzLm5vZGVNYXBbbm9kZS5pZF0gPSBub2RlO1xuXHRcdHRoaXMuYWRkTm9kZVNwZWNpZmljKG5vZGUsIHRoaXMuaWRDb3VudGVyKTtcblx0XHR0aGlzLmlkQ291bnRlciArPSAxO1xuXHRcdHJldHVybiB0aGlzLmlkQ291bnRlciAtIDE7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIG92ZXJyaWRhYmxlIG1ldGhvZCB0byBhZGQgYSBDYW52YXNOb2RlIHRvIHRoZSBzcGVjaWZpYyBkYXRhIHN0cnVjdHVyZSBvZiB0aGUgU2NlbmVHcmFwaFxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBhZGQgdG8gdGhlIGRhdGEgc3RydWN0dXJlXG5cdCAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIENhbnZhc05vZGVcblx0ICovXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBhZGROb2RlU3BlY2lmaWMobm9kZTogQ2FudmFzTm9kZSwgaWQ6IG51bWJlcik6IHZvaWQ7XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhlIFNjZW5lR3JhcGhcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG5cdCAqL1xuICAgIHJlbW92ZU5vZGUobm9kZTogQ2FudmFzTm9kZSk6IHZvaWQge1xuXHRcdC8vIEZpbmQgYW5kIHJlbW92ZSBub2RlIGluIE8obilcblx0XHR0aGlzLm5vZGVNYXBbbm9kZS5pZF0gPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5yZW1vdmVOb2RlU3BlY2lmaWMobm9kZSwgbm9kZS5pZCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBvZiByZW1vdmluZyBhIG5vZGVcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG5cdCAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIG5vZGUgdG8gcmVtb3ZlXG5cdCAqL1xuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgcmVtb3ZlTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBHZXQgYSBzcGVjaWZpYyBub2RlIHVzaW5nIGl0cyBpZFxuXHQgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBDYW52YXNOb2RlIHRvIHJldHJpZXZlXG5cdCAqIEByZXR1cm5zIFRoZSBub2RlIHdpdGggdGhpcyBJRFxuXHQgKi9cblx0Z2V0Tm9kZShpZDogbnVtYmVyKTogQ2FudmFzTm9kZSB7XG5cdFx0cmV0dXJuIHRoaXMubm9kZU1hcFtpZF07XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbm9kZXMgYXQgc3BlY2lmaWMgY29vcmRpbmF0ZXNcblx0ICogQHBhcmFtIHZlY09yWCBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBwb3NpdGlvbiwgb3IgdGhlIGNvb3JkaW5hdGVzIGluIGEgVmVjMlxuXHQgKiBAcGFyYW0geSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBwb3NpdGlvblxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyBmb3VuZCBhdCB0aGUgcG9zaXRpb24gcHJvdmlkZWRcblx0ICovXG4gICAgZ2V0Tm9kZXNBdCh2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiBBcnJheTxDYW52YXNOb2RlPiB7XG5cdFx0aWYodmVjT3JYIGluc3RhbmNlb2YgVmVjMil7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXROb2Rlc0F0Q29vcmRzKHZlY09yWC54LCB2ZWNPclgueSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmdldE5vZGVzQXRDb29yZHModmVjT3JYLCB5KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbm9kZXMgdGhhdCBvdmVybGFwIGEgc3BlY2lmaWMgYm91bmRhcnlcblx0ICogQHBhcmFtIGJvdW5kYXJ5IFRoZSByZWdpb24gdG8gY2hlY2tcblx0ICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXMgZm91bmQgb3ZlcmxhcHBpbmcgdGhlIHByb3ZpZGVkIGJvdW5kYXJ5XG5cdCAqL1xuXHRhYnN0cmFjdCBnZXROb2Rlc0luUmVnaW9uKGJvdW5kYXJ5OiBBQUJCKTogQXJyYXk8Q2FudmFzTm9kZT47XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhbGwgbm9kZXMgaW4gdGhlIFNjZW5lR3JhcGhcblx0ICogQHJldHVybnMgQW4gQXJyYXkgY29udGFpbmluZyBhbGwgbm9kZXMgaW4gdGhlIFNjZW5lR3JhcGhcblx0ICovXG5cdGdldEFsbE5vZGVzKCk6IEFycmF5PENhbnZhc05vZGU+IHtcblx0XHRsZXQgYXJyID0gbmV3IEFycmF5PENhbnZhc05vZGU+KCk7XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMubm9kZU1hcC5sZW5ndGg7IGkrKyl7XG5cdFx0XHRpZih0aGlzLm5vZGVNYXBbaV0gIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcdGFyci5wdXNoKHRoaXMubm9kZU1hcFtpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIG9mIGdldHRpbmcgYSBub2RlIGF0IGNlcnRhaW4gY29vcmRpbmF0ZXNcblx0ICogQHBhcmFtIHggVGhlIHgtY29vcmRpbmF0ZXMgb2YgdGhlIG5vZGVcblx0ICogQHBhcmFtIHkgVGhlIHktY29vcmRpbmF0ZXMgb2YgdGhlIG5vZGVcblx0ICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGdldE5vZGVzQXRDb29yZHMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBBcnJheTxDYW52YXNOb2RlPjtcblxuXHRhYnN0cmFjdCB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkO1xuXHRcblx0YWJzdHJhY3QgcmVuZGVyKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZDtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgdmlzaWJsZSBzZXQgb2YgQ2FudmFzTm9kZXMgYmFzZWQgb24gdGhlIEByZWZlcmVuY2VbVmlld3BvcnRdXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHZpc2libGUgbm9kZXMgaW4gdGhlIFNjZW5lR3JhcGhcblx0ICovXG4gICAgYWJzdHJhY3QgZ2V0VmlzaWJsZVNldCgpOiBBcnJheTxDYW52YXNOb2RlPjtcbn0iLCJpbXBvcnQgU2NlbmVHcmFwaCBmcm9tIFwiLi9TY2VuZUdyYXBoXCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuL1ZpZXdwb3J0XCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XG5pbXBvcnQgU3RhdHMgZnJvbSBcIi4uL0RlYnVnL1N0YXRzXCI7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYSBTY2VuZUdyYXBoIHRoYXQgc2ltcGx5IHN0b3JlZCBDYW52YXNOb2RlcyBpbiBhbiBhcnJheS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVHcmFwaEFycmF5IGV4dGVuZHMgU2NlbmVHcmFwaCB7XG4gICAgLyoqIFRoZSBsaXN0IG9mIENhbnZhc05vZGVzIGluIHRoaXMgU2NlbmVHcmFwaCAqL1xuICAgIHByaXZhdGUgbm9kZUxpc3Q6IEFycmF5PENhbnZhc05vZGU+O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTY2VuZUdyYXBoQXJyYXlcbiAgICAgKiBAcGFyYW0gdmlld3BvcnQgVGhlIFZpZXdwb3J0XG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBTY2VuZSB0aGlzIFNjZW5lR3JhcGggYmVsb25ncyB0b1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZpZXdwb3J0OiBWaWV3cG9ydCwgc2NlbmU6IFNjZW5lKXtcbiAgICAgICAgc3VwZXIodmlld3BvcnQsIHNjZW5lKTtcblxuICAgICAgICB0aGlzLm5vZGVMaXN0ID0gbmV3IEFycmF5PENhbnZhc05vZGU+KCk7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgcHJvdGVjdGVkIGFkZE5vZGVTcGVjaWZpYyhub2RlOiBDYW52YXNOb2RlLCBpZDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMubm9kZUxpc3QucHVzaChub2RlKTtcbiAgICB9XG5cbiAgICAvLyBAb3ZlcnJpZGVcbiAgICBwcm90ZWN0ZWQgcmVtb3ZlTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5ub2RlTGlzdC5pbmRleE9mKG5vZGUpO1xuICAgICAgICBpZihpbmRleCA+IC0xKXtcbiAgICAgICAgICAgIHRoaXMubm9kZUxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEBvdmVycmlkZVxuICAgIGdldE5vZGVzQXRDb29yZHMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBBcnJheTxDYW52YXNOb2RlPiB7XG4gICAgICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMubm9kZUxpc3Qpe1xuICAgICAgICAgICAgaWYobm9kZS5jb250YWlucyh4LCB5KSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgZ2V0Tm9kZXNJblJlZ2lvbihib3VuZGFyeTogQUFCQik6IEFycmF5PENhbnZhc05vZGU+IHtcbiAgICAgICAgbGV0IHQwID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMubm9kZUxpc3Qpe1xuICAgICAgICAgICAgaWYoYm91bmRhcnkub3ZlcmxhcHMobm9kZS5ib3VuZGFyeSkpe1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgU3RhdHMubG9nKFwic2dxdWVyeVwiLCAodDEtdDApKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IHQwID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcbiAgICAgICAgICAgIGlmKCFub2RlLmdldExheWVyKCkuaXNQYXVzZWQoKSl7XG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGUoZGVsdGFUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgU3RhdHMubG9nKFwic2d1cGRhdGVcIiwgKHQxLXQwKSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZCB7fVxuXG4gICAgLy8gQG92ZXJyaWRlXG4gICAgZ2V0VmlzaWJsZVNldCgpOiBBcnJheTxDYW52YXNOb2RlPiB7XG4gICAgICAgIGxldCB2aXNpYmxlU2V0ID0gbmV3IEFycmF5PENhbnZhc05vZGU+KCk7XG5cbiAgICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMubm9kZUxpc3Qpe1xuICAgICAgICAgICAgaWYoIW5vZGUuZ2V0TGF5ZXIoKS5pc0hpZGRlbigpICYmIG5vZGUudmlzaWJsZSAmJiB0aGlzLnZpZXdwb3J0LmluY2x1ZGVzKG5vZGUpKXtcbiAgICAgICAgICAgICAgICB2aXNpYmxlU2V0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmlzaWJsZVNldDtcbiAgICB9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vVXRpbHMvTWF0aFV0aWxzXCI7XG5pbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9RdWV1ZVwiO1xuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuLi9JbnB1dC9JbnB1dFwiO1xuaW1wb3J0IFBhcmFsbGF4TGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9QYXJhbGxheExheWVyXCI7XG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1VJTGF5ZXJcIjtcblxuLyoqXG4gKiBUaGUgdmlld3BvcnQgb2YgdGhlIGdhbWUuIENvcnJlc3BvbmRzIHRvIHRoZSB2aXNpYmxlIHdpbmRvdyBkaXNwbGF5ZWQgaW4gdGhlIGJyb3dzZXIuXG4gKiBUaGUgdmlld3BvcnQga2VlcHMgdHJhY2sgb2YgaXRzIHBvc2l0aW9uIGluIHRoZSBnYW1lIHdvcmxkLCBhbmQgY2FuIGFjdCBhcyBhIGNhbWVyYSB0byBmb2xsb3cgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld3BvcnQge1xuICAgIC8qKiBUaGUgQUFCQiB0aGF0IGNvbnRhaW5zIHRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiB0aGUgdmlld3BvcnQgdmlldyAqL1xuICAgIHByaXZhdGUgdmlldzogQUFCQjtcbiAgICAvKiogVGhlIGJvdW5kYXJ5IGZvciB0aGUgdmlld3BvcnQuIFRoaXMgcmVwcmVzZW50cyB0aGUgbGltaXRzIHRvIHdoZXJlIHRoZSB2aWV3cG9ydCBjYW4gZ28gKi9cbiAgICBwcml2YXRlIGJvdW5kYXJ5OiBBQUJCO1xuICAgIC8qKiBUaGUgR2FtZU5vZGUgdGhlIFZpZXdwb3J0IGlzIGZvbGxvd2luZyAqL1xuICAgIHByaXZhdGUgZm9sbG93aW5nOiBHYW1lTm9kZTtcbiAgICAvKiogVGhlIHBvc2l0aW9uIHRoZSBHYW1lTm9kZSBpcyBmb2N1c2luZyBvbi4gVGhpcyBpcyBvdmVycmlkZGVuIGlmIFwiZm9sbG93aW5nXCIgaXMgc2V0LiAqL1xuICAgIHByaXZhdGUgZm9jdXM6IFZlYzI7XG5cbiAgICAvKiogQSBxdWV1ZSBvZiBwcmV2aW91cyBwb3NpdGlvbnMgb2Ygd2hhdCB0aGlzIHZpZXdwb3J0IGlzIGZvbGxvd2luZy4gVXNlZCBmb3Igc21vb3RoaW5nIHZpZXdwb3J0IG1vdmVtZW50ICovXG4gICAgcHJpdmF0ZSBsYXN0UG9zaXRpb25zOiBRdWV1ZTxWZWMyPjtcblxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHByZXZpb3VzIHBvc2l0aW9ucyB0aGlzIHZpZXdwb3J0IHRyYWNrcyAqL1xuICAgIHByaXZhdGUgc21vb3RoaW5nRmFjdG9yOiBudW1iZXI7XG5cbiAgICAvKiogQSBib29sZWFuIHRoYSByZXByZXNlbnRzIHdoZXRoZXIgdGhlIHBsYXllciBjYW4gem9vbSBieSBzY3JvbGxpbmcgd2l0aCB0aGUgbW91c2Ugd2hlZWwgKi9cbiAgICBwcml2YXRlIHNjcm9sbFpvb21FbmFibGVkOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSBhbW91bnQgdGhhdCBpcyB6b29tZWQgaW4gb3Igb3V0LiAqL1xuICAgIHByaXZhdGUgWk9PTV9GQUNUT1I6IG51bWJlciA9IDEuMjtcblxuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgY2FudmFzICovXG4gICAgcHJpdmF0ZSBjYW52YXNTaXplOiBWZWMyO1xuXG4gICAgY29uc3RydWN0b3IoY2FudmFzU2l6ZTogVmVjMiwgem9vbUxldmVsOiBudW1iZXIpe1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgQUFCQihWZWMyLlpFUk8sIFZlYzIuWkVSTyk7XG4gICAgICAgIHRoaXMuYm91bmRhcnkgPSBuZXcgQUFCQihWZWMyLlpFUk8sIFZlYzIuWkVSTyk7XG4gICAgICAgIHRoaXMubGFzdFBvc2l0aW9ucyA9IG5ldyBRdWV1ZSgpO1xuICAgICAgICB0aGlzLnNtb290aGluZ0ZhY3RvciA9IDEwO1xuICAgICAgICB0aGlzLnNjcm9sbFpvb21FbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FudmFzU2l6ZSA9IFZlYzIuWkVSTztcbiAgICAgICAgdGhpcy5mb2N1cyA9IFZlYzIuWkVSTztcblxuICAgICAgICAvLyBTZXQgdGhlIHNpemUgb2YgdGhlIGNhbnZhc1xuICAgICAgICB0aGlzLnNldENhbnZhc1NpemUoY2FudmFzU2l6ZSk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydFxuICAgICAgICB0aGlzLnNldFNpemUoY2FudmFzU2l6ZSk7XG4gICAgICAgIHRoaXMuc2V0Wm9vbUxldmVsKHpvb21MZXZlbCk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBjZW50ZXIgKGFuZCBtYWtlIHRoZSB2aWV3cG9ydCBzdGF5IHRoZXJlKVxuICAgICAgICB0aGlzLnNldENlbnRlcih0aGlzLnZpZXcuaGFsZlNpemUuY2xvbmUoKSk7XG4gICAgICAgIHRoaXMuc2V0Rm9jdXModGhpcy52aWV3LmhhbGZTaXplLmNsb25lKCkpO1xuICAgIH1cblxuICAgIC8qKiBFbmFibGVzIHRoZSB2aWV3cG9ydCB0byB6b29tIGluIGFuZCBvdXQgKi9cbiAgICBlbmFibGVab29tKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNjcm9sbFpvb21FbmFibGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcmV0dXJucyBUaGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCBhcyBhIFZlYzJcbiAgICAgKi9cbiAgICBnZXRDZW50ZXIoKTogVmVjMiB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuY2VudGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjMiB3aXRoIHRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHJldHVybnMgVGhlIHRvcCBsZWZ0IGNvcm5kZXIgb2YgdGhlIFZpZXBvcnQgYXMgYSBWZWMyXG4gICAgICovXG4gICAgZ2V0T3JpZ2luKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy52aWV3LmxlZnQsIHRoaXMudmlldy50b3ApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlZ2lvbiB2aXNpYmxlIHRvIHRoaXMgdmlld3BvcnRcbiAgICAgKiBAcmV0dXJucyBUaGUgQUFCQiBjb250YWluaW5nIHRoZSByZWdpb24gdmlzaWJsZSB0byB0aGUgdmlld3BvcnRcbiAgICAgKi9cbiAgICBnZXRWaWV3KCk6IEFBQkIge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IHBvc2l0aW9uIG9yIHRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB5IFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb3NpdGlvblxuICAgICAqL1xuICAgIHNldENlbnRlcih2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcbiAgICAgICAgbGV0IHBvczogVmVjMjtcblx0XHRpZih2ZWNPclggaW5zdGFuY2VvZiBWZWMyKXtcbiAgICAgICAgICAgIHBvcyA9IHZlY09yWDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcyA9IG5ldyBWZWMyKHZlY09yWCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZpZXcuY2VudGVyID0gcG9zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0IGFzIGEgVmVjMlxuICAgICAqIEByZXR1cm5zIFRoZSBoYWxmLXNpemUgb2YgdGhlIHZpZXdwb3J0IGFzIGEgVmVjMlxuICAgICAqL1xuICAgIGdldEhhbGZTaXplKCk6IFZlYzIge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldEhhbGZTaXplKCk7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IHdpZHRoIG9mIHRoZSB2aWV3cG9ydCBvciB0aGUgbmV3IHNpemUgYXMgYSBWZWMyXG4gICAgICogQHBhcmFtIHkgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XG4gICAgICovXG4gICAgc2V0U2l6ZSh2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcblx0XHRpZih2ZWNPclggaW5zdGFuY2VvZiBWZWMyKXtcblx0XHRcdHRoaXMudmlldy5zZXRIYWxmU2l6ZSh2ZWNPclguc2NhbGVkKDEvMikpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnZpZXcuc2V0SGFsZlNpemUobmV3IFZlYzIodmVjT3JYLzIsIHkvMikpO1xuXHRcdH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoYWxmLXNpemUgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IGhhbGYtd2lkdGggb2YgdGhlIHZpZXdwb3J0IG9yIHRoZSBuZXcgaGFsZi1zaXplIGFzIGEgVmVjMlxuICAgICAqIEBwYXJhbSB5IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydFxuICAgICAqL1xuICAgIHNldEhhbGZTaXplKHZlY09yWDogVmVjMiB8IG51bWJlciwgeTogbnVtYmVyID0gbnVsbCk6IHZvaWQge1xuXHRcdGlmKHZlY09yWCBpbnN0YW5jZW9mIFZlYzIpe1xuXHRcdFx0dGhpcy52aWV3LnNldEhhbGZTaXplKHZlY09yWC5jbG9uZSgpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy52aWV3LnNldEhhbGZTaXplKG5ldyBWZWMyKHZlY09yWCwgeSkpO1xuXHRcdH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB2aWV3cG9ydCB3aXRoIHRoZSBzaXplIG9mIHRoZSBjdXJyZW50IENhbnZhc1xuICAgICAqIEBwYXJhbSB2ZWNPclggVGhlIHdpZHRoIG9mIHRoZSBjYW52YXMsIG9yIHRoZSBjYW52YXMgc2l6ZSBhcyBhIFZlYzJcbiAgICAgKiBAcGFyYW0geSBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXNcbiAgICAgKi9cbiAgICBzZXRDYW52YXNTaXplKHZlY09yWDogVmVjMiB8IG51bWJlciwgeTogbnVtYmVyID0gbnVsbCk6IHZvaWQge1xuXHRcdGlmKHZlY09yWCBpbnN0YW5jZW9mIFZlYzIpe1xuXHRcdFx0dGhpcy5jYW52YXNTaXplID0gdmVjT3JYLmNsb25lKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY2FudmFzU2l6ZSA9IG5ldyBWZWMyKHZlY09yWCwgeSk7XG5cdFx0fVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHpvb20gVGhlIHpvb20gbGV2ZWxcbiAgICAgKi9cbiAgICBzZXRab29tTGV2ZWwoem9vbTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMudmlldy5oYWxmU2l6ZS5jb3B5KHRoaXMuY2FudmFzU2l6ZS5zY2FsZWQoMS96b29tLzIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEByZXR1cm5zIFRoZSB6b29tIGxldmVsXG4gICAgICovXG4gICAgZ2V0Wm9vbUxldmVsKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc1NpemUueC90aGlzLnZpZXcuaHcvMlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNtb290aGluZyBmYWN0b3IgZm9yIHRoZSB2aWV3cG9ydCBtb3ZlbWVudC5cbiAgICAgKiBAcGFyYW0gc21vb3RoaW5nRmFjdG9yIFRoZSBzbW9vdGhpbmcgZmFjdG9yIGZvciB0aGUgdmlld3BvcnRcbiAgICAgKi9cbiAgICBzZXRTbW9vdGhpbmdGYWN0b3Ioc21vb3RoaW5nRmFjdG9yOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYoc21vb3RoaW5nRmFjdG9yIDwgMSkgc21vb3RoaW5nRmFjdG9yID0gMTtcbiAgICAgICAgdGhpcy5zbW9vdGhpbmdGYWN0b3IgPSBzbW9vdGhpbmdGYWN0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHZpZXdwb3J0IHRvIGZvY3VzIG9uIGEgcG9pbnQuIE92ZXJpZGRlbiBieSBcImZvbGxvd2luZ1wiLlxuICAgICAqIEBwYXJhbSBmb2N1cyBUaGUgcG9pbnQgdGhlICB2aWV3cG9ydCBzaG91bGQgZm9jdXMgb25cbiAgICAgKi9cbiAgICBzZXRGb2N1cyhmb2N1czogVmVjMik6IHZvaWQge1xuICAgICAgICB0aGlzLmZvY3VzLmNvcHkoZm9jdXMpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIENhbnZhc05vZGUgaXMgaW5zaWRlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbm9kZSBpcyBjdXJyZW50bHkgdmlzaWJsZSBpbiB0aGUgdmlld3BvcnQsIGZhbHNlIGlmIG5vdFxuICAgICAqL1xuICAgIGluY2x1ZGVzKG5vZGU6IENhbnZhc05vZGUpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IHBhcmFsbGF4ID0gbm9kZS5nZXRMYXllcigpIGluc3RhbmNlb2YgUGFyYWxsYXhMYXllciB8fCBub2RlLmdldExheWVyKCkgaW5zdGFuY2VvZiBVSUxheWVyID8gKDxQYXJhbGxheExheWVyPm5vZGUuZ2V0TGF5ZXIoKSkucGFyYWxsYXggOiBuZXcgVmVjMigxLCAxKTtcbiAgICAgICAgbGV0IGNlbnRlciA9IHRoaXMudmlldy5jZW50ZXIuY2xvbmUoKTtcbiAgICAgICAgdGhpcy52aWV3LmNlbnRlci5tdWx0KHBhcmFsbGF4KTtcbiAgICAgICAgbGV0IG92ZXJsYXBzID0gdGhpcy52aWV3Lm92ZXJsYXBzKG5vZGUuYm91bmRhcnkpO1xuICAgICAgICB0aGlzLnZpZXcuY2VudGVyID0gY2VudGVyXG4gICAgICAgIHJldHVybiBvdmVybGFwcztcbiAgICB9XG5cblx0Ly8gVE9ETzogUHV0IHNvbWUgZXJyb3IgaGFuZGxpbmcgb24gdGhpcyBmb3IgdHJ5aW5nIHRvIG1ha2UgdGhlIGJvdW5kcyB0b28gc21hbGwgZm9yIHRoZSB2aWV3cG9ydFxuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIGRvbmUgYXV0b21hdGljYWxseSwgb3Igc2hvdWxkIGNvbnNpZGVyIHRoZSBhc3BlY3QgcmF0aW8gb3Igc29tZXRoaW5nXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm91bmRzIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBsb3dlclggVGhlIGxlZnQgZWRnZSBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gbG93ZXJZIFRoZSB0b3AgZWRnZSBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gdXBwZXJYIFRoZSByaWdodCBlZGdlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB1cHBlclkgVGhlIGJvdHRvbSBlZGdlIG9mIHRoZSB2aWV3cG9ydFxuICAgICAqL1xuICAgIHNldEJvdW5kcyhsb3dlclg6IG51bWJlciwgbG93ZXJZOiBudW1iZXIsIHVwcGVyWDogbnVtYmVyLCB1cHBlclk6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBsZXQgaHdpZHRoID0gKHVwcGVyWCAtIGxvd2VyWCkvMjtcbiAgICAgICAgbGV0IGhoZWlnaHQgPSAodXBwZXJZIC0gbG93ZXJZKS8yO1xuICAgICAgICBsZXQgeCA9IGxvd2VyWCArIGh3aWR0aDtcbiAgICAgICAgbGV0IHkgPSBsb3dlclkgKyBoaGVpZ2h0O1xuICAgICAgICB0aGlzLmJvdW5kYXJ5LmNlbnRlci5zZXQoeCwgeSk7XG4gICAgICAgIHRoaXMuYm91bmRhcnkuaGFsZlNpemUuc2V0KGh3aWR0aCwgaGhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0aGUgdmlld3BvcnQgZm9sbG93IHRoZSBzcGVjaWZpZWQgR2FtZU5vZGVcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgR2FtZU5vZGUgdG8gZm9sbG93XG4gICAgICovXG4gICAgZm9sbG93KG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9sbG93aW5nID0gbm9kZTtcbiAgICB9XG5cbiAgICB1cGRhdGVWaWV3KCk6IHZvaWQge1xuICAgICAgICBpZih0aGlzLmxhc3RQb3NpdGlvbnMuZ2V0U2l6ZSgpID4gdGhpcy5zbW9vdGhpbmdGYWN0b3Ipe1xuICAgICAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zLmRlcXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gR2V0IHRoZSBhdmVyYWdlIG9mIHRoZSBsYXN0IDEwIHBvc2l0aW9uc1xuICAgICAgICBsZXQgcG9zID0gVmVjMi5aRVJPO1xuICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbnMuZm9yRWFjaChwb3NpdGlvbiA9PiBwb3MuYWRkKHBvc2l0aW9uKSk7XG4gICAgICAgIHBvcy5zY2FsZSgxL3RoaXMubGFzdFBvc2l0aW9ucy5nZXRTaXplKCkpO1xuXG4gICAgICAgIC8vIFNldCB0aGlzIHBvc2l0aW9uIGVpdGhlciB0byB0aGUgb2JqZWN0IG9yIHRvIGl0cyBib3VuZHNcbiAgICAgICAgcG9zLnggPSBNYXRoVXRpbHMuY2xhbXAocG9zLngsIHRoaXMuYm91bmRhcnkubGVmdCArIHRoaXMudmlldy5odywgdGhpcy5ib3VuZGFyeS5yaWdodCAtIHRoaXMudmlldy5odyk7XG4gICAgICAgIHBvcy55ID0gTWF0aFV0aWxzLmNsYW1wKHBvcy55LCB0aGlzLmJvdW5kYXJ5LnRvcCArIHRoaXMudmlldy5oaCwgdGhpcy5ib3VuZGFyeS5ib3R0b20gLSB0aGlzLnZpZXcuaGgpO1xuXG4gICAgICAgIC8vIEFzc3VyZSB0aGVyZSBhcmUgbm8gbGluZXMgaW4gdGhlIHRpbGVtYXBcbiAgICAgICAgcG9zLnggPSBNYXRoLmZsb29yKHBvcy54KTtcbiAgICAgICAgcG9zLnkgPSBNYXRoLmZsb29yKHBvcy55KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMudmlldy5jZW50ZXIuY29weShwb3MpO1xuICAgIH1cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICAvLyBJZiB6b29tIGlzIGVuYWJsZWRcbiAgICAgICAgaWYodGhpcy5zY3JvbGxab29tRW5hYmxlZCl7XG4gICAgICAgICAgICBpZihJbnB1dC5kaWRKdXN0U2Nyb2xsKCkpe1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U2l6ZSA9IHRoaXMudmlldy5nZXRIYWxmU2l6ZSgpLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgaWYoSW5wdXQuZ2V0U2Nyb2xsRGlyZWN0aW9uKCkgPCAwKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gWm9vbSBpblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS5zY2FsZSgxL3RoaXMuWk9PTV9GQUNUT1IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFpvb20gb3V0XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnNjYWxlKHRoaXMuWk9PTV9GQUNUT1IpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRTaXplLnggPiB0aGlzLmJvdW5kYXJ5Lmh3KXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZhY3RvciA9IHRoaXMuYm91bmRhcnkuaHcvY3VycmVudFNpemUueDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpemUueCA9IHRoaXMuYm91bmRhcnkuaHc7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnkgKj0gZmFjdG9yO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRTaXplLnkgPiB0aGlzLmJvdW5kYXJ5LmhoKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZhY3RvciA9IHRoaXMuYm91bmRhcnkuaGgvY3VycmVudFNpemUueTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpemUueSA9IHRoaXMuYm91bmRhcnkuaGg7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnggKj0gZmFjdG9yO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRIYWxmU2l6ZShjdXJyZW50U2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB2aWV3cG9ydCBpcyBmb2xsb3dpbmcgYW4gb2JqZWN0XG4gICAgICAgIGlmKHRoaXMuZm9sbG93aW5nKXtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBvdXIgbGlzdCBvZiBwcmV2aW91cyBwb3NpdGlvbnNcbiAgICAgICAgICAgIHRoaXMubGFzdFBvc2l0aW9ucy5lbnF1ZXVlKHRoaXMuZm9sbG93aW5nLnBvc2l0aW9uLmNsb25lKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zLmVucXVldWUodGhpcy5mb2N1cyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKTtcbiAgICB9XG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFR5cGVcIjtcblxuLyoqXG4gKiBNYW5hZ2VzIGFueSBzb3VuZHMgb3IgbXVzaWMgbmVlZGVkIGZvciB0aGUgZ2FtZS5cbiAqIFRocm91Z2ggdGhlIEV2ZW50UXVldWUsIGV4cG9zZXMgaW50ZXJmYWNlIHRvIHBsYXkgc291bmRzIHNvIEdhbWVOb2RlcyBjYW4gYWN0aXZhdGUgc291bmRzIHdpdGhvdXRcbiAqIG5lZWRpbmcgZGlyZWN0IHJlZmVyZW5jZXMgdG8gdGhlIGF1ZGlvIHN5c3RlbVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdWRpb01hbmFnZXIge1xuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBBdWRpb01hbmFnZXI7XG5cbiAgICAvKiogVGhlIGV2ZW50IHJlY2VpdmVyIG9mIHRoaXMgQXVkaW9NYW5hZ2VyICovXG4gICAgcHJpdmF0ZSByZWNlaXZlcjogUmVjZWl2ZXI7XG5cbiAgICAvKiogQSBNYXAgb2YgdGhlIG5hbWVzIG9mIGN1cnJlbnRseSBwbGF5aW5nIChvciBwYXVzZWQpIHNvdW5kcyB0byB0aGVpciBBdWRpb0J1ZmZlcnMgKi9cbiAgICBwcml2YXRlIGN1cnJlbnRTb3VuZHM6IE1hcDxBdWRpb0J1ZmZlclNvdXJjZU5vZGU+O1xuXG4gICAgcHJpdmF0ZSBhdWRpb0N0eDogQXVkaW9Db250ZXh0O1xuXG4gICAgcHJpdmF0ZSBnYWluTm9kZXM6IEFycmF5PEdhaW5Ob2RlPjtcblxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5pbml0QXVkaW8oKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShbXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlBMQVlfU09VTkQsXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlNUT1BfU09VTkQsXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlBMQVlfTVVTSUMsXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlBMQVlfU0ZYLFxuICAgICAgICAgICAgR2FtZUV2ZW50VHlwZS5NVVRFX0NIQU5ORUwsXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlVOTVVURV9DSEFOTkVMXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmN1cnJlbnRTb3VuZHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5nYWluTm9kZXMgPSBuZXcgQXJyYXk8R2Fpbk5vZGU+KE1BWF9BVURJT19DSEFOTkVMUyk7XG4gICAgICAgIHRoaXMuaW5pdEdhaW5Ob2RlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5zdGFuY2Ugb2YgdGhlIEF1ZGlvTWFuYWdlciBjbGFzcyBvciBjcmVhdGUgYSBuZXcgb25lIGlmIG5vbmUgZXhpc3RzXG4gICAgICogQHJldHVybnMgVGhlIEF1ZGlvTWFuYWdlclxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogQXVkaW9NYW5hZ2VyIHtcbiAgICAgICAgaWYoIXRoaXMuaW5zdGFuY2Upe1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBBdWRpb01hbmFnZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgd2ViQXVkaW8gY29udGV4dFxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdEF1ZGlvKCk6IHZvaWQge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdpbmRvdy5BdWRpb0NvbnRleHQ7Ly8gfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDsgXG4gICAgICAgICAgICB0aGlzLmF1ZGlvQ3R4ID0gbmV3IEF1ZGlvQ29udGV4dCgpOyBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXZWIgQXVkaW8gQVBJIHN1Y2Nlc3NmdWxseSBsb2FkZWQnKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dlYiBBdWRpbyBBUEkgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTsgXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGluaXRHYWluTm9kZXMoKTogdm9pZCB7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBNQVhfQVVESU9fQ0hBTk5FTFM7IGkrKyl7XG4gICAgICAgICAgICB0aGlzLmdhaW5Ob2Rlc1tpXSA9IHRoaXMuYXVkaW9DdHguY3JlYXRlR2FpbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBhdWRpbyBjb250ZXh0XG4gICAgICogQHJldHVybnMgVGhlIEF1ZGlvQ29udGV4dFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRBdWRpb0NvbnRleHQoKTogQXVkaW9Db250ZXh0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVkaW9DdHg7XG4gICAgfVxuXG4gICAgLypcbiAgICAgICAgQWNjb3JkaW5nIHRvIHRoZSBNRE4sIGNyZWF0ZSBhIG5ldyBzb3VuZCBmb3IgZXZlcnkgY2FsbDpcblxuICAgICAgICBBbiBBdWRpb0J1ZmZlclNvdXJjZU5vZGUgY2FuIG9ubHkgYmUgcGxheWVkIG9uY2U7IGFmdGVyIGVhY2ggY2FsbCB0byBzdGFydCgpLCB5b3UgaGF2ZSB0byBjcmVhdGUgYSBuZXcgbm9kZVxuICAgICAgICBpZiB5b3Ugd2FudCB0byBwbGF5IHRoZSBzYW1lIHNvdW5kIGFnYWluLiBGb3J0dW5hdGVseSwgdGhlc2Ugbm9kZXMgYXJlIHZlcnkgaW5leHBlbnNpdmUgdG8gY3JlYXRlLCBhbmQgdGhlXG4gICAgICAgIGFjdHVhbCBBdWRpb0J1ZmZlcnMgY2FuIGJlIHJldXNlZCBmb3IgbXVsdGlwbGUgcGxheXMgb2YgdGhlIHNvdW5kLiBJbmRlZWQsIHlvdSBjYW4gdXNlIHRoZXNlIG5vZGVzIGluIGFcbiAgICAgICAgXCJmaXJlIGFuZCBmb3JnZXRcIiBtYW5uZXI6IGNyZWF0ZSB0aGUgbm9kZSwgY2FsbCBzdGFydCgpIHRvIGJlZ2luIHBsYXlpbmcgdGhlIHNvdW5kLCBhbmQgZG9uJ3QgZXZlbiBib3RoZXIgdG9cbiAgICAgICAgaG9sZCBhIHJlZmVyZW5jZSB0byBpdC4gSXQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGdhcmJhZ2UtY29sbGVjdGVkIGF0IGFuIGFwcHJvcHJpYXRlIHRpbWUsIHdoaWNoIHdvbid0IGJlXG4gICAgICAgIHVudGlsIHNvbWV0aW1lIGFmdGVyIHRoZSBzb3VuZCBoYXMgZmluaXNoZWQgcGxheWluZy5cbiAgICAqL1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc291bmQgZnJvbSB0aGUga2V5IG9mIGEgbG9hZGVkIGF1ZGlvIGZpbGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCBhdWRpbyBmaWxlIHRvIGNyZWF0ZSBhIG5ldyBzb3VuZCBmb3JcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3bHkgY3JlYXRlZCBBdWRpb0J1ZmZlclxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVTb3VuZChrZXk6IHN0cmluZywgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiwgY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSwgb3B0aW9uczogTWFwPGFueT4pOiBBdWRpb0J1ZmZlclNvdXJjZU5vZGUge1xuICAgICAgICAvLyBHZXQgYXVkaW8gYnVmZmVyXG4gICAgICAgIGxldCBidWZmZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXRBdWRpbyhrZXkpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIHNvdW5kIHNvdXJjZVxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5hdWRpb0N0eC5jcmVhdGVCdWZmZXJTb3VyY2UoKTsgXG4gICAgICBcbiAgICAgICAgLy8gVGVsbCB0aGUgc291cmNlIHdoaWNoIHNvdW5kIHRvIHBsYXlcbiAgICAgICAgc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjsgICAgICAgICAgICAgICBcbiAgICAgIFxuICAgICAgICAvLyBBZGQgYW55IGFkZGl0aW9uYWwgbm9kZXNcbiAgICAgICAgY29uc3Qgbm9kZXM6IEFycmF5PEF1ZGlvTm9kZT4gPSBbc291cmNlXTtcblxuICAgICAgICAvLyBEbyBhbnkgYWRkaXRpb25hbCBub2RlcyBoZXJlP1xuICAgICAgICAvLyBPZiBjb3Vyc2UsIHRoZXJlIGFyZW4ndCBhbnkgc3VwcG9ydGVkIHlldC4uLlxuXG4gICAgICAgIC8vIEFkZCB0aGUgZ2FpbiBub2RlIGZvciB0aGlzIGNoYW5uZWxcbiAgICAgICAgbm9kZXMucHVzaCh0aGlzLmdhaW5Ob2Rlc1tjaGFubmVsXSk7XG5cbiAgICAgICAgLy8gQ29ubmVjdCBhbnkgbm9kZXMgYWxvbmcgdGhlIHBhdGhcbiAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIG5vZGVzW2ktMV0uY29ubmVjdChub2Rlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25uZWN0IHRoZSBzb3VyY2UgdG8gdGhlIGNvbnRleHQncyBkZXN0aW5hdGlvblxuICAgICAgICBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXS5jb25uZWN0KHRoaXMuYXVkaW9DdHguZGVzdGluYXRpb24pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGF5IHRoZSBzb3VuZCBzcGVjaWZpZWQgYnkgdGhlIGtleVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgc291bmQgdG8gcGxheVxuICAgICAqIEBwYXJhbSBsb29wIEEgYm9vbGVhbiBmb3Igd2hldGhlciBvciBub3QgdG8gbG9vcCB0aGUgc291bmRcbiAgICAgKiBAcGFyYW0gaG9sZFJlZmVyZW5jZSBBIGJvb2xlYW4gZm9yIHdoZXRoZXIgb3Igbm90IHdlIHdhbnQgdG8gaG9sZCBvbiB0byBhIHJlZmVyZW5jZSBvZiB0aGUgYXVkaW8gbm9kZS4gVGhpcyBpcyBnb29kIGZvciBwbGF5aW5nIG11c2ljIG9uIGEgbG9vcCB0aGF0IHdpbGwgZXZlbnR1YWxseSBuZWVkIHRvIGJlIHN0b3BwZWQuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHBsYXlTb3VuZChrZXk6IHN0cmluZywgbG9vcDogYm9vbGVhbiwgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiwgY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSwgb3B0aW9uczogTWFwPGFueT4pOiB2b2lkIHtcbiAgICAgICAgbGV0IHNvdW5kID0gdGhpcy5jcmVhdGVTb3VuZChrZXksIGhvbGRSZWZlcmVuY2UsIGNoYW5uZWwsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmKGxvb3Ape1xuICAgICAgICAgICAgc291bmQubG9vcCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgYSByZWZlcmVuY2Ugb2YgdGhlIG5ldyBzb3VuZCB0byBhIG1hcC4gVGhpcyB3aWxsIGFsbG93IHVzIHRvIHN0b3AgYSBsb29waW5nIG9yIGxvbmcgc291bmQgYXQgYSBsYXRlciB0aW1lXG4gICAgICAgIGlmKGhvbGRSZWZlcmVuY2Upe1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U291bmRzLmFkZChrZXksIHNvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc291bmQuc3RhcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSBzb3VuZCBzcGVjaWZpZWQgYnkgdGhlIGtleVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzdG9wU291bmQoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgbGV0IHNvdW5kID0gdGhpcy5jdXJyZW50U291bmRzLmdldChrZXkpO1xuICAgICAgICBpZihzb3VuZCl7XG4gICAgICAgICAgICBzb3VuZC5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTb3VuZHMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgbXV0ZUNoYW5uZWwoY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSl7XG4gICAgICAgIHRoaXMuZ2Fpbk5vZGVzW2NoYW5uZWxdLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgdGhpcy5hdWRpb0N0eC5jdXJyZW50VGltZSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHVubXV0ZUNoYW5uZWwoY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSl7XG4gICAgICAgIHRoaXMuZ2Fpbk5vZGVzW2NoYW5uZWxdLmdhaW4uc2V0VmFsdWVBdFRpbWUoMSwgdGhpcy5hdWRpb0N0eC5jdXJyZW50VGltZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdm9sdW1lIG9mIGEgY2hhbm5lbCB1c2luZyB0aGUgR2Fpbk5vZGUgZm9yIHRoYXQgY2hhbm5lbC4gRm9yIG1vcmVcbiAgICAgKiBpbmZvcm1hdGlvbiBvbiBHYWluTm9kZXMsIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvR2Fpbk5vZGVcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgYXVkaW8gY2hhbm5lbCB0byBzZXQgdGhlIHZvbHVtZSBmb3JcbiAgICAgKiBAcGFyYW0gdm9sdW1lIFRoZSB2b2x1bWUgb2YgdGhlIGNoYW5uZWwuIDAgaXMgbXV0ZWQuIFZhbHVlcyBiZWxvdyB6ZXJvIHdpbGwgYmUgc2V0IHRvIHplcm8uXG4gICAgICovXG4gICAgc3RhdGljIHNldFZvbHVtZShjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlLCB2b2x1bWU6IG51bWJlcil7XG4gICAgICAgIGlmKHZvbHVtZSA8IDApe1xuICAgICAgICAgICAgdm9sdW1lID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFtID0gQXVkaW9NYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgIGFtLmdhaW5Ob2Rlc1tjaGFubmVsXS5nYWluLnNldFZhbHVlQXRUaW1lKHZvbHVtZSwgYW0uYXVkaW9DdHguY3VycmVudFRpbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEdhaW5Ob2RlIGZvciB0aGlzIGNoYW5uZWwuXG4gICAgICogTGVhcm4gbW9yZSBhYm91dCBHYWluTm9kZXMgaGVyZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvR2Fpbk5vZGVcbiAgICAgKiBET04nVCBVU0UgVEhJUyBVTkxFU1MgWU9VIEtOT1cgV0hBVCBZT1UnUkUgRE9JTkdcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbFxuICAgICAqIEByZXR1cm5zIFRoZSBHYWluTm9kZSBmb3IgdGhlIHNwZWNpZmllZCBjaGFubmVsXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbEdhaW5Ob2RlKGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUpe1xuICAgICAgICByZXR1cm4gdGhpcy5nYWluTm9kZXNbY2hhbm5lbF07XG4gICAgfVxuICAgIFxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICAvLyBQbGF5IGVhY2ggYXVkaW8gY2xpcCByZXF1ZXN0ZWRcbiAgICAgICAgLy8gVE9ETyAtIEFkZCBsb2dpYyB0byBtZXJnZSBzb3VuZHMgaWYgdGhlcmUgYXJlIG11bHRpcGxlIG9mIHRoZSBzYW1lIGtleVxuICAgICAgICB3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKXtcbiAgICAgICAgICAgIGxldCBldmVudCA9IHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfU09VTkQgfHwgZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5QTEFZX01VU0lDIHx8IGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9TRlgpe1xuICAgICAgICAgICAgICAgIGxldCBzb3VuZEtleSA9IGV2ZW50LmRhdGEuZ2V0KFwia2V5XCIpO1xuICAgICAgICAgICAgICAgIGxldCBsb29wID0gZXZlbnQuZGF0YS5nZXQoXCJsb29wXCIpO1xuICAgICAgICAgICAgICAgIGxldCBob2xkUmVmZXJlbmNlID0gZXZlbnQuZGF0YS5nZXQoXCJob2xkUmVmZXJlbmNlXCIpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGNoYW5uZWwgPSBBdWRpb0NoYW5uZWxUeXBlLkRFRkFVTFQ7XG5cbiAgICAgICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfTVVTSUMpe1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsID0gQXVkaW9DaGFubmVsVHlwZS5NVVNJQztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoR2FtZUV2ZW50VHlwZS5QTEFZX1NGWCl7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSBBdWRpb0NoYW5uZWxUeXBlLlNGWDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoZXZlbnQuZGF0YS5oYXMoXCJjaGFubmVsXCIpKXtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCA9IGV2ZW50LmRhdGEuZ2V0KFwiY2hhbm5lbFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlTb3VuZChzb3VuZEtleSwgbG9vcCwgaG9sZFJlZmVyZW5jZSwgY2hhbm5lbCwgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuU1RPUF9TT1VORCl7XG4gICAgICAgICAgICAgICAgbGV0IHNvdW5kS2V5ID0gZXZlbnQuZGF0YS5nZXQoXCJrZXlcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wU291bmQoc291bmRLZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLk1VVEVfQ0hBTk5FTCl7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRlQ2hhbm5lbChldmVudC5kYXRhLmdldChcImNoYW5uZWxcIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlVOTVVURV9DSEFOTkVMKXtcbiAgICAgICAgICAgICAgICB0aGlzLnVubXV0ZUNoYW5uZWwoZXZlbnQuZGF0YS5nZXQoXCJjaGFubmVsXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGVudW0gQXVkaW9DaGFubmVsVHlwZSB7XG4gICAgREVGQVVMVCA9IDAsXG4gICAgU0ZYID0gMSxcbiAgICBNVVNJQyA9IDIsXG4gICAgQ1VTVE9NXzEgPSAzLFxuICAgIENVU1RPTV8yID0gNCxcbiAgICBDVVNUT01fMyA9IDUsXG4gICAgQ1VTVE9NXzQgPSA2LFxuICAgIENVU1RPTV81ID0gNyxcbiAgICBDVVNUT01fNiA9IDgsXG4gICAgQ1VTVE9NXzcgPSA5LFxuICAgIENVU1RPTV84ID0gMTAsXG4gICAgQ1VTVE9NXzkgPSAxMSxcbn1cblxuZXhwb3J0IGNvbnN0IE1BWF9BVURJT19DSEFOTkVMUyA9IDEyOyIsImltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi9VdGlscy9NYXRoVXRpbHNcIjtcbmltcG9ydCBUaW1lck1hbmFnZXIgZnJvbSBcIi4vVGltZXJNYW5hZ2VyXCI7XG5cbi8qKiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcblxuICAgIC8qKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIHRpbWVyICovXG4gICAgcHJvdGVjdGVkIHN0YXRlOiBUaW1lclN0YXRlO1xuICAgIFxuICAgIC8qKiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoaXMgdGltZXIgZW5kcyAqL1xuICAgIHByb3RlY3RlZCBvbkVuZDogRnVuY3Rpb247XG5cbiAgICAvKiogV2hldGhlciBvciBub3QgdGhpcyB0aW1lciBzaG91bGQgbG9vcCAqL1xuICAgIHByb3RlY3RlZCBsb29wOiBib29sZWFuO1xuXG4gICAgLyoqIFRoZSB0b3RhbCBhbW91bnQgb2YgdGltZSB0aGlzIHRpbWVyIHJ1bnMgZm9yICovXG4gICAgcHJvdGVjdGVkIHRvdGFsVGltZTogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBhbW91bnQgb2YgdGltZSBsZWZ0IG9uIHRoZSBjdXJyZW50IHJ1biAqL1xuICAgIHByb3RlY3RlZCB0aW1lTGVmdDogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgdGltZXMgdGhpcyB0aW1lciBoYXMgYmVlbiBydW4gKi9cbiAgICBwcm90ZWN0ZWQgbnVtUnVuczogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IodGltZTogbnVtYmVyLCBvbkVuZD86IEZ1bmN0aW9uLCBsb29wOiBib29sZWFuID0gZmFsc2Upe1xuICAgICAgICAvLyBSZWdpc3RlciB0aGlzIHRpbWVyXG4gICAgICAgIFRpbWVyTWFuYWdlci5nZXRJbnN0YW5jZSgpLmFkZFRpbWVyKHRoaXMpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy50b3RhbFRpbWUgPSB0aW1lO1xuICAgICAgICB0aGlzLnRpbWVMZWZ0ID0gMDtcbiAgICAgICAgdGhpcy5vbkVuZCA9IG9uRW5kO1xuICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xuICAgICAgICB0aGlzLnN0YXRlID0gVGltZXJTdGF0ZS5TVE9QUEVEO1xuICAgICAgICB0aGlzLm51bVJ1bnMgPSAwO1xuICAgIH1cblxuICAgIGlzU3RvcHBlZCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gVGltZXJTdGF0ZS5TVE9QUEVEO1xuICAgIH1cblxuICAgIGlzUGF1c2VkKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBUaW1lclN0YXRlLlBBVVNFRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoaXMgdGltZXIgaGFzIGJlZW4gcnVuIGJlZm9yZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgaXQgaGFzIGJlZW4gcnVuIGF0IGxlYXN0IG9uY2UgKGFmdGVyIHRoZSBsYXRlc3QgcmVzZXQpLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaGFzUnVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1SdW5zID4gMDtcbiAgICB9XG5cbiAgICBzdGFydCh0aW1lPzogbnVtYmVyKXtcbiAgICAgICAgaWYodGltZSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHRoaXMudG90YWxUaW1lID0gdGltZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gVGltZXJTdGF0ZS5BQ1RJVkU7XG4gICAgICAgIHRoaXMudGltZUxlZnQgPSB0aGlzLnRvdGFsVGltZTtcbiAgICB9XG5cbiAgICAvKiogUmVzZXRzIHRoaXMgdGltZXIuIFNldHMgdGhlIHByb2dyZXNzIGJhY2sgdG8gemVybywgYW5kIHNldHMgdGhlIG51bWJlciBvZiBydW5zIGJhY2sgdG8gemVybyAqL1xuICAgIHJlc2V0KCl7XG4gICAgICAgIHRoaXMudGltZUxlZnQgPSB0aGlzLnRvdGFsVGltZTtcbiAgICAgICAgdGhpcy5udW1SdW5zID0gMDtcbiAgICB9XG5cbiAgICBwYXVzZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFRpbWVyU3RhdGUuUEFVU0VEO1xuICAgIH1cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcil7XG4gICAgICAgIGlmKHRoaXMuc3RhdGUgPT09IFRpbWVyU3RhdGUuQUNUSVZFKXtcbiAgICAgICAgICAgIHRoaXMudGltZUxlZnQgLT0gZGVsdGFUKjEwMDA7XG5cbiAgICAgICAgICAgIGlmKHRoaXMudGltZUxlZnQgPD0gMCl7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lTGVmdCA9IE1hdGhVdGlscy5jbGFtcExvdzAodGhpcy50aW1lTGVmdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBlbmQoKXtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzdGF0ZVxuICAgICAgICB0aGlzLnN0YXRlID0gVGltZXJTdGF0ZS5TVE9QUEVEO1xuICAgICAgICB0aGlzLm51bVJ1bnMgKz0gMTtcblxuICAgICAgICAvLyBDYWxsIHRoZSBlbmQgZnVuY3Rpb24gaWYgdGhlcmUgaXMgb25lXG4gICAgICAgIGlmKHRoaXMub25FbmQpe1xuICAgICAgICAgICAgdGhpcy5vbkVuZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vcCBpZiB3ZSB3YW50IHRvXG4gICAgICAgIGlmKHRoaXMubG9vcCl7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gVGltZXJTdGF0ZS5BQ1RJVkU7XG4gICAgICAgICAgICB0aGlzLnRpbWVMZWZ0ID0gdGhpcy50b3RhbFRpbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmd7XG4gICAgICAgIHJldHVybiBcIlRpbWVyOiBcIiArIHRoaXMuc3RhdGUgKyBcIiAtIFRpbWUgTGVmdDogXCIgKyB0aGlzLnRpbWVMZWZ0ICsgXCJtcyBvZiBcIiArIHRoaXMudG90YWxUaW1lICsgXCJtc1wiO1xuICAgIH1cbn1cblxuZXhwb3J0IGVudW0gVGltZXJTdGF0ZSB7XG4gICAgQUNUSVZFID0gXCJBQ1RJVkVcIixcbiAgICBQQVVTRUQgPSBcIlBBVVNFRFwiLFxuICAgIFNUT1BQRUQgPSBcIlNUT1BQRURcIlxufSIsImltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XG5pbXBvcnQgVGltZXIgZnJvbSBcIi4vVGltZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZXJNYW5hZ2VyIGltcGxlbWVudHMgVXBkYXRlYWJsZSB7XG5cbiAgICBwcm90ZWN0ZWQgdGltZXJzOiBBcnJheTxUaW1lcj47XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnRpbWVycyA9IG5ldyBBcnJheSgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzdGF0aWMgaW5zdGFuY2U6IFRpbWVyTWFuYWdlcjtcblxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBUaW1lck1hbmFnZXIge1xuICAgICAgICBpZighdGhpcy5pbnN0YW5jZSl7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFRpbWVyTWFuYWdlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgYWRkVGltZXIodGltZXI6IFRpbWVyKXtcbiAgICAgICAgdGhpcy50aW1lcnMucHVzaCh0aW1lcik7XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lcnMoKXtcbiAgICAgICAgdGhpcy50aW1lcnMgPSBuZXcgQXJyYXkoKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50aW1lcnMuZm9yRWFjaCh0aW1lciA9PiB0aW1lci51cGRhdGUoZGVsdGFUKSk7XG4gICAgfVxufSIsImltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4vTWF0aFV0aWxzXCI7XG5cbi8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIG1vdmVkIHRvIHRoZSBkYXRhdHlwZXMgZm9sZGVyXG4vKipcbiAqIEEgQ29sb3IgdXRpbCBjbGFzcyB0aGF0IGtlZXBzIHRyYWNrIG9mIGNvbG9ycyBsaWtlIGEgdmVjdG9yLCBidXQgY2FuIGJlIGNvbnZlcnRlZCBpbnRvIGEgc3RyaW5nIGZvcm1hdFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvciB7XG5cdC8qKiBUaGUgcmVkIHZhbHVlICovXG5cdHB1YmxpYyByOiBudW1iZXI7XG5cdC8qKiBUaGUgZ3JlZW4gdmFsdWUgKi9cblx0cHVibGljIGc6IG51bWJlcjtcblx0LyoqIFRoZSBibHVlIHZhbHVlICovXG5cdHB1YmxpYyBiOiBudW1iZXI7XG5cdC8qKiBUaGUgYWxwaGEgdmFsdWUgKi9cblx0cHVibGljIGE6IG51bWJlcjtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBjb2xvclxuXHQgKiBAcGFyYW0gciBSZWRcblx0ICogQHBhcmFtIGcgR3JlZW5cblx0ICogQHBhcmFtIGIgQmx1ZVxuXHQgKiBAcGFyYW0gYSBBbHBoYVxuXHQgKi9cblx0Y29uc3RydWN0b3IocjogbnVtYmVyID0gMCwgZzogbnVtYmVyID0gMCwgYjogbnVtYmVyID0gMCwgYTogbnVtYmVyID0gMSl7XG4gICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgIHRoaXMuZyA9IGc7XG4gICAgICAgIHRoaXMuYiA9IGI7XG4gICAgICAgIHRoaXMuYSA9IGE7XG5cdH1cblxuXHQvKipcdFxuXHQgKiBUcmFuc3BhcmVudCBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2JhKDAsIDAsIDAsIDApXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IFRSQU5TUEFSRU5UKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xuXHR9XG5cdFxuXHQvKipcdFxuXHQgKiBSZWQgY29sb3Jcblx0ICogQHJldHVybnMgcmdiKDI1NSwgMCwgMClcblx0ICovXG5cdHN0YXRpYyBnZXQgUkVEKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDI1NSwgMCwgMCwgMSk7XG5cdH1cblxuXHQvKipcdFxuXHQgKiBHcmVlbiBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMCwgMjU1LCAwKVxuXHQgKi9cblx0c3RhdGljIGdldCBHUkVFTigpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAyNTUsIDAsIDEpO1xuXHR9XG5cblx0LyoqXHRcblx0ICogQmx1ZSBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMCwgMCwgMjU1KVxuXHQgKi9cblx0c3RhdGljIGdldCBCTFVFKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDAsIDAsIDI1NSwgMSk7XG5cdH1cblxuXHQvKipcdFxuXHQgKiBZZWxsb3cgY29sb3Jcblx0ICogQHJldHVybnMgcmdiKDI1NSwgMjU1LCAwKVxuXHQgKi9cblx0c3RhdGljIGdldCBZRUxMT1coKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAyNTUsIDAsIDEpO1xuXHR9XG5cblx0LyoqXHRcblx0ICogTWFnZW50YSBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAwLCAyNTUpXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IE1BR0VOVEEoKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAwLCAyNTUsIDEpO1xuXHR9XG5cblx0LyoqXHRcblx0ICogQ3lhbiBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMCwgMjU1LCAyNTUpXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IENZQU4oKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoMCwgMjU1LCAyNTUsIDEpO1xuXHR9XG5cblx0LyoqXHRcblx0ICogV2hpdGUgY29sb3Jcblx0ICogQHJldHVybnMgcmdiKDI1NSwgMjU1LCAyNTUpXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IFdISVRFKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKDI1NSwgMjU1LCAyNTUsIDEpO1xuXHR9IFxuXG5cdC8qKlx0XG5cdCAqIEJsYWNrIGNvbG9yXG5cdCAqIEByZXR1cm5zIHJnYigwLCAwLCAwKVxuXHQgKi9cblx0c3RhdGljIGdldCBCTEFDSygpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAxKTtcblx0fVxuXG5cdC8qKlx0XG5cdCAqIE9yYW5nZSBjb2xvclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAxMDAsIDApXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IE9SQU5HRSgpOiBDb2xvciB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigyNTUsIDEwMCwgMCwgMSk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgY29sb3IgdG8gdGhlIHZhbHVlcyBwcm92aWRlZFxuXHQgKiBAcGFyYW0gciBSZWRcblx0ICogQHBhcmFtIGcgR3JlZW5cblx0ICogQHBhcmFtIGIgQmx1ZVxuXHQgKiBAcGFyYW0gYSBBbHBoYVxuXHQgKi9cblx0c2V0KHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIsIGE6IG51bWJlciA9IDEpOiB2b2lkIHtcblx0XHR0aGlzLnIgPSByO1xuXHRcdHRoaXMuZyA9IGc7XG5cdFx0dGhpcy5iID0gYjtcblx0XHR0aGlzLmEgPSBhO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgY29sb3Igc2xpZ2h0bHkgbGlnaHRlciB0aGFuIHRoZSBjdXJyZW50IGNvbG9yXG5cdCAqIEByZXR1cm5zIEEgbmV3IGxpZ2h0ZXIgQ29sb3Jcblx0ICovXG5cdGxpZ2h0ZW4oKTogQ29sb3Ige1xuXHRcdHJldHVybiBuZXcgQ29sb3IoTWF0aFV0aWxzLmNsYW1wKHRoaXMuciArIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5nICsgNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmIgKyA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuYSArIDEwLCAwLCAyNTUpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbmV3IGNvbG9yIHNsaWdodGx5IGRhcmtlciB0aGFuIHRoZSBjdXJyZW50IGNvbG9yXG5cdCAqIEByZXR1cm5zIEEgbmV3IGRhcmtlciBDb2xvclxuXHQgKi9cblx0ZGFya2VuKCk6IENvbG9yIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKE1hdGhVdGlscy5jbGFtcCh0aGlzLnIgLSA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuZyAtIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5iIC0gNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmEgKyAxMCwgMCwgMjU1KSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoaXMgY29sb3IgYXMgYW4gYXJyYXlcblx0ICogQHJldHVybnMgW3IsIGcsIGIsIGFdXG5cdCAqL1xuXHR0b0FycmF5KCk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcblx0XHRyZXR1cm4gW3RoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYV07XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjb2xvciBhcyBhIHN0cmluZyBvZiB0aGUgZm9ybSAjUlJHR0JCXG5cdCAqIEByZXR1cm5zICNSUkdHQkJcblx0ICovXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIFwiI1wiICsgTWF0aFV0aWxzLnRvSGV4KHRoaXMuciwgMikgKyBNYXRoVXRpbHMudG9IZXgodGhpcy5nLCAyKSArIE1hdGhVdGlscy50b0hleCh0aGlzLmIsIDIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNvbG9yIGFzIGEgc3RyaW5nIG9mIHRoZSBmb3JtIHJnYihyLCBnLCBiKVxuXHQgKiBAcmV0dXJucyByZ2IociwgZywgYilcblx0ICovXG5cdHRvU3RyaW5nUkdCKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIFwicmdiKFwiICsgdGhpcy5yLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLmcudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuYi50b1N0cmluZygpICsgXCIpXCI7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gcmdiYShyLCBnLCBiLCBhKVxuXHQgKiBAcmV0dXJucyByZ2JhKHIsIGcsIGIsIGEpXG5cdCAqL1xuXHR0b1N0cmluZ1JHQkEoKTogc3RyaW5nIHtcblx0XHRpZih0aGlzLmEgPT09IDApe1xuXHRcdFx0cmV0dXJuIHRoaXMudG9TdHJpbmdSR0IoKTtcblx0XHR9XG5cdFx0cmV0dXJuIFwicmdiYShcIiArIHRoaXMuci50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5nLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLmIudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuYS50b1N0cmluZygpICtcIilcIlxuXHR9XG5cblx0LyoqXG5cdCAqIFR1cm5zIHRoaXMgY29sb3IgaW50byBhIGZsb2F0MzJBcnJheSBhbmQgY2hhbmdlcyBjb2xvciByYW5nZSB0byBbMC4wLCAxLjBdXG5cdCAqIEByZXR1cm5zIGEgRmxvYXQzMkFycmF5IGNvbnRhaW5pbmcgdGhlIGNvbG9yXG5cdCAqL1xuXHR0b1dlYkdMKCk6IEZsb2F0MzJBcnJheSB7XG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuXHRcdFx0dGhpcy5yLzI1NSxcblx0XHRcdHRoaXMuZy8yNTUsXG5cdFx0XHR0aGlzLmIvMjU1LFxuXHRcdFx0dGhpcy5hXG5cdFx0XSk7XG5cdH1cblxuXHRzdGF0aWMgZnJvbVN0cmluZ0hleChzdHI6IHN0cmluZyk6IENvbG9yIHtcblx0XHRsZXQgaSA9IDA7XG5cdFx0aWYoc3RyLmNoYXJBdCgwKSA9PSBcIiNcIikgaSs9IDE7XG5cdFx0bGV0IHIgPSBNYXRoVXRpbHMuZnJvbUhleChzdHIuc3Vic3RyaW5nKGksIGkrMikpO1xuXHRcdGxldCBnID0gTWF0aFV0aWxzLmZyb21IZXgoc3RyLnN1YnN0cmluZyhpKzIsIGkrNCkpO1xuXHRcdGxldCBiID0gTWF0aFV0aWxzLmZyb21IZXgoc3RyLnN1YnN0cmluZyhpKzQsIGkrNikpO1xuXHRcdHJldHVybiBuZXcgQ29sb3IociwgZywgYik7XG5cdH1cbn0iLCIvLyBAaWdub3JlUGFnZVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFYXNlRnVuY3Rpb25zIHtcblxuICAgIHN0YXRpYyBlYXNlSW5PdXRTaW5lKHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAtKE1hdGguY29zKE1hdGguUEkgKiB4KSAtIDEpIC8gMjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZWFzZU91dEluU2luZSh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4geCA8IDAuNSA/IC1NYXRoLmNvcyhNYXRoLlBJKih4ICsgMC41KSkvMiA6IC1NYXRoLmNvcyhNYXRoLlBJKih4IC0gMC41KSkvMiArIDE7XG4gICAgfVxuXG4gICAgc3RhdGljIGVhc2VPdXRTaW5lKHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpbigoeCAqIE1hdGguUEkpIC8gMik7XG4gICAgfVxuXG4gICAgc3RhdGljIGVhc2VJblNpbmUoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcygoeCAqIE1hdGguUEkpIC8gMik7IFxuICAgIH1cblxuICAgIHN0YXRpYyBlYXNlSW5PdXRRdWludCh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4geCA8IDAuNSA/IDE2ICogeCAqIHggKiB4ICogeCAqIHggOiAxIC0gTWF0aC5wb3coLTIgKiB4ICsgMiwgNSkgLyAyOyAgICBcbiAgICB9XG5cbiAgICBzdGF0aWMgZWFzZUluT3V0UXVhZCh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4geCA8IDAuNSA/IDIgKiB4ICogeCA6IDEgLSBNYXRoLnBvdygtMiAqIHggKyAyLCAyKSAvIDI7XG4gICAgfVxuXG4gICAgc3RhdGljIGVhc2VPdXRJblF1YWQoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHggPCAwLjUgPyB0aGlzLmVhc2VPdXRJbl9PdXRQb3coeCwgMikgOiB0aGlzLmVhc2VPdXRJbl9JblBvdyh4LCAyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBlYXNlT3V0SW5fT3V0UG93KHg6IG51bWJlciwgcG93OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gMC41IC0gTWF0aC5wb3coLTIgKiB4ICsgMSwgcG93KSAvIDI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZWFzZU91dEluX0luUG93KHg6IG51bWJlciwgcG93OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gMC41ICsgTWF0aC5wb3coMiAqIHggLSAxLCBwb3cpIC8gMjtcbiAgICB9XG59XG5cbmV4cG9ydCBlbnVtIEVhc2VGdW5jdGlvblR5cGUge1xuICAgIC8vIFNJTkVcbiAgICBJTl9PVVRfU0lORSA9IFwiZWFzZUluT3V0U2luZVwiLFxuICAgIE9VVF9JTl9TSU5FID0gXCJlYXNlT3V0SW5TaW5lXCIsXG4gICAgSU5fU0lORSA9IFwiZWFzZUluU2luZVwiLFxuICAgIE9VVF9TSU5FID0gXCJlYXNlT3V0U2luZVwiLFxuXG4gICAgLy8gUVVBRFxuICAgIElOX09VVF9RVUFEID0gXCJlYXNlSW5PdXRRdWFkXCIsXG4gICAgT1VUX0lOX1FVQUQgPSBcImVhc2VPdXRJblF1YWRcIixcblxuICAgIC8vIFFVSU5UXG4gICAgSU5fT1VUX1FVSU5UID0gXCJlYXNlSW5PdXRRdWludFwiXG59IiwiaW1wb3J0IEdyYXBoIGZyb20gXCIuLi9EYXRhVHlwZXMvR3JhcGhzL0dyYXBoXCI7XG5pbXBvcnQgRWRnZU5vZGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvRWRnZU5vZGVcIjtcblxuLyoqIEEgY2xhc3MgdG8gcHJvdmlkZXMgc29tZSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgZ3JhcGhzICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaFV0aWxzIHtcblxuXHQvKipcblx0ICogQW4gaW1wbGVtZW50YXRpb24gb2YgRGppa3N0cmEncyBzaG9ydGVzdCBwYXRoIGFsZ29yaXRobSBiYXNlZCBvbiB0aGUgb25lIGRlc2NyaWJlZCBpbiBUaGUgQWxnb3JpdGhtIERlc2lnbiBNYW51YWwuXG5cdCAqIEBwYXJhbSBnIFRoZSBncmFwaFxuXHQgKiBAcGFyYW0gc3RhcnQgVGhlIG51bWJlciB0byBzdGFydCB0aGUgc2hvcnRlc3QgcGF0aCBmcm9tXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBhcmVudCBvZiBlYWNoIG5vZGUgb2YgdGhlIEdyYXBoIGluIHRoZSBzaG9ydGVzdCBwYXRoLlxuXHQgKi9cblx0c3RhdGljIGRqaWtzdHJhKGc6IEdyYXBoLCBzdGFydDogbnVtYmVyKTogQXJyYXk8bnVtYmVyPiB7XG5cdFx0bGV0IGk6IG51bWJlcjtcdFx0Ly8gQ291bnRlclxuXHRcdGxldCBwOiBFZGdlTm9kZTtcdC8vIFBvaW50ZXIgdG8gZWRnZW5vZGVcblx0XHRsZXQgaW5UcmVlOiBBcnJheTxib29sZWFuPiA9IG5ldyBBcnJheShnLm51bVZlcnRpY2VzKTtcblx0XHRsZXQgZGlzdGFuY2U6IEFycmF5PG51bWJlcj4gPSBuZXcgQXJyYXkoZy5udW1WZXJ0aWNlcyk7XG5cdFx0bGV0IHBhcmVudDogQXJyYXk8bnVtYmVyPiA9IG5ldyBBcnJheShnLm51bVZlcnRpY2VzKTtcblx0XHRsZXQgdjogbnVtYmVyO1x0XHQvLyBDdXJyZW50IHZlcnRleCB0byBwcm9jZXNzXG5cdFx0bGV0IHc6IG51bWJlcjsgXHRcdC8vIENhbmRpZGF0ZSBmb3IgbmV4dCB2ZXJ0ZXhcblx0XHRsZXQgd2VpZ2h0OiBudW1iZXI7XHQvLyBFZGdlIHdlaWdodFxuXHRcdGxldCBkaXN0O1x0XHRcdC8vIEJlc3QgY3VycmVudCBkaXN0YW5jZSBmcm9tIHN0YXJ0XG5cblx0XHRmb3IoaSA9IDA7IGkgPCBnLm51bVZlcnRpY2VzOyBpKyspe1xuXHRcdFx0aW5UcmVlW2ldID0gZmFsc2U7XG5cdFx0XHRkaXN0YW5jZVtpXSA9IEluZmluaXR5O1xuXHRcdFx0cGFyZW50W2ldID0gLTE7XG5cdFx0fVxuXG5cdFx0ZGlzdGFuY2Vbc3RhcnRdID0gMDtcblx0XHR2ID0gc3RhcnQ7XG5cblx0XHR3aGlsZSghaW5UcmVlW3ZdKXtcblx0XHRcdGluVHJlZVt2XSA9IHRydWU7XG5cdFx0XHRwID0gZy5lZGdlc1t2XTtcblxuXHRcdFx0d2hpbGUocCAhPT0gbnVsbCl7XG5cdFx0XHRcdHcgPSBwLnk7XG5cdFx0XHRcdHdlaWdodCA9IHAud2VpZ2h0O1xuXG5cdFx0XHRcdGlmKGRpc3RhbmNlW3ddID4gZGlzdGFuY2Vbdl0gKyB3ZWlnaHQpe1xuXHRcdFx0XHRcdGRpc3RhbmNlW3ddID0gZGlzdGFuY2Vbdl0gKyB3ZWlnaHQ7XG5cdFx0XHRcdFx0cGFyZW50W3ddID0gdjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHAgPSBwLm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdHYgPSAwO1xuXG5cdFx0XHRkaXN0ID0gSW5maW5pdHk7XG5cblx0XHRcdGZvcihpID0gMDsgaSA8PSBnLm51bVZlcnRpY2VzOyBpKyspe1xuXHRcdFx0XHRpZighaW5UcmVlW2ldICYmIGRpc3QgPiBkaXN0YW5jZVtpXSl7XG5cdFx0XHRcdFx0ZGlzdCA9IGRpc3RhbmNlO1xuXHRcdFx0XHRcdHYgPSBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhcmVudDtcblxuXHR9XG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XG5cbi8qKiBBIGNsYXNzIGNvbnRhaW5pbmcgc29tZSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgbWF0aCBvcGVyYXRpb25zICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRoVXRpbHMge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpZ24gb2YgdGhlIHZhbHVlIHByb3ZpZGVkXG4gICAgICogQHBhcmFtIHggVGhlIHZhbHVlIHRvIGV4dHJhY3QgdGhlIHNpZ24gZnJvbVxuICAgICAqIEByZXR1cm5zIC0xIGlmIHRoZSBudW1iZXIgaXMgbGVzcyB0aGFuIDAsIDEgb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3RhdGljIHNpZ24oeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHggPCAwID8gLTEgOiAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgeCBpcyBiZXR3ZWVuIGEgYW5kIGJcbiAgICAgKiBAcGFyYW0gYSBUaGUgbWluIGJvdW5kXG4gICAgICogQHBhcmFtIGIgVGhlIG1heCBib3VuZFxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBjaGVja1xuICAgICAqIEBwYXJhbSBleGNsdXNpdmUgV2hldGhlciBvciBub3QgYSBhbmQgYiBhcmUgZXhjbHVzaXZlIGJvdW5kc1xuICAgICAqIEByZXR1cm5zIFRydWUgaWYgeCBpcyBiZXR3ZWVuIGEgYW5kIGIsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHN0YXRpYyBiZXR3ZWVuKGE6IG51bWJlciwgYjogbnVtYmVyLCB4OiBudW1iZXIsIGV4Y2x1c2l2ZT86IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICAgICAgaWYoZXhjbHVzaXZlKXtcbiAgICAgICAgICAgIHJldHVybiAoYSA8IHgpICYmICh4IDwgYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKGEgPD0geCkgJiYgKHggPD0gYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgdGhlIHZhbHVlIHggdG8gdGhlIHJhbmdlIFttaW4sIG1heF0sIHJvdW5kaW5nIHVwIG9yIGRvd24gaWYgbmVlZGVkXG4gICAgICogQHBhcmFtIHggVGhlIHZhbHVlIHRvIGJlIGNsYW1wZWRcbiAgICAgKiBAcGFyYW0gbWluIFRoZSBtaW4gb2YgdGhlIHJhbmdlXG4gICAgICogQHBhcmFtIG1heCBUaGUgbWF4IG9mIHRoZSByYW5nZVxuICAgICAqIEByZXR1cm5zIHgsIGlmIGl0IGlzIGJldHdlZW4gbWluIGFuZCBtYXgsIG9yIG1pbi9tYXggaWYgaXQgZXhjZWVkcyB0aGVpciBib3VuZHNcbiAgICAgKi9cbiAgICBzdGF0aWMgY2xhbXAoeDogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBpZih4IDwgbWluKSByZXR1cm4gbWluO1xuICAgICAgICBpZih4ID4gbWF4KSByZXR1cm4gbWF4O1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgdGhlIHZhbHVlIHggdG8gdGhlIHJhbmdlIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXG4gICAgICogQHJldHVybnMgeCwgaWYgaXQgaXMgYmV0d2VlbiAwIGFuZCAxLCBvciAwLzEgaWYgaXQgZXhjZWVkcyB0aGVpciBib3VuZHNcbiAgICAgKi9cbiAgICBzdGF0aWMgY2xhbXAwMSh4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aFV0aWxzLmNsYW1wKHgsIDAsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyB0aGUgbG93ZXIgZW5kIG9mIHRoZSB2YWx1ZSBvZiB4IHRvIHRoZSByYW5nZSB0byBtaW5cbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gYmUgY2xhbXBlZFxuICAgICAqIEBwYXJhbSBtaW4gVGhlIG1pbmltdW0gYWxsb3dlZCB2YWx1ZSBvZiB4XG4gICAgICogQHJldHVybnMgeCwgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIG1pbiwgb3RoZXJ3aXNlIG1pblxuICAgICAqL1xuICAgIHN0YXRpYyBjbGFtcExvdyh4OiBudW1iZXIsIG1pbjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHggPCBtaW4gPyBtaW4gOiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyB0aGUgbG93ZXIgZW5kIG9mIHRoZSB2YWx1ZSBvZiB4IHRvIHplcm9cbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gYmUgY2xhbXBlZFxuICAgICAqIEByZXR1cm5zIHgsIGlmIGl0IGlzIGdyZWF0ZXIgdGhhbiAwLCBvdGhlcndpc2UgMFxuICAgICAqL1xuICAgIHN0YXRpYyBjbGFtcExvdzAoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5jbGFtcExvdyh4LCAwKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xhbXBNYWduaXR1ZGUodjogVmVjMiwgbTogbnVtYmVyKTogVmVjMiB7XG4gICAgICAgIGlmKHYubWFnU3EoKSA+IG0qbSl7XG4gICAgICAgICAgICByZXR1cm4gdi5zY2FsZVRvKG0pO1xuICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBjaGFuZ2VSYW5nZSh4OiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciwgbmV3TWluOiBudW1iZXIsIG5ld01heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVycChuZXdNaW4sIG5ld01heCwgdGhpcy5pbnZMZXJwKG1pbiwgbWF4LCB4KSk7XG4gICAgfVxuXG4gICAgLyoqXG5cdCAqIExpbmVhciBJbnRlcnBvbGF0aW9uXG5cdCAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2YWx1ZSBmb3IgdGhlIGludGVycG9sYXRpb24gYm91bmRcblx0ICogQHBhcmFtIGIgVGhlIHNlY29uZCB2YWx1ZSBmb3IgdGhlIGludGVycG9sYXRpb24gYm91bmRcblx0ICogQHBhcmFtIHQgVGhlIHRpbWUgd2UgYXJlIGludGVycG9sYXRpbmcgdG9cbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgYmV0d2VlbiBhIGFuZCBiIGF0IHRpbWUgdFxuXHQgKi9cblx0c3RhdGljIGxlcnAoYTogbnVtYmVyLCBiOiBudW1iZXIsIHQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBhICsgdCAqIChiIC0gYSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52ZXJzZSBMaW5lYXIgSW50ZXJwb2xhdGlvbi4gRmluZHMgdGhlIHRpbWUgYXQgd2hpY2ggYSB2YWx1ZSBiZXR3ZWVuIGEgYW5kIGIgd291bGQgb2NjdXJcbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgZm9yIHRoZSBpbnRlcnBvbGF0aW9uIGJvdW5kXG4gICAgICogQHBhcmFtIGIgVGhlIHNlY29uZCB2YWx1ZSBmb3IgdGhlIGludGVycG9sYXRpb24gYm91bmRcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgKiBAcmV0dXJucyBUaGUgdGltZSBhdCB3aGljaCB0aGUgY3VycmVudCB2YWx1ZSBvY2N1cnMgYmV0d2VlbiBhIGFuZCBiXG4gICAgICovXG4gICAgc3RhdGljIGludkxlcnAoYTogbnVtYmVyLCBiOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpe1xuICAgICAgICByZXR1cm4gKHZhbHVlIC0gYSkvKGIgLSBhKTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQ3V0cyBvZmYgZGVjaW1hbCBwb2ludHMgb2YgYSBudW1iZXIgYWZ0ZXIgYSBzcGVjaWZpZWQgcGxhY2VcbiAgICAgKiBAcGFyYW0gbnVtIFRoZSBudW1iZXIgdG8gZmxvb3JcbiAgICAgKiBAcGFyYW0gcGxhY2UgVGhlIGxhc3QgZGVjaW1hbCBwbGFjZSBvZiB0aGUgbmV3IG51bWJlclxuICAgICAqIEByZXR1cm5zIFRoZSBmbG9vcmVkIG51bWJlclxuICAgICAqL1xuICAgIHN0YXRpYyBmbG9vclRvUGxhY2UobnVtOiBudW1iZXIsIHBsYWNlOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBpZihwbGFjZSA9PT0gMCl7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZhY3RvciA9IDEwO1xuICAgICAgICB3aGlsZShwbGFjZSA+IDEpe1xuICAgICAgICAgICAgZmFjdG9yICE9IDEwO1xuICAgICAgICAgICAgcGxhY2UtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bSpmYWN0b3IpL2ZhY3RvcjtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBudW1iZXIgZnJvbSBhIGhleCBzdHJpbmdcbiAgICAgKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgY29udGFpbmluZyB0aGUgaGV4IG51bWJlclxuICAgICAqIEByZXR1cm5zIHRoZSBudW1iZXIgaW4gZGVjaW1hbCByZXByZXNlbnRlZCBieSB0aGUgaGV4IHN0cmluZ1xuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSGV4KHN0cjogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBhcyBhIGhleGFkZWNpbWFsXG4gICAgICogQHBhcmFtIG51bSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gaGV4XG4gICAgICogQHBhcmFtIG1pbkxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSByZXR1cm5lZCBoZXggc3RyaW5nIChhZGRzIHplcm8gcGFkZGluZyBpZiBuZWVkZWQpXG4gICAgICogQHJldHVybnMgVGhlIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIHRvSGV4KG51bTogbnVtYmVyLCBtaW5MZW5ndGg6IG51bWJlciA9IG51bGwpOiBzdHJpbmcge1xuICAgICAgICBsZXQgZmFjdG9yID0gMTtcbiAgICAgICAgd2hpbGUoZmFjdG9yKjE2IDwgbnVtKXtcbiAgICAgICAgICAgIGZhY3RvciAqPSAxNjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGV4U3RyID0gXCJcIjtcbiAgICAgICAgd2hpbGUoZmFjdG9yID49IDEpe1xuICAgICAgICAgICAgbGV0IGRpZ2l0ID0gTWF0aC5mbG9vcihudW0vZmFjdG9yKTtcbiAgICAgICAgICAgIGhleFN0ciArPSBNYXRoVXRpbHMudG9IZXhEaWdpdChkaWdpdCk7XG4gICAgICAgICAgICBudW0gLT0gZGlnaXQgKiBmYWN0b3I7XG4gICAgICAgICAgICBmYWN0b3IgLz0gMTY7XG5cdFx0fVxuXHRcdFxuXHRcdGlmKG1pbkxlbmd0aCAhPT0gbnVsbCl7XG5cdFx0XHR3aGlsZShoZXhTdHIubGVuZ3RoIDwgbWluTGVuZ3RoKXtcblx0XHRcdFx0aGV4U3RyID0gXCIwXCIgKyBoZXhTdHI7XG5cdFx0XHR9XG5cdFx0fVxuXG4gICAgICAgIHJldHVybiBoZXhTdHI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBkaWdpdCB0byBoZXhhZGVjaW1hbC4gSW4gdGhpcyBjYXNlLCBhIGRpZ2l0IGlzIGJldHdlZW4gMCBhbmQgMTUgaW5jbHVzaXZlXG4gICAgICogQHBhcmFtIG51bSBUaGUgZGlnaXQgdG8gY29udmVydCB0byBoZXhhZGVjaW1hbFxuICAgICAqIEByZXR1cm5zIFRoZSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGRpZ2l0IGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIHRvSGV4RGlnaXQobnVtOiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICBpZihudW0gPCAxMCl7XG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIG51bTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgbnVtIC0gMTApO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuL0NvbG9yXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuL01hdGhVdGlsc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJpbmdVdGlscyB7XG5cdHN0YXRpYyB0b1dlYkdMQ29vcmRzKHBvaW50OiBWZWMyLCBvcmlnaW46IFZlYzIsIHdvcmxkU2l6ZTogVmVjMik6IEZsb2F0MzJBcnJheSB7XG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuXHRcdFx0TWF0aFV0aWxzLmNoYW5nZVJhbmdlKHBvaW50LngsIG9yaWdpbi54LCBvcmlnaW4ueCArIHdvcmxkU2l6ZS54LCAtMSwgMSksXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UocG9pbnQueSwgb3JpZ2luLnksIG9yaWdpbi55ICsgd29ybGRTaXplLnksIDEsIC0xKVxuXHRcdF0pO1xuXHR9XG5cblx0c3RhdGljIHRvV2ViR0xTY2FsZShzaXplOiBWZWMyLCB3b3JsZFNpemU6IFZlYzIpOiBGbG9hdDMyQXJyYXkge1xuXHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcblx0XHRcdDIqc2l6ZS54L3dvcmxkU2l6ZS54LFxuXHRcdFx0MipzaXplLnkvd29ybGRTaXplLnksXG5cdFx0XSk7XG5cdH1cblxuXHRzdGF0aWMgdG9XZWJHTENvbG9yKGNvbG9yOiBDb2xvcik6IEZsb2F0MzJBcnJheSB7XG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuXHRcdFx0TWF0aFV0aWxzLmNoYW5nZVJhbmdlKGNvbG9yLnIsIDAsIDI1NSwgMCwgMSksXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UoY29sb3IuZywgMCwgMjU1LCAwLCAxKSxcblx0XHRcdE1hdGhVdGlscy5jaGFuZ2VSYW5nZShjb2xvci5iLCAwLCAyNTUsIDAsIDEpLFxuXHRcdFx0Y29sb3IuYVxuXHRcdF0pO1xuXHR9XG59IiwiLyoqIFNvbWUgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBzdHJpbmdzICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdVdGlscyB7XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHBhdGggZnJvbSBhIGZpbGVwYXRoIHRoYXQgaW5jbHVkZXMgdGhlIGZpbGVcbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggdGhlIGZpbGVwYXRoIHRvIGV4dHJhY3QgdGhlIHBhdGggZnJvbVxuICAgICAqIEByZXR1cm5zIFRoZSBwYXRoIHBvcnRpb24gb2YgdGhlIGZpbGVwYXRoIHByb3ZpZGVkXG4gICAgICovXG4gICAgc3RhdGljIGdldFBhdGhGcm9tRmlsZVBhdGgoZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGxldCBzcGxpdFBhdGggPSBmaWxlUGF0aC5zcGxpdChcIi9cIik7XG4gICAgICAgIHNwbGl0UGF0aC5wb3AoKTtcbiAgICAgICAgc3BsaXRQYXRoLnB1c2goXCJcIik7XG4gICAgICAgIHJldHVybiBzcGxpdFBhdGguam9pbihcIi9cIik7XG4gICAgfVxufSIsImltcG9ydCBTdGFjayBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1N0YWNrXCI7XG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9FdmVudHMvRW1pdHRlclwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgeyBFZmZlY3REYXRhIH0gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0F0dGFjay9pbnRlcm5hbFwiO1xuaW1wb3J0IFBvaW50QXR0YWNrIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9BdHRhY2svUG9pbnRBdHRhY2tcIjtcbmltcG9ydCB7IFNsaWNlQW5pbWF0aW9uIH0gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0F0dGFja0FuaW1hdGlvbi9TbGljZUFuaW1hdGlvblwiO1xuaW1wb3J0IHsgRWZmZWN0IH0gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0VmZmVjdC9FZmZlY3RcIjtcbmltcG9ydCBCYXR0bGVyQUkgZnJvbSBcIi4vQmF0dGxlckFJXCI7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmVteUFJIGltcGxlbWVudHMgQmF0dGxlckFJIHtcblxuICAgIGF0azogUG9pbnRBdHRhY2s7XG5cbiAgICBhcm1vcjogbnVtYmVyO1xuXG4gICAgZWZmZWN0czogRWZmZWN0PGFueT5bXTtcblxuICAgIGF0a0VmZmVjdDogRWZmZWN0RGF0YTtcblxuICAgIHJvdXRlSW5kZXg6IG51bWJlciA9IDA7XG5cbiAgICBhbGl2ZVR1cnJldHM6IEFycmF5PEFuaW1hdGVkU3ByaXRlPjtcblxuICAgIGZsb29yOiBPcnRob2dvbmFsVGlsZW1hcDtcblxuICAgIGVtaXR0ZXI6IEVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuXG4gICAgLyoqIFRoZSBvd25lciBvZiB0aGlzIEFJICovXG4gICAgb3duZXI6IEFuaW1hdGVkU3ByaXRlO1xuXG4gICAgLyoqIFRoZSB0b3RhbCBwb3NzaWJsZSBhbW91bnQgb2YgaGVhbHRoIHRoaXMgZW50aXR5IGhhcyAqL1xuICAgIG1heEhlYWx0aDogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBjdXJyZW50IGFtb3VudCBvZiBoZWFsdGggdGhpcyBlbnRpdHkgaGFzICovXG4gICAgaGVhbHRoOiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGRlZmF1bHQgbW92ZW1lbnQgc3BlZWQgb2YgdGhpcyBBSSAqL1xuICAgIHNwZWVkOiBudW1iZXIgPSAyMDtcblxuICAgIC8vIFRoZSBjdXJyZW50IGtub3duIHBvc2l0aW9uIG9mIHRoZSBwbGF5ZXJcbiAgICBCYXNlUG9zOiBWZWMyO1xuICAgIFNwYXduUG9zOiBWZWMyO1xuXG4gICAgYWxpdmVXYWxsczogQXJyYXk8QW5pbWF0ZWRTcHJpdGU+O1xuXG4gICAgLy8gQXR0YWNrIHJhbmdlXG4gICAgaW5SYW5nZTogbnVtYmVyO1xuXG4gICAgLy8gUGF0aCB0byBwbGF5ZXJcbiAgICBwYXRoOiBBcnJheTxWZWMyPiA9IFtdO1xuXG4gICAgY3VycmVudFBhdGg6IE5hdmlnYXRpb25QYXRoO1xuXG4gICAgaW5pdGlhbGl6ZUFJKG93bmVyOiBBbmltYXRlZFNwcml0ZSwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XG5cbiAgICAgICAgdGhpcy5tYXhIZWFsdGggPSBvcHRpb25zLmhlYWx0aDtcblxuICAgICAgICB0aGlzLmhlYWx0aCA9IG9wdGlvbnMuaGVhbHRoO1xuXG4gICAgICAgIHRoaXMuQmFzZVBvcyA9IG9wdGlvbnMuQmFzZVBvcztcblxuICAgICAgICB0aGlzLlNwYXduUG9zID0gb3B0aW9ucy5TcGF3blBvcztcblxuICAgICAgICB0aGlzLmFsaXZlV2FsbHMgPSBvcHRpb25zLmFsaXZlV2FsbHM7XG5cbiAgICAgICAgdGhpcy5hbGl2ZVR1cnJldHMgPSBvcHRpb25zLmFsaXZlVHVycmV0cztcblxuICAgICAgICB0aGlzLmZsb29yID0gb3B0aW9ucy5mbG9vcjtcblxuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gdGhpcy5nZXROZXh0UGF0aCgpO1xuXG4gICAgICAgIHRoaXMuYXRrID0gbmV3IFBvaW50QXR0YWNrKDEwLCAzMDAsIG5ldyBTbGljZUFuaW1hdGlvbihDb2xvci5CTEFDSyksIHt9LCBvcHRpb25zLmJhdHRsZU1hbmFnZXIpO1xuXG4gICAgfVxuXG4gICAgYWN0aXZhdGUob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQgeyB9XG5cbiAgICBkYW1hZ2UoZGFtYWdlOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5oZWFsdGggLT0gZGFtYWdlO1xuICAgICAgICAvLyBJZiBoZWFsdGggZ29lcyBiZWxvdyAwLCBkaXNhYmxlIEFJIGFuZCBmaXJlIGVuZW15RGllZCBldmVudFxuICAgICAgICBpZiAodGhpcy5oZWFsdGggPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5vd25lci5zZXRBSUFjdGl2ZShmYWxzZSwge30pO1xuICAgICAgICAgICAgdGhpcy5vd25lci5pc0NvbGxpZGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub3duZXIudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChcImVuZW15RGllZFwiLCB7IG93bmVyOiB0aGlzLm93bmVyIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb3ZlT25lUGF0aChkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5pc0RvbmUoKSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IHRoaXMuZ2V0TmV4dFBhdGgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0a0lmUGF0aEJsb2NrZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub3duZXIubW92ZU9uUGF0aCh0aGlzLnNwZWVkICogZGVsdGFULCB0aGlzLmN1cnJlbnRQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldE5leHRQYXRoKCk6IE5hdmlnYXRpb25QYXRoIHtcbiAgICAgICAgbGV0IHN0YWNrID0gbmV3IFN0YWNrPFZlYzI+KCk7XG4gICAgICAgIHRoaXMuZmluZFBhdGgoKTtcbiAgICAgICAgc3RhY2sucHVzaCh0aGlzLnBhdGhbdGhpcy5yb3V0ZUluZGV4XSk7XG4gICAgICAgIGxldCBwYXRoID0gbmV3IE5hdmlnYXRpb25QYXRoKHN0YWNrKTtcbiAgICAgICAgdGhpcy5yb3V0ZUluZGV4ID0gdGhpcy5yb3V0ZUluZGV4ICsgMTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgYXRrSWZQYXRoQmxvY2tlZCgpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSBWZWMyLlVQLmFuZ2xlVG9DQ1codGhpcy5jdXJyZW50UGF0aC5nZXRNb3ZlRGlyZWN0aW9uKHRoaXMub3duZXIpKTtcbiAgICAgICAgY29uc3QgdGlsZVBvc2l0aW9uID0gdGhpcy5mbG9vci5nZXRDb2xSb3dBdCh0aGlzLm93bmVyLnBvc2l0aW9uKTtcbiAgICAgICAgY29uc29sZS5sb2cocm90YXRpb24pO1xuICAgICAgICBpZiAoKHJvdGF0aW9uID49IC0wLjUgJiYgcm90YXRpb24gPCAwLjcpIHx8IHJvdGF0aW9uID4gNS41KSB7XG4gICAgICAgICAgICB0aWxlUG9zaXRpb24uYWRkKG5ldyBWZWMyKDAsIC0xKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm90YXRpb24gPiAwLjkgJiYgcm90YXRpb24gPCAyLjMpIHtcbiAgICAgICAgICAgIHRpbGVQb3NpdGlvbi5hZGQobmV3IFZlYzIoLTEsIDApKVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJvdGF0aW9uID4gMi40ICYmIHJvdGF0aW9uIDwgMy44KSB7XG5cbiAgICAgICAgICAgIHRpbGVQb3NpdGlvbi5hZGQobmV3IFZlYzIoMCwgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJvdGF0aW9uID4gNCAmJiByb3RhdGlvbiA8IDUuNCkge1xuICAgICAgICAgICAgdGlsZVBvc2l0aW9uLmFkZChuZXcgVmVjMigxLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1vdmluZyBpbiBpbXBvc3NpYmxlIHdheXNcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWxpdmVUdXJyZXRzLnNvbWUoKGUpID0+IHRoaXMuZmxvb3IuZ2V0Q29sUm93QXQoZS5wb3NpdGlvbikuZXF1YWxzKHRpbGVQb3NpdGlvbikpKSB7XG4gICAgICAgICAgICB0aGlzLmF0ay5hdHRhY2sodGhpcywgdGhpcy5hbGl2ZVR1cnJldHMuZmluZCgoZSkgPT4gdGhpcy5mbG9vci5nZXRDb2xSb3dBdChlLnBvc2l0aW9uKS5lcXVhbHModGlsZVBvc2l0aW9uKSkuYWkgYXMgQmF0dGxlckFJKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFsaXZlV2FsbHMuc29tZSgoZSkgPT4gdGhpcy5mbG9vci5nZXRDb2xSb3dBdChlLnBvc2l0aW9uKS5lcXVhbHModGlsZVBvc2l0aW9uKSkpIHtcbiAgICAgICAgICAgIHRoaXMuYXRrLmF0dGFjayh0aGlzLCB0aGlzLmFsaXZlV2FsbHMuZmluZCgoZSkgPT4gdGhpcy5mbG9vci5nZXRDb2xSb3dBdChlLnBvc2l0aW9uKS5lcXVhbHModGlsZVBvc2l0aW9uKSkuYWkgYXMgQmF0dGxlckFJKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZpbmRQYXRoKCkge1xuICAgICAgICBjb25zdCB0dXJucG9pbnQgPSBuZXcgVmVjMih0aGlzLlNwYXduUG9zLngsIHRoaXMuQmFzZVBvcy55KTtcbiAgICAgICAgdGhpcy5wYXRoLnB1c2godHVybnBvaW50LmNsb25lKCkpO1xuICAgICAgICB0aGlzLnBhdGgucHVzaCh0aGlzLkJhc2VQb3MuY2xvbmUoKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcikge1xuICAgICAgICBpZiAoIXRoaXMucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZFBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW92ZU9uZVBhdGgoZGVsdGFUKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZEVmZmVjdChlZmZlY3Q6IEVmZmVjdDxhbnk+KTogdm9pZCB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyID0gdGhpcy5lZmZlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKGN1cnIudHlwZSA9PT0gZWZmZWN0LnR5cGUgJiYgY3Vyci5pc0FjdGl2ZSgpICYmIGN1cnIuZXF1YWwoZWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIGN1cnIucmVmcmVzaEVmZmVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgICAgICBlZmZlY3QuYXBwbHlFZmZlY3QoKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG59XG5cbmV4cG9ydCBlbnVtIEVuZW15U3RhdGVzIHtcbiAgICBERUZBVUxUID0gXCJkZWZhdWx0XCJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9FdmVudHMvRW1pdHRlclwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9FdmVudHMvUmVjZWl2ZXJcIjtcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9VdGlscy9Db2xvclwiO1xuaW1wb3J0IEFPRUF0dGFjayBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvQXR0YWNrL0FPRUF0dGFja1wiO1xuaW1wb3J0IHsgRWZmZWN0RGF0YSB9IGZyb20gXCIuLi9HYW1lU3lzdGVtcy9BdHRhY2svaW50ZXJuYWxcIjtcbmltcG9ydCBQb2ludEF0dGFjayBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvQXR0YWNrL1BvaW50QXR0YWNrXCI7XG5pbXBvcnQgeyBCdWxsZXRBbmltYXRpb24gfSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvQXR0YWNrQW5pbWF0aW9uL0J1bGxldEFuaW1hdGlvblwiO1xuaW1wb3J0IHsgRWZmZWN0IH0gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0VmZmVjdC9FZmZlY3RcIjtcbmltcG9ydCB4ZW5vX2xldmVsIGZyb20gXCIuLi9TY2VuZXMveGVub19sZXZlbFwiO1xuaW1wb3J0IEJhdHRsZXJBSSBmcm9tIFwiLi9CYXR0bGVyQUlcIjtcbmltcG9ydCBVcGdyYWRlYWJsZSBmcm9tIFwiLi9VcGdyYWRhYmxlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR1cnJldEFJIGltcGxlbWVudHMgQmF0dGxlckFJLCBVcGdyYWRlYWJsZSB7XG5cbiAgICBhcm1vcjogbnVtYmVyO1xuXG4gICAgcmFuZ2U6IG51bWJlciA9IDMwMDtcblxuICAgIHNwZWVkOiBudW1iZXI7XG5cbiAgICBvd25lcjogQW5pbWF0ZWRTcHJpdGU7XG5cbiAgICBoZWFsdGg6IG51bWJlcjtcblxuICAgIHRhcmdldDogQmF0dGxlckFJO1xuXG4gICAgZWZmZWN0czogRWZmZWN0PGFueT5bXTtcblxuICAgIGF0a0VmZmVjdDogRWZmZWN0RGF0YTtcblxuICAgIGVtaXR0ZXI6IEVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuXG4gICAgYXRrOiBQb2ludEF0dGFjaztcblxuICAgIGRhbWFnZShkYW1hZ2U6IG51bWJlcikge1xuICAgICAgICB0aGlzLmhlYWx0aCAtPSBkYW1hZ2U7XG4gICAgICAgIGlmICh0aGlzLmhlYWx0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm93bmVyLnNldEFJQWN0aXZlKGZhbHNlLCB7fSk7XG4gICAgICAgICAgICB0aGlzLm93bmVyLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vd25lci52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KFwidHVycmV0RGllZFwiLCB7IG93bmVyOiB0aGlzLm93bmVyIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZUFJKG93bmVyOiBBbmltYXRlZFNwcml0ZSwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgICAgIHRoaXMuaGVhbHRoID0gMjA7XG4gICAgICAgIHRoaXMub3duZXIuYW5pbWF0aW9uLnBsYXlJZk5vdEFscmVhZHkoJ0lETEUnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5hdGsgPSBuZXcgUG9pbnRBdHRhY2soMTAsIDEwMDAsIG5ldyBCdWxsZXRBbmltYXRpb24oQ29sb3IuWUVMTE9XKSwge30sIG9wdGlvbnMuYmF0dGxlTWFuYWdlcik7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuXG4gICAgYWN0aXZhdGUob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG5cbiAgICBoYW5kbGVFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XG5cbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSAodGhpcy5vd25lci5nZXRTY2VuZSgpIGFzIHhlbm9fbGV2ZWwpLmZpbmRFbmVteUluUmFuZ2UodGhpcy5vd25lci5wb3NpdGlvbiwgdGhpcy5yYW5nZSk7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgbG9va0RpciA9IHRoaXMub3duZXIucG9zaXRpb24uZGlyVG8odGhpcy50YXJnZXQub3duZXIucG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5hdGsuYXR0YWNrKHRoaXMsIHRoaXMudGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMub3duZXIucm90YXRpb24gPSBWZWMyLlVQLmFuZ2xlVG9DQ1cobG9va0Rpcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGdyYWRlKCk6IHZvaWQge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG5cbiAgICBhZGRFZmZlY3QoZWZmZWN0OiBFZmZlY3Q8YW55Pik6IHZvaWQge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZWZmZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VyciA9IHRoaXMuZWZmZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChjdXJyLnR5cGUgPT09IGVmZmVjdC50eXBlICYmIGN1cnIuaXNBY3RpdmUoKSAmJiBjdXJyLmVxdWFsKGVmZmVjdCkpIHtcbiAgICAgICAgICAgICAgICBjdXJyLnJlZnJlc2hFZmZlY3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICAgICAgZWZmZWN0LmFwcGx5RWZmZWN0KCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlRWZmZWN0KGlkOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gdGhpcy5lZmZlY3RzLmZpbHRlcigoZSkgPT4gZS5pZCAhPT0gaWQpO1xuICAgIH1cblxufSIsImltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9FdmVudHMvRW1pdHRlclwiO1xuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XG5pbXBvcnQgeyBXQUxMX1RZUEUgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgQU9FQXR0YWNrIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9BdHRhY2svQU9FQXR0YWNrXCI7XG5pbXBvcnQgeyBFZmZlY3REYXRhIH0gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0F0dGFjay9pbnRlcm5hbFwiO1xuaW1wb3J0IFBvaW50QXR0YWNrIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9BdHRhY2svUG9pbnRBdHRhY2tcIjtcbmltcG9ydCB7IEVmZmVjdCB9IGZyb20gXCIuLi9HYW1lU3lzdGVtcy9FZmZlY3QvRWZmZWN0XCI7XG5pbXBvcnQgQmF0dGxlckFJIGZyb20gXCIuL0JhdHRsZXJBSVwiO1xuaW1wb3J0IFVwZ3JhZGVhYmxlIGZyb20gXCIuL1VwZ3JhZGFibGVcIjtcblxuZXhwb3J0IGVudW0gTkVJR0hCT1Ige1xuICAgIExFRlQsXG4gICAgUklHSFQsXG4gICAgVE9QLFxuICAgIEJPVFxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdhbGxBSSBpbXBsZW1lbnRzIEJhdHRsZXJBSSwgVXBncmFkZWFibGUge1xuICAgIHNwZWVkOiBudW1iZXI7XG4gICAgYXJtb3I6IG51bWJlcjtcbiAgICBlZmZlY3RzOiBFZmZlY3Q8YW55PltdO1xuICAgIGF0a0VmZmVjdDogRWZmZWN0RGF0YTtcbiAgICBhdGs6IFBvaW50QXR0YWNrIHwgQU9FQXR0YWNrO1xuICAgIFxuXG5cbiAgICBvd25lcjogQW5pbWF0ZWRTcHJpdGU7XG4gICAgaGVhbHRoOiBudW1iZXI7XG4gICAgbmVpZ2hib3JpbmdXYWxsOiBBcnJheTxBbmltYXRlZFNwcml0ZT4gPSBuZXcgQXJyYXkoNCk7XG4gICAgbmVpZ2hib3JOdW06IG51bWJlcjtcbiAgICB0eXBlOiBXQUxMX1RZUEVcbiAgICBzaGFwZTogc3RyaW5nXG4gICAgZW1pdHRlcjogRW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG5cblxuICAgIGRhbWFnZShkYW1hZ2U6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmhlYWx0aCAtPSBkYW1hZ2U7IFxuXG4gICAgICAgIGlmICh0aGlzLmhlYWx0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm93bmVyLnNldEFJQWN0aXZlKGZhbHNlLCB7fSk7XG4gICAgICAgICAgICB0aGlzLm93bmVyLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5vd25lci52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KFwid2FsbERpZWRcIiwge293bmVyOiB0aGlzLm93bmVyfSk7IFxuICAgICAgICB9XG5cbiAgICB9XG5cblxuICAgIGluaXRpYWxpemVBSShvd25lcjogQW5pbWF0ZWRTcHJpdGUsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLmhlYWx0aCA9IDEwMDsgXG4gICAgICAgIHRoaXMudHlwZSA9IFdBTExfVFlQRS5ESVJUXG4gICAgICAgIHRoaXMubmVpZ2hib3JpbmdXYWxsW05FSUdIQk9SLkxFRlRdID0gb3B0aW9ucy5sZWZ0VGlsZTtcbiAgICAgICAgdGhpcy5uZWlnaGJvcmluZ1dhbGxbTkVJR0hCT1IuUklHSFRdID0gb3B0aW9ucy5yaWdodFRpbGU7XG4gICAgICAgIHRoaXMubmVpZ2hib3JpbmdXYWxsW05FSUdIQk9SLlRPUF0gPSBvcHRpb25zLnRvcFRpbGU7XG4gICAgICAgIHRoaXMubmVpZ2hib3JpbmdXYWxsW05FSUdIQk9SLkJPVF0gPSBvcHRpb25zLmJvdFRpbGU7XG4gICAgICAgIHRoaXMubmVpZ2hib3JOdW0gPSB0aGlzLm5laWdoYm9yaW5nV2FsbC5maWx0ZXIoKGUpID0+ICEhZSkubGVuZ3RoO1xuICAgICAgICB0aGlzLnVwZGF0ZVNoYXBlKCk7IFxuICAgIH1cblxuICAgIGFkZE5laWdoYm9yKHc6IEFuaW1hdGVkU3ByaXRlLCBkaXI6IE5FSUdIQk9SKSB7XG4gICAgICAgIHRoaXMubmVpZ2hib3JpbmdXYWxsW2Rpcl0gPSB3OyBcbiAgICAgICAgdGhpcy5uZWlnaGJvck51bSsrO1xuICAgICAgICB0aGlzLnVwZGF0ZVNoYXBlKCk7XG4gICAgfVxuXG4gICAgZGVsTmVpZ2hib3IoZGlyOiBORUlHSEJPUikge1xuICAgICAgICB0aGlzLm5laWdoYm9yaW5nV2FsbFtkaXJdID0gbnVsbDsgXG4gICAgICAgIHRoaXMubmVpZ2hib3JOdW0tLTtcbiAgICAgICAgdGhpcy51cGRhdGVTaGFwZSgpOyBcbiAgICB9XG5cbiAgICB1cGRhdGVTaGFwZSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSBXYWxsQUkuZ2V0V2FsbFNoYXBlKFxuICAgICAgICAgICAgdGhpcy5uZWlnaGJvcmluZ1dhbGxbTkVJR0hCT1IuTEVGVF0sXG4gICAgICAgICAgICB0aGlzLm5laWdoYm9yaW5nV2FsbFtORUlHSEJPUi5SSUdIVF0sXG4gICAgICAgICAgICB0aGlzLm5laWdoYm9yaW5nV2FsbFtORUlHSEJPUi5CT1RdLFxuICAgICAgICAgICAgdGhpcy5uZWlnaGJvcmluZ1dhbGxbTkVJR0hCT1IuVE9QXSxcbiAgICAgICAgICAgIHRoaXMubmVpZ2hib3JOdW1cbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zaGFwZSA9IG5ld1NoYXBlO1xuICAgICAgICB0aGlzLm93bmVyLmFuaW1hdGlvbi5wbGF5KGAke3RoaXMudHlwZX1fJHtuZXdTaGFwZX1gLCB0cnVlKTtcbiAgICB9XG5cbiAgICB1cGdyYWRlKCk6IHZvaWQge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBXQUxMX1RZUEUuRElSVDpcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBXQUxMX1RZUEUuV09PRDtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWx0aCA9IDIgKiAxMDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdBTExfVFlQRS5XT09EOlxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFdBTExfVFlQRS5TVE9ORTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWx0aCA9IDMgKiAxMDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdBTExfVFlQRS5TVE9ORTpcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBXQUxMX1RZUEUuRklCRVI7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFsdGggPSA0ICogMTAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXQUxMX1RZUEUuRklCRVI6XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vd25lci5hbmltYXRpb24ucGxheShgJHt0aGlzLnR5cGV9XyR7dGhpcy5zaGFwZX1gLCB0cnVlKTtcbiAgICB9XG5cblxuICAgIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cblxuICAgIGFjdGl2YXRlKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuXG4gICAgaGFuZGxlRXZlbnQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgYWRkRWZmZWN0KGVmZmVjdDogRWZmZWN0PGFueT4pOiB2b2lkIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuXG4gICAgcmVtb3ZlRWZmZWN0KGlkOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gdGhpcy5lZmZlY3RzLmZpbHRlcigoZSkgPT4gZS5pZCAhPT0gaWQpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRXYWxsU2hhcGUoXG4gICAgICAgIGxlZnQ6IEFuaW1hdGVkU3ByaXRlLFxuICAgICAgICByaWdodDogQW5pbWF0ZWRTcHJpdGUsXG4gICAgICAgIGJvdDogQW5pbWF0ZWRTcHJpdGUsXG4gICAgICAgIHRvcDogQW5pbWF0ZWRTcHJpdGUsXG4gICAgICAgIG51bTogbnVtYmVyXG4gICAgKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKG51bSA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuICdDUk9TU1JPQUQnXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVtID09PSAzKSB7XG4gICAgICAgICAgICBpZiAoIWxlZnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdSVFJJJztcbiAgICAgICAgICAgIGlmICghcmlnaHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdMVFJJJztcbiAgICAgICAgICAgIGlmICghdG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiAnQlRSSSc7XG4gICAgICAgICAgICBpZiAoIWJvdClcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1RUUkknXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVtID09PSAyKSB7XG4gICAgICAgICAgICBpZiAoIWxlZnQgJiYgIXJpZ2h0KVxuICAgICAgICAgICAgICAgIHJldHVybiAnVkVSVElDQUwnXG4gICAgICAgICAgICBpZiAoIXRvcCAmJiAhYm90KVxuICAgICAgICAgICAgICAgIHJldHVybiAnSE9SSVpPTlRBTCdcbiAgICAgICAgICAgIGlmICghbGVmdCAmJiAhdG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiAnUkJUVVJOJ1xuICAgICAgICAgICAgaWYgKCFsZWZ0ICYmICFib3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdSVFRVUk4nXG4gICAgICAgICAgICBpZiAoIXJpZ2h0ICYmICF0b3ApXG4gICAgICAgICAgICAgICAgcmV0dXJuICdMQlRVUk4nXG4gICAgICAgICAgICBpZiAoIXJpZ2h0ICYmICFib3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdMVFRVUk4nXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVtID09PSAxKSB7XG4gICAgICAgICAgICBpZiAobGVmdCB8fCByaWdodClcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0hPUklaT05UQUwnXG4gICAgICAgICAgICBpZiAodG9wIHx8IGJvdClcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1ZFUlRJQ0FMJ1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdIT1JJWk9OVEFMJ1xuICAgIH1cblxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9FbWl0dGVyXCI7XG5pbXBvcnQgVGltZXIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL1RpbWluZy9UaW1lclwiO1xuaW1wb3J0IEJhdHRsZXJBSSBmcm9tIFwiLi4vLi4vQUkvQmF0dGxlckFJXCI7XG5pbXBvcnQgeyBYRU5PX0VGRkVDVF9UWVBFIH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IEF0a0FuaW1hdGlvbiBmcm9tIFwiLi4vQXR0YWNrQW5pbWF0aW9uL0F0a0FuaW1hdGlvblwiO1xuaW1wb3J0IHsgQnVsbGV0QW5pbWF0aW9uIH0gZnJvbSBcIi4uL0F0dGFja0FuaW1hdGlvbi9CdWxsZXRBbmltYXRpb25cIjtcbmltcG9ydCB7IFNsaWNlQW5pbWF0aW9uIH0gZnJvbSBcIi4uL0F0dGFja0FuaW1hdGlvbi9TbGljZUFuaW1hdGlvblwiO1xuaW1wb3J0IEJhdHRsZU1hbmFnZXIgZnJvbSBcIi4uL0JhdHRsZU1hbmFnZXJcIjtcbmltcG9ydCB7IEFjaWRFZmZlY3QgfSBmcm9tIFwiLi4vRWZmZWN0L0FjaWRFZmZlY3RcIjtcbmltcG9ydCB7IEVmZmVjdCB9IGZyb20gXCIuLi9FZmZlY3QvRWZmZWN0XCI7XG5pbXBvcnQgeyBGaXJlRWZmZWN0IH0gZnJvbSBcIi4uL0VmZmVjdC9GaXJlRWZmZWNcIjtcbmltcG9ydCB7IFNsb3dFZmZlY3QgfSBmcm9tIFwiLi4vRWZmZWN0L1Nsb3dFZmZlY3RcIjtcbmltcG9ydCB7IEVmZmVjdERhdGEgfSBmcm9tIFwiLi9pbnRlcm5hbFwiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50QXR0YWNrIHtcblxuICAgIGJhdHRsZU1hbmFnZXI6IEJhdHRsZU1hbmFnZXJcblxuICAgIGFzc2V0czogQXJyYXk8YW55PjtcblxuICAgIGRhbWFnZTogbnVtYmVyO1xuXG4gICAgY29vbGRvd25UaW1lcjogVGltZXI7XG5cbiAgICBlZmZlY3RzOiBFZmZlY3REYXRhXG5cbiAgICBhdGtBbmltYXRpb246IEF0a0FuaW1hdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKGRhbWFnZTogbnVtYmVyLCBjb29sZG93bjogbnVtYmVyLCBhdGtBbmltYXRpb246IEF0a0FuaW1hdGlvbiwgZWZmZWN0czogRWZmZWN0RGF0YSwgYmF0dGxlTWFuYWdlcjogQmF0dGxlTWFuYWdlcikge1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xuICAgICAgICB0aGlzLmRhbWFnZSA9IGRhbWFnZTtcbiAgICAgICAgdGhpcy5jb29sZG93blRpbWVyID0gbmV3IFRpbWVyKGNvb2xkb3duKTtcbiAgICAgICAgdGhpcy5hdGtBbmltYXRpb24gPSBhdGtBbmltYXRpb247XG4gICAgICAgIHRoaXMuYmF0dGxlTWFuYWdlciA9IGJhdHRsZU1hbmFnZXI7XG4gICAgfVxuXG4gICAgYXR0YWNrKGZyb206IEJhdHRsZXJBSSwgdG86IEJhdHRsZXJBSSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIXRoaXMuY29vbGRvd25UaW1lci5pc1N0b3BwZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXNzZXRzID0gdGhpcy5hdGtBbmltYXRpb24uY3JlYXRlUmVxdWlyZWRBc3NldHMoZnJvbS5vd25lci5nZXRTY2VuZSgpKTtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5hc3NldHMpO1xuXG4gICAgICAgIGlmICh0aGlzLmF0a0FuaW1hdGlvbiBpbnN0YW5jZW9mIEJ1bGxldEFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hdGtBbmltYXRpb24uZG9BbmltYXRpb24oZnJvbS5vd25lci5wb3NpdGlvbiwgdG8ub3duZXIucG9zaXRpb24sIHRoaXMuYXNzZXRzWzBdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmF0a0FuaW1hdGlvbiBpbnN0YW5jZW9mIFNsaWNlQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmF0a0FuaW1hdGlvbi5kb0FuaW1hdGlvbihmcm9tLm93bmVyLnBvc2l0aW9uLCBmcm9tLm93bmVyLnBvc2l0aW9uLmRpclRvKHRvLm93bmVyLnBvc2l0aW9uKSwgdGhpcy5hc3NldHNbMF0sIGZyb20ub3duZXIucm90YXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5iYXR0bGVNYW5hZ2VyLmhhbmRsZVBvaW50QXRrKHRvLCB0aGlzLmRhbWFnZSwgdGhpcy5lZmZlY3RzKTsgXG5cbiAgICAgICAgdGhpcy5jb29sZG93blRpbWVyLnN0YXJ0KCk7IFxuICAgIH1cblxufSIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgQXRrQW5pbWF0aW9uIHtcblxuICAgIGFic3RyYWN0IGRvQW5pbWF0aW9uKC4uLmFyZ3M6IGFueSk6IHZvaWQ7XG5cbiAgICBhYnN0cmFjdCBjcmVhdGVSZXF1aXJlZEFzc2V0cyhzY2VuZTogU2NlbmUpOiBBcnJheTxhbnk+O1xuXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgeyBUd2VlbmFibGVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgeyBHcmFwaGljVHlwZSB9IGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXNcIjtcbmltcG9ydCBMaW5lIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgeyBFYXNlRnVuY3Rpb25UeXBlIH0gZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL1V0aWxzL0Vhc2VGdW5jdGlvbnNcIjtcbmltcG9ydCB7IFhFTk9fRVZFTlRTIH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IEF0a0FuaW1hdGlvbiBmcm9tIFwiLi9BdGtBbmltYXRpb25cIjtcblxuZXhwb3J0IGNsYXNzIEJ1bGxldEFuaW1hdGlvbiBleHRlbmRzIEF0a0FuaW1hdGlvbiB7XG5cblxuICAgIHByaXZhdGUgY29sb3I6IENvbG9yO1xuXG4gICAgY29uc3RydWN0b3IoY29sb3I6IENvbG9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB9XG5cbiAgICBkb0FuaW1hdGlvbihmcm9tOiBWZWMyLCB0bzogVmVjMiwgbGluZTogTGluZSk6IHZvaWQge1xuICAgICAgICBsaW5lLnN0YXJ0ID0gZnJvbTtcbiAgICAgICAgbGluZS5lbmQgPSB0bztcblxuICAgICAgICBsaW5lLnR3ZWVucy5wbGF5KFwiZmFkZVwiKTtcbiAgICB9XG5cbiAgICBjcmVhdGVSZXF1aXJlZEFzc2V0cyhzY2VuZTogU2NlbmUpOiBMaW5lW10ge1xuICAgICAgICBsZXQgbGluZSA9IDxMaW5lPnNjZW5lLmFkZC5ncmFwaGljKEdyYXBoaWNUeXBlLkxJTkUsIFwicHJpbWFyeVwiLCB7IHN0YXJ0OiBuZXcgVmVjMigtMSwgMSksIGVuZDogbmV3IFZlYzIoLTEsIC0xKSB9KTtcbiAgICAgICAgbGluZS5jb2xvciA9IHRoaXMuY29sb3I7XG5cbiAgICAgICAgbGluZS50d2VlbnMuYWRkKFwiZmFkZVwiLCB7XG4gICAgICAgICAgICBzdGFydERlbGF5OiAwLFxuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIGVmZmVjdHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBUd2VlbmFibGVQcm9wZXJ0aWVzLmFscGhhLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogMSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICAgICAgICAgICAgICBlYXNlOiBFYXNlRnVuY3Rpb25UeXBlLk9VVF9TSU5FXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG9uRW5kOiBYRU5PX0VWRU5UUy5VTkxPQURfQVNTRVRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFtsaW5lXTtcbiAgICB9XG5cblxuXG4gICAgY2xvbmUoKTogQXRrQW5pbWF0aW9uIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWxsZXRBbmltYXRpb24odGhpcy5jb2xvcik7XG4gICAgfVxuXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBBdGtBbmltYXRpb24gZnJvbSBcIi4vQXRrQW5pbWF0aW9uXCI7XG5cbmV4cG9ydCBjbGFzcyBTbGljZUFuaW1hdGlvbiBleHRlbmRzIEF0a0FuaW1hdGlvbiB7XG5cblxuICAgIHByaXZhdGUgY29sb3I6IENvbG9yO1xuXG4gICAgY29uc3RydWN0b3IoY29sb3I6IENvbG9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB9XG5cbiAgICBkb0FuaW1hdGlvbihmcm9tOiBWZWMyLCBkaXJlY3Rpb246IFZlYzIsIHNsaWNlU3ByaXRlOiBBbmltYXRlZFNwcml0ZSwgcm90YXRpb246IG51bWJlcik6IHZvaWQge1xuXG4gICAgICAgIC8vIHNsaWNlU3ByaXRlLnJvdGF0aW9uID0gcm90YXRpb247XG5cbiAgICAgICAgc2xpY2VTcHJpdGUucG9zaXRpb24gPSBmcm9tLmNsb25lKCkuYWRkKG5ldyBWZWMyKDE2LCAxNikpO1xuXG4gICAgICAgIHNsaWNlU3ByaXRlLmFuaW1hdGlvbi5wbGF5KFwiU0xJQ0VcIik7XG4gICAgICAgIHNsaWNlU3ByaXRlLmFuaW1hdGlvbi5xdWV1ZShcIk5PUk1BTFwiLCB0cnVlKTtcblxuICAgIH1cblxuICAgIGNyZWF0ZVJlcXVpcmVkQXNzZXRzKHNjZW5lOiBTY2VuZSk6IFtBbmltYXRlZFNwcml0ZV0ge1xuICAgICAgICBsZXQgc2xpY2UgPSBzY2VuZS5hZGQuYW5pbWF0ZWRTcHJpdGUoXCJzbGljZVwiLCBcInByaW1hcnlcIik7XG4gICAgICAgIHNsaWNlLmFuaW1hdGlvbi5wbGF5KFwiTk9STUFMXCIsIHRydWUpO1xuICAgICAgICBjb25zb2xlLmxvZyhzbGljZSk7XG4gICAgICAgIHJldHVybiBbc2xpY2VdO1xuICAgIH1cblxuICAgIGNsb25lKCk6IEF0a0FuaW1hdGlvbiB7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2VBbmltYXRpb24odGhpcy5jb2xvcik7XG4gICAgfVxuXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCBCYXR0bGVyQUkgZnJvbSBcIi4uL0FJL0JhdHRsZXJBSVwiO1xuaW1wb3J0IHsgWEVOT19BVEtFUl9UWVBFIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgRWZmZWN0RGF0YSB9IGZyb20gXCIuL0F0dGFjay9pbnRlcm5hbFwiO1xuaW1wb3J0IHsgQWNpZEVmZmVjdCB9IGZyb20gXCIuL0VmZmVjdC9BY2lkRWZmZWN0XCI7XG5pbXBvcnQgeyBFZmZlY3QgfSBmcm9tIFwiLi9FZmZlY3QvRWZmZWN0XCI7XG5pbXBvcnQgeyBGaXJlRWZmZWN0IH0gZnJvbSBcIi4vRWZmZWN0L0ZpcmVFZmZlY1wiO1xuaW1wb3J0IHsgU2xvd0VmZmVjdCB9IGZyb20gXCIuL0VmZmVjdC9TbG93RWZmZWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhdHRsZU1hbmFnZXIge1xuXG4gICAgdHVycmV0czogQXJyYXk8QW5pbWF0ZWRTcHJpdGU+XG4gICAgd2FsbHM6IEFycmF5PEFuaW1hdGVkU3ByaXRlPlxuICAgIGVuZW1pZXM6IEFycmF5PEFuaW1hdGVkU3ByaXRlPlxuXG4gICAgaGFuZGxlUG9pbnRBdGsodG86IEJhdHRsZXJBSSwgZG1nOiBudW1iZXIsIGVmZmVjdHM6IEVmZmVjdERhdGEpIHtcbiAgICAgICAgdG8uZGFtYWdlKGRtZyk7XG4gICAgICAgIEJhdHRsZU1hbmFnZXIuYWRkRWZmZWN0cyhlZmZlY3RzLCB0byk7XG4gICAgfVxuXG4gICAgaGFuZGxlQU9FQXRrKGZyb206IFZlYzIsIHI6IG51bWJlciwgZG1nOiBudW1iZXIsIGVmZmVjdHM6IEVmZmVjdERhdGEsIGF0a2VyVHlwZTogWEVOT19BVEtFUl9UWVBFKSB7XG4gICAgICAgIGNvbnN0IHIyID0gciAqIHI7XG4gICAgICAgIHN3aXRjaCAoYXRrZXJUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFhFTk9fQVRLRVJfVFlQRS5FTkVNWTpcbiAgICAgICAgICAgICAgICB0aGlzLnR1cnJldHNcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodCkgPT4gZnJvbS5kaXN0YW5jZVNxVG8odC5wb3NpdGlvbikgPD0gcjIpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0LmFpIGFzIEJhdHRsZXJBSTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5kYW1hZ2UoZG1nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJhdHRsZU1hbmFnZXIuYWRkRWZmZWN0cyhlZmZlY3RzLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIHRoaXMud2FsbHNcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodykgPT4gZnJvbS5kaXN0YW5jZVNxVG8ody5wb3NpdGlvbikgPD0gcjIpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKCh3KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB3LmFpIGFzIEJhdHRsZXJBSTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5kYW1hZ2UoZG1nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJhdHRsZU1hbmFnZXIuYWRkRWZmZWN0cyhlZmZlY3RzLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBYRU5PX0FUS0VSX1RZUEUuRlJJRU5EOlxuICAgICAgICAgICAgICAgIHRoaXMuZW5lbWllc1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChlKSA9PiBmcm9tLmRpc3RhbmNlU3FUbyhlLnBvc2l0aW9uKSA8PSByMilcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUuYWkgYXMgQmF0dGxlckFJO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmRhbWFnZShkbWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgQmF0dGxlTWFuYWdlci5hZGRFZmZlY3RzKGVmZmVjdHMsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBhZGRFZmZlY3RzKGRhdGE6IEVmZmVjdERhdGEsIHRhcmdldDogQmF0dGxlckFJKSB7XG4gICAgICAgIGlmIChkYXRhLmZpcmUpIHtcbiAgICAgICAgICAgIHRhcmdldC5hZGRFZmZlY3QobmV3IEZpcmVFZmZlY3QoZGF0YS5maXJlLmR1cmF0aW9uLCBkYXRhLmZpcmUudGlja3MsIHRhcmdldCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNsb3cpIHtcbiAgICAgICAgICAgIHRhcmdldC5hZGRFZmZlY3QobmV3IFNsb3dFZmZlY3QoZGF0YS5zbG93LmR1cmF0aW9uLCBkYXRhLnNsb3cucGVyY2VudCwgdGFyZ2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuYWNpZCkge1xuICAgICAgICAgICAgdGFyZ2V0LmFkZEVmZmVjdChuZXcgQWNpZEVmZmVjdChkYXRhLmFjaWQuZHVyYXRpb24sIGRhdGEuYWNpZC5yZWR1Y3Rpb24sIHRhcmdldCkpO1xuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0IFRpbWVyIGZyb20gXCIuLi8uLi8uLi9Xb2xmaWUyRC9UaW1pbmcvVGltZXJcIjtcbmltcG9ydCBCYXR0bGVyQUkgZnJvbSBcIi4uLy4uL0FJL0JhdHRsZXJBSVwiO1xuaW1wb3J0IHsgWEVOT19FRkZFQ1RfVFlQRSB9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IEVmZmVjdCB9IGZyb20gXCIuL0VmZmVjdFwiO1xuXG5leHBvcnQgY2xhc3MgQWNpZEVmZmVjdCBleHRlbmRzIEVmZmVjdDxBY2lkRWZmZWN0PiB7XG5cbiAgICBcbiAgICBkdXJhdGlvbjogbnVtYmVyO1xuICAgIFxuICAgIHJlZHVjdGlvbjogbnVtYmVyOyBcbiAgICBcbiAgICB0eXBlOiBYRU5PX0VGRkVDVF9UWVBFID0gWEVOT19FRkZFQ1RfVFlQRS5BQ0lEX0VGRkVDVDtcbiAgICBcbiAgICBwcml2YXRlIGR1cmF0aW9uVGltZXI6IFRpbWVyOyBcblxuICAgIGNvbnN0cnVjdG9yKGR1cmF0aW9uOiBudW1iZXIsIHJlZHVjdGlvbjogbnVtYmVyLCB0YXJnZXQ6IEJhdHRsZXJBSSkge1xuICAgICAgICBzdXBlcigpOyBcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucmVkdWN0aW9uID0gcmVkdWN0aW9uO1xuICAgICAgICB0aGlzLmR1cmF0aW9uVGltZXIgPSBuZXcgVGltZXIoZHVyYXRpb24sIHRoaXMuZW5kRWZmZWN0KTsgXG4gICAgfVxuXG4gICAgYXBwbHlFZmZlY3QoKTogdm9pZCB7IFxuICAgICAgICB0aGlzLnRhcmdldC5hcm1vciAtPSB0aGlzLnJlZHVjdGlvbjtcbiAgICAgICAgdGhpcy5kdXJhdGlvblRpbWVyLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZW5kRWZmZWN0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnRhcmdldC5hcm1vciArPSB0aGlzLnJlZHVjdGlvbjtcbiAgICB9XG5cbiAgICByZWZyZXNoRWZmZWN0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmR1cmF0aW9uVGltZXIucmVzZXQoKTtcbiAgICB9XG5cbiAgICBpc0FjdGl2ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmR1cmF0aW9uVGltZXIuaXNTdG9wcGVkKClcbiAgICB9XG5cbiAgICBlcXVhbChlOiBBY2lkRWZmZWN0KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmR1cmF0aW9uID09PSBlLmR1cmF0aW9uICYmIHRoaXMucmVkdWN0aW9uID09PSBlLnJlZHVjdGlvbjsgXG4gICAgfVxuICAgIFxuICAgIFxufVxuIiwiaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9FbWl0dGVyXCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCBUaW1lciBmcm9tIFwiLi4vLi4vLi4vV29sZmllMkQvVGltaW5nL1RpbWVyXCI7XG5pbXBvcnQgQmF0dGxlckFJIGZyb20gXCIuLi8uLi9BSS9CYXR0bGVyQUlcIjtcbmltcG9ydCB7IFhFTk9fRUZGRUNUX1RZUEUgfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBFZmZlY3Q8VD4ge1xuXG4gICAgaWQ6IG51bWJlciA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSArIE1hdGgucmFuZG9tKCkpOyBcblxuICAgIGR1cmF0aW9uOiBudW1iZXI7IFxuICAgIFxuICAgIHRhcmdldDogQmF0dGxlckFJOyBcblxuICAgIHR5cGU6IFhFTk9fRUZGRUNUX1RZUEU7XG4gICAgXG4gICAgZW1pdHRlcjogRW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG5cbiAgICBhYnN0cmFjdCBhcHBseUVmZmVjdCgpOiB2b2lkO1xuXG4gICAgYWJzdHJhY3QgZW5kRWZmZWN0KCk6IHZvaWQ7XG5cbiAgICBhYnN0cmFjdCByZWZyZXNoRWZmZWN0KCk6IHZvaWQ7XG4gICAgXG4gICAgYWJzdHJhY3QgaXNBY3RpdmUoKTogYm9vbGVhbjsgXG5cbiAgICBhYnN0cmFjdCBlcXVhbChlOiBUKTogYm9vbGVhbjtcbn1cblxuXG4iLCJpbXBvcnQgVGltZXIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL1RpbWluZy9UaW1lclwiO1xuaW1wb3J0IEJhdHRsZXJBSSBmcm9tIFwiLi4vLi4vQUkvQmF0dGxlckFJXCI7XG5pbXBvcnQgeyBYRU5PX0VGRkVDVF9UWVBFIH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgRWZmZWN0IH0gZnJvbSBcIi4vRWZmZWN0XCI7XG5cbmV4cG9ydCBjbGFzcyBGaXJlRWZmZWN0IGV4dGVuZHMgRWZmZWN0PEZpcmVFZmZlY3Q+IHtcblxuICAgIGR1cmF0aW9uOiBudW1iZXI7XG5cbiAgICBkYW1hZ2U6IG51bWJlcjtcblxuICAgIHRpY2tzOiBudW1iZXI7IFxuXG4gICAgcHJpdmF0ZSBkb3RUaW1lcjogVGltZXI7IFxuXG4gICAgcHJpdmF0ZSBkdXJhdGlvblRpbWVyOiBUaW1lcjsgXG5cbiAgICB0eXBlOiBYRU5PX0VGRkVDVF9UWVBFID0gWEVOT19FRkZFQ1RfVFlQRS5GSVJFX0VGRkVDVDsgXG5cbiAgICBjb25zdHJ1Y3RvcihkdXJhdGlvbjogbnVtYmVyLCB0aWNrczogbnVtYmVyLCB0YXJnZXQ6IEJhdHRsZXJBSSkge1xuICAgICAgICBzdXBlcigpOyBcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuZHVyYXRpb25UaW1lciA9IG5ldyBUaW1lcihkdXJhdGlvbiwgdGhpcy5lbmRFZmZlY3QpOyBcbiAgICAgICAgdGhpcy5kb3RUaW1lciA9IG5ldyBUaW1lcihkdXJhdGlvbiAvIHRpY2tzLCB0aGlzLmRvdCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgYXBwbHlFZmZlY3QoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZG90VGltZXIuc3RhcnQoKTsgXG4gICAgICAgIHRoaXMuZHVyYXRpb25UaW1lci5zdGFydCgpO1xuICAgIH1cblxuICAgIGRvdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50YXJnZXQuZGFtYWdlKHRoaXMuZGFtYWdlKTsgXG4gICAgfVxuXG4gICAgZW5kRWZmZWN0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRvdFRpbWVyLnBhdXNlKCk7IFxuICAgICAgICBcbiAgICB9XG5cbiAgICByZWZyZXNoRWZmZWN0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmR1cmF0aW9uVGltZXIucmVzZXQoKTtcbiAgICB9XG5cbiAgICBpc0FjdGl2ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmR1cmF0aW9uVGltZXIuaXNTdG9wcGVkKCk7XG4gICAgfVxuXG4gICAgZXF1YWwoZTogRmlyZUVmZmVjdCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZS5kdXJhdGlvbiA9PT0gdGhpcy5kdXJhdGlvbiAmJiBlLmRhbWFnZSA9PT0gdGhpcy5kYW1hZ2UgJiYgZS50aWNrcyA9PT0gdGhpcy50aWNrcztcbiAgICB9XG59XG4iLCJpbXBvcnQgVGltZXIgZnJvbSBcIi4uLy4uLy4uL1dvbGZpZTJEL1RpbWluZy9UaW1lclwiO1xuaW1wb3J0IEJhdHRsZXJBSSBmcm9tIFwiLi4vLi4vQUkvQmF0dGxlckFJXCI7XG5pbXBvcnQgeyBYRU5PX0VGRkVDVF9UWVBFIH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgRWZmZWN0IH0gZnJvbSBcIi4vRWZmZWN0XCI7XG5cblxuZXhwb3J0IGNsYXNzIFNsb3dFZmZlY3QgZXh0ZW5kcyBFZmZlY3Q8U2xvd0VmZmVjdD4ge1xuXG4gICAgZHVyYXRpb246IG51bWJlcjtcblxuICAgIHR5cGU6IFhFTk9fRUZGRUNUX1RZUEUgPSBYRU5PX0VGRkVDVF9UWVBFLlNMT1dfRUZGRUNUO1xuICAgIFxuICAgIHByaXZhdGUgcGVyY2VudDogbnVtYmVyOyBcblxuICAgIHByaXZhdGUgZG90VGltZXI6IFRpbWVyOyBcblxuICAgIHByaXZhdGUgZHVyYXRpb25UaW1lcjogVGltZXI7IFxuXG5cbiAgICBjb25zdHJ1Y3RvcihkdXJhdGlvbjogbnVtYmVyLCBwZXJjZW50OiBudW1iZXIsIHRhcmdldDogQmF0dGxlckFJKSB7XG4gICAgICAgIHN1cGVyKCk7IFxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5kdXJhdGlvblRpbWVyID0gbmV3IFRpbWVyKGR1cmF0aW9uLCB0aGlzLmRvdFRpbWVyLnBhdXNlKTsgXG4gICAgfVxuXG4gICAgYXBwbHlFZmZlY3QoKTogdm9pZCB7IFxuICAgICAgICB0aGlzLnRhcmdldC5zcGVlZCAqPSB0aGlzLnBlcmNlbnQ7XG4gICAgICAgIHRoaXMuZHVyYXRpb25UaW1lci5zdGFydCgpO1xuICAgIH1cblxuICAgIGVuZEVmZmVjdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50YXJnZXQuc3BlZWQgLz0gdGhpcy5wZXJjZW50O1xuICAgICAgICB0aGlzLmR1cmF0aW9uVGltZXIucGF1c2UoKTsgXG4gICAgICAgIGRlbGV0ZSB0aGlzLmR1cmF0aW9uVGltZXI7IFxuICAgIH1cblxuICAgIHJlZnJlc2hFZmZlY3QoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZHVyYXRpb25UaW1lci5yZXNldCgpO1xuICAgIH1cblxuICAgIGlzQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gIXRoaXMuZHVyYXRpb25UaW1lci5pc1N0b3BwZWQoKTtcbiAgICB9XG5cbiAgICBlcXVhbChlOiBTbG93RWZmZWN0KTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChlLnR5cGUgPT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHVyYXRpb24gPT09IGUuZHVyYXRpb24gJiYgdGhpcy5wZXJjZW50ID09PSBlLnBlcmNlbnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xuaW1wb3J0IExheWVyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9TY2VuZS9MYXllclwiO1xuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9TY2VuZS9TY2VuZVwiO1xuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9VdGlscy9Db2xvclwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XG5pbXBvcnQgeyBDQU5WQVNfU0laRSB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudFwiO1xuaW1wb3J0IHhlbm9fbGV2ZWwgZnJvbSBcIi4veGVub19sZXZlbFwiO1xuXG5jb25zdCBQQURESU5HID0gMTAwO1xuY29uc3QgUGFzc2l2ZUdyZXkgPSBuZXcgQ29sb3IoMTk2LCAxOTYsIDE5Nik7XG5jb25zdCBBY3RpdmVHcmV5ID0gbmV3IENvbG9yKDIyOSwgMjI5LCAyMjkpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWluTWVudSBleHRlbmRzIFNjZW5lIHtcbiAgICAvLyBMYXllcnMsIGZvciBtdWx0aXBsZSBtYWluIG1lbnUgc2NyZWVuc1xuICAgIHByaXZhdGUgbWFpbjogTGF5ZXI7XG4gICAgcHJpdmF0ZSBjaGFwdGVyOiBMYXllcjtcbiAgICBwcml2YXRlIGNvbnRyb2w6IExheWVyO1xuICAgIHByaXZhdGUgaGVscDogTGF5ZXI7IFxuXG4gICAgbG9hZFNjZW5lKCkge1xuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UoXCJiYWNrZ3JvdW5kXCIsIFwieGVub19hc3NldHMvaW1hZ2VzL2JhY2tncm91bmQucG5nXCIpXG4gICAgICAgIHRoaXMubG9hZC5pbWFnZShcImxlZnRjbGlja1wiLCBcInhlbm9fYXNzZXRzL2ltYWdlcy9saWdodC9tb3VzZV9sZWZ0X2tleV9saWdodC5wbmdcIilcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwiRVNDXCIsIFwieGVub19hc3NldHMvaW1hZ2VzL2xpZ2h0L2VzY19rZXlfbGlnaHQucG5nXCIpXG4gICAgICAgIHRoaXMubG9hZC5pbWFnZShcInNlbWljb2xvblwiLCBcInhlbm9fYXNzZXRzL2ltYWdlcy9saWdodC9zZW1pY29sb25fa2V5X2xpZ2h0LnBuZ1wiKVxuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UoXCJxdW90ZVwiLCBcInhlbm9fYXNzZXRzL2ltYWdlcy9saWdodC9xdW90ZV9sZXlfbGlnaHQucG5nXCIpXG4gICAgfVxuXG4gICAgc3RhcnRTY2VuZSgpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhpcy52aWV3cG9ydC5nZXRDZW50ZXIoKTtcblxuICAgICAgICAvLyBUaGUgbWFpbiBtZW51XG4gICAgICAgIHRoaXMubWFpbiA9IHRoaXMuYWRkVUlMYXllcihcIm1haW5cIik7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IHRoaXMuYWRkVUlMYXllcihcImNvbnRyb2xcIik7XG4gICAgICAgIHRoaXMuaGVscCA9IHRoaXMuYWRkVUlMYXllcihcImhlbHBcIik7XG4gICAgICAgIHRoaXMuY2hhcHRlciA9IHRoaXMuYWRkVUlMYXllcihcImNoYXB0ZXJcIik7XG5cbiAgICAgICAgdGhpcy5jb250cm9sLnNldEhpZGRlbih0cnVlKTtcbiAgICAgICAgdGhpcy5oZWxwLnNldEhpZGRlbih0cnVlKTtcbiAgICAgICAgdGhpcy5jaGFwdGVyLnNldEhpZGRlbih0cnVlKTtcblxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZSgnbWFpbicpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZSgnY29udHJvbCcpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZSgnaGVscCcpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZSgnY2hhcHRlcicpO1xuXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKCdjaGFwdGVyMV8xJyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKCdjaGFwdGVyMV8xJyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKCdjaGFwdGVyMl8xJyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKCdjaGFwdGVyMl8yJyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKCdjaGFwdGVyM18xJyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKCdjaGFwdGVyM18yJyk7XG5cbiAgICAgICAgY29uc3QgbWFpbkJhY2tncm91bmQgPSB0aGlzLmFkZC5zcHJpdGUoXCJiYWNrZ3JvdW5kXCIsIFwibWFpblwiKTtcbiAgICAgICAgbWFpbkJhY2tncm91bmQucG9zaXRpb24uY29weShjZW50ZXIpOyBcbiAgICAgICAgY29uc3QgY29udHJvbEJhY2tncm91bmQgPSB0aGlzLmFkZC5zcHJpdGUoXCJiYWNrZ3JvdW5kXCIsIFwiY29udHJvbFwiKTtcbiAgICAgICAgY29udHJvbEJhY2tncm91bmQucG9zaXRpb24uY29weShjZW50ZXIpOyBcbiAgICAgICAgY29uc3QgaGVscEJhY2tncm91bmQgPSB0aGlzLmFkZC5zcHJpdGUoXCJiYWNrZ3JvdW5kXCIsIFwiaGVscFwiKTtcbiAgICAgICAgaGVscEJhY2tncm91bmQucG9zaXRpb24uY29weShjZW50ZXIpOyBcbiAgICAgICAgY29uc3QgY2hhcHRlckJhY2tncm91bmQgPSB0aGlzLmFkZC5zcHJpdGUoXCJiYWNrZ3JvdW5kXCIsIFwiY2hhcHRlclwiKTtcbiAgICAgICAgY2hhcHRlckJhY2tncm91bmQucG9zaXRpb24uY29weShjZW50ZXIpOyBcblxuICAgICAgICBcbiAgICAgICAgY29uc3QgdGl0bGVQb3NpdGlvbiA9IHsgeDogQ0FOVkFTX1NJWkUueCAvIDQsIHk6IDIgKiBQQURESU5HIH1cblxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1BSU4gTEFZRVIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgIGNvbnN0IG1haW5UaXRsZUxpbmUgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwibWFpblwiLCB7IHBvc2l0aW9uOiBuZXcgVmVjMih0aXRsZVBvc2l0aW9uLngsIHRpdGxlUG9zaXRpb24ueSksIHRleHQ6IFwiWEVOT1wiIH0pXG4gICAgICAgIG1haW5UaXRsZUxpbmUudGV4dENvbG9yID0gQ29sb3IuQkxBQ0s7XG4gICAgICAgIG1haW5UaXRsZUxpbmUuZm9udFNpemUgPSA3ODtcblxuICAgICAgICBjb25zdCBjaGFwdGVyQnRuID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcIm1haW5cIiwgeyBwb3NpdGlvbjogbmV3IFZlYzIoQ0FOVkFTX1NJWkUueCAqIDAuNzUsIDQgKiBQQURESU5HKSwgdGV4dDogJ0NIQVBURVInIH0pO1xuICAgICAgICBjaGFwdGVyQnRuLmJvcmRlckNvbG9yID0gY2hhcHRlckJ0bi5iYWNrZ3JvdW5kQ29sb3IgPSBQYXNzaXZlR3JleTtcbiAgICAgICAgY2hhcHRlckJ0bi5zaXplLnNldCgyMDAsIDUwKTtcbiAgICAgICAgY2hhcHRlckJ0bi5vbkNsaWNrRXZlbnRJZCA9IFwiY2hhcHRlclwiOyBcblxuICAgICAgICBjb25zdCBjb250cm9sQnRuID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcIm1haW5cIiwgeyBwb3NpdGlvbjogbmV3IFZlYzIoQ0FOVkFTX1NJWkUueCAqIDAuNzUsIDUgKiBQQURESU5HKSwgdGV4dDogJ0NPTlRST0wnIH0pO1xuICAgICAgICBjb250cm9sQnRuLmJvcmRlckNvbG9yID0gY29udHJvbEJ0bi5iYWNrZ3JvdW5kQ29sb3IgPSBQYXNzaXZlR3JleTtcbiAgICAgICAgY29udHJvbEJ0bi5zaXplLnNldCgyMDAsIDUwKTtcbiAgICAgICAgY29udHJvbEJ0bi5vbkNsaWNrRXZlbnRJZCA9IFwiY29udHJvbFwiOyBcblxuICAgICAgICBjb25zdCBoZWxwQnRuID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcIm1haW5cIiwgeyBwb3NpdGlvbjogbmV3IFZlYzIoQ0FOVkFTX1NJWkUueCAqIDAuNzUsIDYgKiBQQURESU5HKSwgdGV4dDogJ0hFTFAnIH0pO1xuICAgICAgICBoZWxwQnRuLmJvcmRlckNvbG9yID0gaGVscEJ0bi5iYWNrZ3JvdW5kQ29sb3IgPSBQYXNzaXZlR3JleTtcbiAgICAgICAgaGVscEJ0bi5zaXplLnNldCgyMDAsIDUwKTtcbiAgICAgICAgaGVscEJ0bi5vbkNsaWNrRXZlbnRJZCA9IFwiaGVscFwiOyBcblxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQ0hBUFRFUiBMQVlFUiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAgICAgICBjb25zdCBjaGFwdGVyVGl0bGVMaW5lID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcImNoYXB0ZXJcIiwgeyBwb3NpdGlvbjogbmV3IFZlYzIodGl0bGVQb3NpdGlvbi54LCB0aXRsZVBvc2l0aW9uLnkpLCB0ZXh0OiBcIkNIQVBURVJTXCIgfSlcbiAgICAgICAgY2hhcHRlclRpdGxlTGluZS50ZXh0Q29sb3IgPSBDb2xvci5CTEFDSztcbiAgICAgICAgY2hhcHRlclRpdGxlTGluZS5mb250U2l6ZSA9IDc4O1xuXG4gICAgICAgIGNvbnN0IGNoYXB0ZXIxXzFCdG4gPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwiY2hhcHRlclwiLCB7IHBvc2l0aW9uOiBuZXcgVmVjMihDQU5WQVNfU0laRS54ICogMC4yNSwgNCAqIFBBRERJTkcpLCB0ZXh0OiAnMS0xJyB9KVxuICAgICAgICBjaGFwdGVyMV8xQnRuLmJvcmRlckNvbG9yID0gY2hhcHRlcjFfMUJ0bi5iYWNrZ3JvdW5kQ29sb3IgPSBQYXNzaXZlR3JleTtcbiAgICAgICAgY2hhcHRlcjFfMUJ0bi5zaXplLnNldCgxMDAsIDEwMCk7XG4gICAgICAgIGNoYXB0ZXIxXzFCdG4ub25DbGlja0V2ZW50SWQgPSBcImNoYXB0ZXIxXzFcIjsgXG4gICAgICAgIGNvbnN0IGNoYXB0ZXIxXzJCdG4gPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwiY2hhcHRlclwiLCB7IHBvc2l0aW9uOiBuZXcgVmVjMihDQU5WQVNfU0laRS54ICogMC4yNSAsIDYgKiBQQURESU5HKSwgdGV4dDogJzEtMicgfSlcbiAgICAgICAgY2hhcHRlcjFfMkJ0bi5ib3JkZXJDb2xvciA9IGNoYXB0ZXIxXzJCdG4uYmFja2dyb3VuZENvbG9yID0gUGFzc2l2ZUdyZXk7XG4gICAgICAgIGNoYXB0ZXIxXzJCdG4uc2l6ZS5zZXQoMTAwLCAxMDApO1xuICAgICAgICBjaGFwdGVyMV8yQnRuLm9uQ2xpY2tFdmVudElkID0gXCJjaGFwdGVyMV8yXCI7XG4gICAgICAgIGNvbnN0IGNoYXB0ZXIyXzFCdG4gPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwiY2hhcHRlclwiLCB7IHBvc2l0aW9uOiBuZXcgVmVjMihDQU5WQVNfU0laRS54ICogMC41LCA0ICogUEFERElORyksIHRleHQ6ICcyLTEnIH0pXG4gICAgICAgIGNoYXB0ZXIyXzFCdG4uYm9yZGVyQ29sb3IgPSBjaGFwdGVyMl8xQnRuLmJhY2tncm91bmRDb2xvciA9IFBhc3NpdmVHcmV5O1xuICAgICAgICBjaGFwdGVyMl8xQnRuLnNpemUuc2V0KDEwMCwgMTAwKTtcbiAgICAgICAgY2hhcHRlcjJfMUJ0bi5vbkNsaWNrRXZlbnRJZCA9IFwiY2hhcHRlcjJfMVwiO1xuICAgICAgICBjb25zdCBjaGFwdGVyMl8yQnRuID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcImNoYXB0ZXJcIiwgeyBwb3NpdGlvbjogbmV3IFZlYzIoQ0FOVkFTX1NJWkUueCAqIDAuNSwgNiAqIFBBRERJTkcpLCB0ZXh0OiAnMi0yJyB9KVxuICAgICAgICBjaGFwdGVyMl8yQnRuLmJvcmRlckNvbG9yID0gY2hhcHRlcjJfMkJ0bi5iYWNrZ3JvdW5kQ29sb3IgPSBQYXNzaXZlR3JleTtcbiAgICAgICAgY2hhcHRlcjJfMkJ0bi5zaXplLnNldCgxMDAsIDEwMCk7XG4gICAgICAgIGNoYXB0ZXIyXzJCdG4ub25DbGlja0V2ZW50SWQgPSBcImNoYXB0ZXIyXzJcIjtcbiAgICAgICAgY29uc3QgY2hhcHRlcjNfMUJ0biA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJjaGFwdGVyXCIsIHsgcG9zaXRpb246IG5ldyBWZWMyKENBTlZBU19TSVpFLnggKiAwLjc1LCA0ICogUEFERElORyksIHRleHQ6ICczLTEnIH0pXG4gICAgICAgIGNoYXB0ZXIzXzFCdG4uYm9yZGVyQ29sb3IgPSBjaGFwdGVyM18xQnRuLmJhY2tncm91bmRDb2xvciA9IFBhc3NpdmVHcmV5O1xuICAgICAgICBjaGFwdGVyM18xQnRuLnNpemUuc2V0KDEwMCwgMTAwKTtcbiAgICAgICAgY2hhcHRlcjNfMUJ0bi5vbkNsaWNrRXZlbnRJZCA9IFwiY2hhcHRlcjNfMVwiO1xuICAgICAgICBjb25zdCBjaGFwdGVyM18yQnRuID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcImNoYXB0ZXJcIiwgeyBwb3NpdGlvbjogbmV3IFZlYzIoQ0FOVkFTX1NJWkUueCAqIDAuNzUgLCA2ICogUEFERElORyksIHRleHQ6ICczLTInIH0pXG4gICAgICAgIGNoYXB0ZXIzXzJCdG4uYm9yZGVyQ29sb3IgPSBjaGFwdGVyM18yQnRuLmJhY2tncm91bmRDb2xvciA9IFBhc3NpdmVHcmV5O1xuICAgICAgICBjaGFwdGVyM18yQnRuLnNpemUuc2V0KDEwMCwgMTAwKTtcbiAgICAgICAgY2hhcHRlcjNfMkJ0bi5vbkNsaWNrRXZlbnRJZCA9IFwiY2hhcHRlcjNfMlwiO1xuXG5cbiAgICAgICAgY29uc3QgY2hhcHRlckJhY2tCdG4gPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwiY2hhcHRlclwiLCB7IHBvc2l0aW9uOiBuZXcgVmVjMihDQU5WQVNfU0laRS54ICogMC45LCA4ICogUEFERElORyksIHRleHQ6ICdCQUNLJyB9KTtcbiAgICAgICAgY2hhcHRlckJhY2tCdG4uYm9yZGVyQ29sb3IgPSBjaGFwdGVyQmFja0J0bi5iYWNrZ3JvdW5kQ29sb3IgPSBBY3RpdmVHcmV5OyBcbiAgICAgICAgY2hhcHRlckJhY2tCdG4uc2l6ZS5zZXQoMjAwLCA1MCk7XG4gICAgICAgIGNoYXB0ZXJCYWNrQnRuLm9uQ2xpY2tFdmVudElkID0gXCJtYWluXCI7XG5cblxuXG4gICAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBDT05UUk9MIExBWUVSIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgIGNvbnN0IGNvbnRyb2xUaXRsZUxpbmUgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiY29udHJvbFwiLCB7IHBvc2l0aW9uOiBuZXcgVmVjMih0aXRsZVBvc2l0aW9uLngsIHRpdGxlUG9zaXRpb24ueSksIHRleHQ6IFwiQ09UTlJPTFwiIH0pXG4gICAgICAgIGNvbnRyb2xUaXRsZUxpbmUudGV4dENvbG9yID0gQ29sb3IuQkxBQ0s7XG4gICAgICAgIGNvbnRyb2xUaXRsZUxpbmUuZm9udFNpemUgPSA3ODtcblxuICAgICAgICBjb25zdCBsZWZ0Y2xpY2sgPSB0aGlzLmFkZC5zcHJpdGUoXCJsZWZ0Y2xpY2tcIiwgXCJjb250cm9sXCIpO1xuICAgICAgICBsZWZ0Y2xpY2sucG9zaXRpb24gPSBuZXcgVmVjMih0aXRsZVBvc2l0aW9uLngsIDQgKiBQQURESU5HKTtcblxuICAgICAgICBjb25zdCBsZWZ0Y2xpY2tMaW5lMSA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJjb250cm9sXCIsIHsgcG9zaXRpb246IG5ldyBWZWMyKENBTlZBU19TSVpFLnggKiAwLjU1LCA0ICogUEFERElORyksIHRleHQ6ICdMZWZ0Y2xpY2sgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgaW4gZ2FtZSBVSS4nIH0pXG4gICAgICAgIGxlZnRjbGlja0xpbmUxLmJhY2tncm91bmRDb2xvciA9IGxlZnRjbGlja0xpbmUxLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XG4gICAgICAgIGxlZnRjbGlja0xpbmUxLmZvbnRTaXplID0gNDA7XG4gICAgICAgIGxlZnRjbGlja0xpbmUxLnRleHRDb2xvciA9IENvbG9yLkJMQUNLOyBcblxuICAgICAgICBjb25zdCBsZWZ0Y2xpY2tMaW5lMiA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJjb250cm9sXCIsIHsgcG9zaXRpb246IG5ldyBWZWMyKENBTlZBU19TSVpFLnggKiAwLjYsIDQuNSAqIFBBRERJTkcpLCB0ZXh0OiAnQ2xpY2sgb24gZXhpc3RpbmcgdHVycmV0cy93YWxscy90cmFwcyB0byB1cGdyYWRlIHRoZW0uJyB9KVxuICAgICAgICBsZWZ0Y2xpY2tMaW5lMi5iYWNrZ3JvdW5kQ29sb3IgPSBsZWZ0Y2xpY2tMaW5lMi5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xuICAgICAgICBsZWZ0Y2xpY2tMaW5lMi5mb250U2l6ZSA9IDQwO1xuICAgICAgICBsZWZ0Y2xpY2tMaW5lMi50ZXh0Q29sb3IgPSBDb2xvci5CTEFDSzsgXG4gICAgICAgIFxuICAgICAgICBjb25zdCBFU0MgPSB0aGlzLmFkZC5zcHJpdGUoXCJFU0NcIiwgXCJjb250cm9sXCIpO1xuICAgICAgICBFU0MucG9zaXRpb24gPSBuZXcgVmVjMih0aXRsZVBvc2l0aW9uLngsIDYgKiBQQURESU5HKTtcbiAgICAgICAgY29uc3QgRVNDTGluZSA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJjb250cm9sXCIsIHsgcG9zaXRpb246IG5ldyBWZWMyKENBTlZBU19TSVpFLnggKiAwLjYsIDYgKiBQQURESU5HKSwgdGV4dDogJ1BhdXNlIHRoZSBnYW1lIHdoaWxlIGluIGdhbWUgYW5kIGFjZXNzIHRoZSBwYXVzZSBtZW51JyB9KTtcbiAgICAgICAgRVNDTGluZS5iYWNrZ3JvdW5kQ29sb3IgPSBFU0NMaW5lLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XG4gICAgICAgIEVTQ0xpbmUuZm9udFNpemUgPSA0MDtcbiAgICAgICAgRVNDTGluZS50ZXh0Q29sb3IgPSBDb2xvci5CTEFDSzsgXG5cbiAgICAgICAgY29uc3QgY29udHJvbEJhY2tCdG4gPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwiY29udHJvbFwiLCB7IHBvc2l0aW9uOiBuZXcgVmVjMihDQU5WQVNfU0laRS54ICogMC45LCA4ICogUEFERElORyksIHRleHQ6ICdCQUNLJyB9KTtcbiAgICAgICAgY29udHJvbEJhY2tCdG4uYm9yZGVyQ29sb3IgPSBjb250cm9sQmFja0J0bi5iYWNrZ3JvdW5kQ29sb3IgPSBBY3RpdmVHcmV5OyBcbiAgICAgICAgY29udHJvbEJhY2tCdG4uc2l6ZS5zZXQoMjAwLCA1MCk7XG4gICAgICAgIGNvbnRyb2xCYWNrQnRuLm9uQ2xpY2tFdmVudElkID0gXCJtYWluXCI7XG5cblxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEhFTFAgTEFZRVIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAgICAgICBjb25zdCBoZWxwVGl0bGVMaW5lID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcImhlbHBcIiwgeyBwb3NpdGlvbjogbmV3IFZlYzIodGl0bGVQb3NpdGlvbi54LCB0aXRsZVBvc2l0aW9uLnkpLCB0ZXh0OiBcIkhFTFBcIiB9KVxuICAgICAgICBoZWxwVGl0bGVMaW5lLnRleHRDb2xvciA9IENvbG9yLkJMQUNLO1xuICAgICAgICBoZWxwVGl0bGVMaW5lLmZvbnRTaXplID0gNzg7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBoZWxwRGV2ZUxpbmUgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiaGVscFwiLCB7IHBvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgMyAqIFBBRERJTkcpLCB0ZXh0OiBcIlhlbm8gaXMgZGV2ZWxvcGVkIGJ5IENoZW5jaGVuZyBZYW5nLCBIb25nY2hlbmcgTGksIGFuZCBYWFhcIiB9KVxuXG4gICAgICAgIGNvbnN0IGhlbHBTdG9yeUxpbmUxID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcImhlbHBcIiwgeyBwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIDQgKiBQQURESU5HKSwgdGV4dDogXCJZb3VyIGFyZSBwYXJ0IG9mIHRoZSBpbnRlcmdhbGFjdGljIGV4cGxvcmVycywgXFxcIlhlbm9cXFwiXCJ9KTtcbiAgICAgICAgY29uc3QgaGVscFN0b3J5TGluZTIgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiaGVscFwiLCB7IHBvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgNC41ICogUEFERElORyksIHRleHQ6IFwiVXRpbGl6ZSB5b3VyIHJlc291cmNlIHRvIGJ1aWxkIHVwIGEgZm9ydHJlc3MgYW5kIGRlZmVuZCBhZ2FpbnN0IHRoZSB2aWNpb3VzIFVNQXNcIn0pO1xuICAgICAgICBjb25zdCBoZWxwU3RvcnlMaW5lMyA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJoZWxwXCIsIHsgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCA1ICogUEFERElORyksIHRleHQ6IFwiRG9uJ3QgbGV0IHlvdXIgZ3VhcmQgZG93biBvciB5b3Ugd2lsbCBiZSBlYXRlbiBhbGl2ZSBcIn0pO1xuXG4gICAgICAgIGNvbnN0IHNlbWljb2xvbiA9IHRoaXMuYWRkLnNwcml0ZShcInNlbWljb2xvblwiLCBcImhlbHBcIik7XG4gICAgICAgIHNlbWljb2xvbi5wb3NpdGlvbiA9IG5ldyBWZWMyKHRpdGxlUG9zaXRpb24ueCwgNiAqIFBBRERJTkcpO1xuICAgICAgICBjb25zdCBzZW1pY29sb25MaW5lID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcImhlbHBcIiwgeyBwb3NpdGlvbjogbmV3IFZlYzIoQ0FOVkFTX1NJWkUueCAqIDAuNiwgNiAqIFBBRERJTkcpLCB0ZXh0OiAnSW5maW5pdGUgTW9uZXknIH0pO1xuICAgICAgICBzZW1pY29sb25MaW5lLmJhY2tncm91bmRDb2xvciA9IHNlbWljb2xvbkxpbmUuYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcbiAgICAgICAgc2VtaWNvbG9uTGluZS5mb250U2l6ZSA9IDQwO1xuICAgICAgICBzZW1pY29sb25MaW5lLnRleHRDb2xvciA9IENvbG9yLkJMQUNLOyBcbiAgICAgICAgY29uc3QgcXVvdGUgPSB0aGlzLmFkZC5zcHJpdGUoXCJxdW90ZVwiLCBcImhlbHBcIik7XG4gICAgICAgIHF1b3RlLnBvc2l0aW9uID0gbmV3IFZlYzIodGl0bGVQb3NpdGlvbi54LCA3ICogUEFERElORyk7XG4gICAgICAgIGNvbnN0IHF1b3RlTGluZSA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJoZWxwXCIsIHsgcG9zaXRpb246IG5ldyBWZWMyKENBTlZBU19TSVpFLnggKiAwLjYsIDcgKiBQQURESU5HKSwgdGV4dDogJ0luZmluaXRlIEhlYWx0aCcgfSk7XG4gICAgICAgIHF1b3RlTGluZS5iYWNrZ3JvdW5kQ29sb3IgPSBxdW90ZUxpbmUuYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcbiAgICAgICAgcXVvdGVMaW5lLmZvbnRTaXplID0gNDA7XG4gICAgICAgIHF1b3RlTGluZS50ZXh0Q29sb3IgPSBDb2xvci5CTEFDSzsgXG5cblxuICAgICAgICBjb25zdCBoZWxwQmFja0J0biA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJoZWxwXCIsIHsgcG9zaXRpb246IG5ldyBWZWMyKENBTlZBU19TSVpFLnggKiAwLjksIDggKiBQQURESU5HKSwgdGV4dDogJ0JBQ0snIH0pO1xuICAgICAgICBoZWxwQmFja0J0bi5ib3JkZXJDb2xvciA9IGhlbHBCYWNrQnRuLmJhY2tncm91bmRDb2xvciA9IEFjdGl2ZUdyZXk7IFxuICAgICAgICBoZWxwQmFja0J0bi5zaXplLnNldCgyMDAsIDUwKTtcbiAgICAgICAgaGVscEJhY2tCdG4ub25DbGlja0V2ZW50SWQgPSBcIm1haW5cIjtcblxuXG4gICAgfVxuXG4gICAgdXBkYXRlU2NlbmUoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKSB7XG4gICAgICAgICAgICBsZXQgZXZlbnQgPSB0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhldmVudCk7XG5cbiAgICAgICAgICAgIHN3aXRjaChldmVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1haW5cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zd2l0Y2hTY2VuZSgnbWFpbicpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjaGFwdGVyXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3dpdGNoU2NlbmUoJ2NoYXB0ZXInKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29udHJvbFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN3aXRjaFNjZW5lKCdjb250cm9sJylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImhlbHBcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zd2l0Y2hTY2VuZSgnaGVscCcpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjaGFwdGVyMV8xXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoeGVub19sZXZlbCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoU2NlbmUobmFtZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gWydtYWluJywgJ2NvbnRyb2wnLCAnaGVscCcsICdjaGFwdGVyJ107XG4gICAgICAgIG5hbWVzLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRMYXllcihlKS5zZXRIaWRkZW4oZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldExheWVyKGUpLnNldEhpZGRlbih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cblxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9JbnB1dC9JbnB1dFwiO1xuaW1wb3J0IExhYmVsIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvTGF5ZXJcIjtcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vV29sZmllMkQvVXRpbHMvQ29sb3JcIjtcbmltcG9ydCBNYWluTWVudSBmcm9tIFwiLi9NYWluTWVudVwiO1xuXG5jb25zdCBDT0xPUl9TQUxNT04gPSBuZXcgQ29sb3IoMjUwLCAxMjgsIDExNCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGFzaFNjcmVlbiBleHRlbmRzIFNjZW5lIHtcbiAgICBwcml2YXRlIHNwbGFzaFNjcmVlbjogTGF5ZXI7XG5cbiAgICBsb2FkU2NlbmUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZC5pbWFnZShcImxvZ29cIiwgXCJ4ZW5vX2Fzc2V0cy9pbWFnZXMvbG9nby5wbmdcIik7XG4gICAgfVxuXG4gICAgdW5sb2FkU2NlbmUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyLnVubG9hZEFsbFJlc291cmNlcygpOyBcbiAgICB9XG5cbiAgICBzdGFydFNjZW5lKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNwbGFzaFNjcmVlbiA9IHRoaXMuYWRkVUlMYXllcihcInNwbGFzaFNjcmVlblwiKTtcblxuICAgICAgICAvLyBBZGQgbG9nb1xuICAgICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLnZpZXdwb3J0LmdldENlbnRlcigpO1xuXG4gICAgICAgIGNvbnN0IGxvZ28gPSB0aGlzLmFkZC5zcHJpdGUoXCJsb2dvXCIsIFwic3BsYXNoU2NyZWVuXCIpO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgc3RhcnRUZXh0ID0gXCJQcmVzcyBMZWZ0Y2xpY2sgVG8gU3RhcnRcIlxuICAgICAgICBjb25zdCBzdGFydExpbmUgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwic3BsYXNoU2NyZWVuXCIsIHsgcG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDQwMCksIHRleHQ6IHN0YXJ0VGV4dCB9KTtcbiAgICAgICAgLy8gU2FsbW9uIFxuICAgICAgICBzdGFydExpbmUudGV4dENvbG9yID0gQ09MT1JfU0FMTU9OO1xuICAgICAgICBzdGFydExpbmUuZm9udFNpemUgPSA2NDtcbiAgICAgICAgXG4gICAgICAgIGxvZ28ucG9zaXRpb24uY29weShjZW50ZXIpO1xuICAgIH1cblxuICAgIHVwZGF0ZVNjZW5lKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmIChJbnB1dC5pc01vdXNlSnVzdFByZXNzZWQoMCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoTWFpbk1lbnUsIHt9KTsgXG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IEFBQkIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50XCI7XG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0lucHV0L0lucHV0XCI7XG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XG5pbXBvcnQgTGF5ZXIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lL0xheWVyXCI7XG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XG5pbXBvcnQgVGltZXJNYW5hZ2VyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9UaW1pbmcvVGltZXJNYW5hZ2VyXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1V0aWxzL0NvbG9yXCI7XG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9VdGlscy9NYXRoVXRpbHNcIjtcbmltcG9ydCBCYXR0bGVyQUkgZnJvbSBcIi4uL0FJL0JhdHRsZXJBSVwiO1xuaW1wb3J0IEVuZW15QUkgZnJvbSBcIi4uL0FJL0VuZW15QUlcIjtcbmltcG9ydCBUdXJyZXRBSSBmcm9tIFwiLi4vQUkvVHVycmV0QUlcIjtcbmltcG9ydCBXYWxsQUksIHsgTkVJR0hCT1IgfSBmcm9tIFwiLi4vQUkvV2FsbEFJXCI7XG5pbXBvcnQgeyBUUkFQX1RZUEUsIFhFTk9fRVZFTlRTIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IEJhdHRsZU1hbmFnZXIgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0JhdHRsZU1hbmFnZXJcIjtcblxubGV0IGlkQ291bnRlciA9IDA7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgeGVub19sZXZlbCBleHRlbmRzIFNjZW5lIHtcblxuICAgIHByaXZhdGUgcGxhY2luZ01vZGU6IFwiV0FMTFwiIHwgXCJUVVJSRVRcIiB8IFwiVFJBUFwiIHwgXCJFTkVNWVwiID0gXCJXQUxMXCI7XG5cbiAgICBwcml2YXRlIGZsb29yOiBPcnRob2dvbmFsVGlsZW1hcDtcblxuICAgIHByaXZhdGUgZGVhZFdhbGxzOiBBcnJheTxBbmltYXRlZFNwcml0ZT4gPSBuZXcgQXJyYXkoKTtcblxuICAgIHByaXZhdGUgZGVhZFRyYXBzOiBBcnJheTxBbmltYXRlZFNwcml0ZT4gPSBuZXcgQXJyYXkoKTtcblxuICAgIHByaXZhdGUgZGVhZFR1cnJldHM6IEFycmF5PEFuaW1hdGVkU3ByaXRlPiA9IG5ldyBBcnJheSgpO1xuXG4gICAgcHJpdmF0ZSBkZWFkRW5lbWllczogQXJyYXk8QW5pbWF0ZWRTcHJpdGU+ID0gbmV3IEFycmF5KCk7XG5cbiAgICBwcml2YXRlIGFsaXZlV2FsbHM6IEFycmF5PEFuaW1hdGVkU3ByaXRlPiA9IG5ldyBBcnJheSgpO1xuXG4gICAgcHJpdmF0ZSBhbGl2ZVRyYXBzOiBBcnJheTxBbmltYXRlZFNwcml0ZT4gPSBuZXcgQXJyYXkoKTtcblxuICAgIHByaXZhdGUgYWxpdmVUdXJyZXRzOiBBcnJheTxBbmltYXRlZFNwcml0ZT4gPSBuZXcgQXJyYXkoKTtcblxuICAgIHByaXZhdGUgYWxpdmVFbmVtaWVzOiBBcnJheTxBbmltYXRlZFNwcml0ZT4gPSBuZXcgQXJyYXkoKTtcblxuICAgIHByaXZhdGUgYmF0dGxlTWFuYWdlcjogQmF0dGxlTWFuYWdlciA9IG5ldyBCYXR0bGVNYW5hZ2VyKCk7XG5cbiAgICBwcml2YXRlIFVJOiBMYXllcjtcblxuICAgIHByaXZhdGUgZXJyb3JMYWJlbDogTGFiZWxcblxuICAgIGxvYWRTY2VuZSgpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLmxvYWQudGlsZW1hcChcImxldmVsXCIsIFwieGVub19hc3NldHMvbWFwL3Rlc3RfbWFwLmpzb25cIik7XG4gICAgICAgIHRoaXMubG9hZC5zcHJpdGVzaGVldChcImJhc2VcIixcInhlbm9fYXNzZXRzL3Nwcml0ZXNoZWV0cy9nZW5lcmF0b3IuanNvblwiKTtcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwid2FsbHNcIiwgXCJ4ZW5vX2Fzc2V0cy9zcHJpdGVzaGVldHMvd2FsbHMuanNvblwiKTtcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwidHJhcHNcIiwgXCJ4ZW5vX2Fzc2V0cy9zcHJpdGVzaGVldHMvdHJhcHMuanNvblwiKTtcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwidHVycmV0XCIsIFwieGVub19hc3NldHMvc3ByaXRlc2hlZXRzL3R1cnJldF9zaW1wbGUuanNvblwiKTtcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwiVU1BXCIsIFwieGVub19hc3NldHMvc3ByaXRlc2hlZXRzL3VtYS5qc29uXCIpXG4gICAgICAgIHRoaXMubG9hZC5zcHJpdGVzaGVldChcInNsaWNlXCIsIFwiaHc0X2Fzc2V0cy9zcHJpdGVzaGVldHMvc2xpY2UuanNvblwiKVxuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UoXCJEcmF3aW5nXCIsIFwieGVub19hc3NldHMvaW1hZ2VzL2RyYXdpbmcucG5nXCIpXG4gICAgfVxuXG4gICAgc3RhcnRTY2VuZSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgU2xvdDEgPSBuZXcgVmVjMigxNDU1LCAyMTApO1xuICAgICAgICBjb25zdCBTbG90MiA9IG5ldyBWZWMyKDE1NTUsIDIxMCk7XG4gICAgICAgIGNvbnN0IFNsb3QzID0gbmV3IFZlYzIoMTQ1NSwgMzQwKTtcbiAgICAgICAgY29uc3QgU2xvdDQgPSBuZXcgVmVjMigxNTU1LCAzNDApO1xuICAgICAgICBjb25zdCBTbG90NSA9IG5ldyBWZWMyKDE0NTUsIDQ2MCk7XG4gICAgICAgIGNvbnN0IFNsb3Q2ID0gbmV3IFZlYzIoMTU1NSwgNDYwKTtcbiAgICAgICAgY29uc3QgU2xvdDcgPSBuZXcgVmVjMigxNDU1LCA1OTApO1xuICAgICAgICBjb25zdCBTbG90OCA9IG5ldyBWZWMyKDE1NTUsIDU5MCk7XG4gICAgICAgIGNvbnN0IFNsb3Q5ID0gbmV3IFZlYzIoMTQ1NSwgNzEwKTtcbiAgICAgICAgY29uc3QgU2xvdDEwID0gbmV3IFZlYzIoMTU1NSwgNzEwKTtcbiAgICAgICAgY29uc3QgU2xvdE1vbmV5ID0gbmV3IFZlYzIoMTUwMCwgNDApO1xuICAgICAgICBjb25zdCBTbG90U3RhdHVzID0gbmV3IFZlYzIoMTQ2MCwgMTIwKTtcbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhpcy52aWV3cG9ydC5nZXRDZW50ZXIoKTtcblxuICAgICAgICBsZXQgdGlsZW1hcExheWVycyA9IHRoaXMuYWRkLnRpbGVtYXAoXCJsZXZlbFwiLCBuZXcgVmVjMigxLCAxKSk7XG5cbiAgICAgICAgdGhpcy5VSSA9IHRoaXMuYWRkVUlMYXllcihcIlVJXCIpO1xuICAgICAgICBjb25zdCBEcmF3aW5nID0gdGhpcy5hZGQuc3ByaXRlKFwiRHJhd2luZ1wiLCBcIlVJXCIpO1xuICAgICAgICBEcmF3aW5nLnBvc2l0aW9uLmNvcHkoY2VudGVyKTtcbiAgICAgICAgY29uc3QgTW9uZXlMYWJlbCA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJVSVwiLCB7IHBvc2l0aW9uOiBTbG90TW9uZXksIHRleHQ6IFwiMDAwMDBcIiB9KTtcbiAgICAgICAgY29uc3QgU3RhdHVzTGFiZWwgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiVUlcIiwgeyBwb3NpdGlvbjogU2xvdFN0YXR1cywgdGV4dDogXCJTdGF0dXNcIiB9KTtcbiAgICAgICAgdGhpcy5lcnJvckxhYmVsID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcIlVJXCIsIHsgcG9zaXRpb246IG5ldyBWZWMyKDcwMCwgMjAwKSwgdGV4dDonJ30pO1xuICAgICAgICB0aGlzLmVycm9yTGFiZWwudGV4dENvbG9yID0gQ29sb3IuUkVEO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZmxvb3IgPSAodGlsZW1hcExheWVyc1sxXS5nZXRJdGVtcygpWzBdIGFzIE9ydGhvZ29uYWxUaWxlbWFwKTtcbiAgICAgICAgbGV0IHRpbGVtYXBTaXplID0gdGhpcy5mbG9vci5zaXplLnNjYWxlZCgxKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydC5zZXRCb3VuZHMoMCwgMCwgdGlsZW1hcFNpemUueCwgdGlsZW1hcFNpemUueSk7XG5cbiAgICAgICAgdGhpcy5hZGRMYXllcihcInByaW1hcnlcIiwgMTApO1xuXG4gICAgICAgIHRoaXMucGxhY2ViYXNlKG5ldyBWZWMyKDY3MiwzNTIpKTtcblxuXG4gICAgICAgIHRoaXMudmlld3BvcnQuc2V0Wm9vbUxldmVsKDEpO1xuXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFtcbiAgICAgICAgICAgICd0dXJyZXREaWVkJyxcbiAgICAgICAgICAgICdlbmVteURpZWQnLFxuICAgICAgICAgICAgJ3dhbGxEaWVkJyxcbiAgICAgICAgICAgICdnYW1lT3ZlcicsXG4gICAgICAgICAgICBYRU5PX0VWRU5UUy5VTkxPQURfQVNTRVQsXG4gICAgICAgICAgICBYRU5PX0VWRU5UUy5FUlJPUlxuICAgICAgICBdKVxuXG4gICAgfVxuXG4gICAgaGFuZGxlRXZlbnQoZXZlbnQ6IEdhbWVFdmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgWEVOT19FVkVOVFMuVU5MT0FEX0FTU0VUOlxuICAgICAgICAgICAgICAgIGNvbnN0IGFzc2V0ID0gdGhpcy5zY2VuZUdyYXBoLmdldE5vZGUoZXZlbnQuZGF0YS5nZXQoXCJub2RlXCIpKTtcbiAgICAgICAgICAgICAgICBhc3NldC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFhFTk9fRVZFTlRTLkVSUk9SOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1JcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvckxhYmVsLnRleHQgPSBldmVudC5kYXRhLmdldCgnbWVzc2FnZScpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBYRU5PX0VWRU5UUy5UVVJSRVRfRElFRDpcbiAgICAgICAgICAgICAgICBjb25zdCBkZWFkVHVycmV0ID0gZXZlbnQuZGF0YS5nZXQoJ293bmVyJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGl2ZVR1cnJldHMgPSB0aGlzLmFsaXZlVHVycmV0cy5maWx0ZXIoKGUpID0+IGUuaWQgIT0gZGVhZFR1cnJldC5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWFkVHVycmV0cy5wdXNoKGRlYWRUdXJyZXQpOyBcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgWEVOT19FVkVOVFMuV0FMTF9ESUVEOlxuICAgICAgICAgICAgICAgIGNvbnN0IGRlYWRXYWxsID0gZXZlbnQuZGF0YS5nZXQoJ293bmVyJyk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVOZWlnaGJvcnMoZGVhZFdhbGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWxpdmVXYWxscyA9IHRoaXMuYWxpdmVXYWxscy5maWx0ZXIoKGUpID0+IGUuaWQgIT0gZGVhZFdhbGwuaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVhZFdhbGxzLnB1c2goZGVhZFdhbGwpOyBcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgWEVOT19FVkVOVFMuRU5FTVlfRElFRDpcbiAgICAgICAgICAgICAgICBjb25zdCBkZWFkRW5lbXkgPSBldmVudC5kYXRhLmdldCgnb3duZXInKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFsaXZlRW5lbWllcyA9IHRoaXMuYWxpdmVFbmVtaWVzLmZpbHRlcigoZSkgPT4gZS5pZCAhPSBkZWFkRW5lbXkuaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVhZEVuZW1pZXMucHVzaChkZWFkRW5lbXkpOyBcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgWEVOT19FVkVOVFMuR0FNRV9PVkVSOlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlU2NlbmUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgd2hpbGUgKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpIHtcbiAgICAgICAgICAgIGxldCBldmVudCA9IHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChJbnB1dC5pc0tleUp1c3RQcmVzc2VkKCcxJykpIHtcbiAgICAgICAgICAgIHRoaXMucGxhY2luZ01vZGUgPSAnV0FMTCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSW5wdXQuaXNLZXlKdXN0UHJlc3NlZCgnMicpKSB7XG4gICAgICAgICAgICB0aGlzLnBsYWNpbmdNb2RlID0gJ1RVUlJFVCc7XG4gICAgICAgIH1cblxuICAgICAgICBcbiAgICAgICAgaWYgKElucHV0LmlzS2V5SnVzdFByZXNzZWQoJzMnKSkge1xuICAgICAgICAgICAgdGhpcy5wbGFjaW5nTW9kZSA9ICdFTkVNWSc7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChJbnB1dC5pc0tleUp1c3RQcmVzc2VkKCc0JykpIHtcbiAgICAgICAgICAgIHRoaXMucGxhY2luZ01vZGUgPSAnVFJBUCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSW5wdXQuaXNNb3VzZUp1c3RQcmVzc2VkKDApICYmIElucHV0LmdldEdsb2JhbE1vdXNlUHJlc3NQb3NpdGlvbigpLmNsb25lKCkueCA8IDEzODgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQW55T3ZlcmxhcChJbnB1dC5nZXRHbG9iYWxNb3VzZVBvc2l0aW9uKCkuY2xvbmUoKS5hZGQobmV3IFZlYzIoMTYsIDE2KSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChYRU5PX0VWRU5UUy5FUlJPUiwge21lc3NhZ2U6ICdTUEFDRSBPQ0NVUElFRCd9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KFhFTk9fRVZFTlRTLkVSUk9SLCB7bWVzc2FnZTogJyd9KVxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBsYWNpbmdNb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIldBTExcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGFjZVdhbGwoSW5wdXQuZ2V0R2xvYmFsTW91c2VQcmVzc1Bvc2l0aW9uKCkuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJUUkFQXCI6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJUVVJSRVRcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGFjZVR1cnJldChJbnB1dC5nZXRHbG9iYWxNb3VzZVByZXNzUG9zaXRpb24oKS5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkVORU1ZXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxhY2VFbmVtZXkoSW5wdXQuZ2V0R2xvYmFsTW91c2VQcmVzc1Bvc2l0aW9uKCkuY2xvbmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoSW5wdXQuaXNNb3VzZUp1c3RQcmVzc2VkKDApKSB7XG4gICAgICAgICAgICBjb25zdCBjbGlja1BvcyA9IElucHV0LmdldEdsb2JhbE1vdXNlUHJlc3NQb3NpdGlvbigpLmNsb25lKClcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGNsaWNrUG9zKTtcbiAgICAgICAgICAgIGlmIChjbGlja1Bvcy54IDwgMTUwMCAmJiBjbGlja1Bvcy54ID4gMTQxMCkge1xuICAgICAgICAgICAgICAgIGlmIChjbGlja1Bvcy55IDwgMjcwICYmIGNsaWNrUG9zLnkgPiAxNzApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIxLDEgU0xPVDFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsaWNrUG9zLnkgPCA0MDAgJiYgY2xpY2tQb3MueSA+IDMwMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIjEsMiBTTE9UM1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xpY2tQb3MueSA8IDUyMCAmJiBjbGlja1Bvcy55ID4gNDIwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiMSwzIFNMT1Q1XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbGlja1Bvcy55IDwgNjUwICYmIGNsaWNrUG9zLnkgPiA1NDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIxLDQgU0xPVDdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsaWNrUG9zLnkgPCA3ODAgJiYgY2xpY2tQb3MueSA+IDY4MCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIjEsNSBTTE9UOVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xpY2tQb3MueSA8IDg4MCAmJiBjbGlja1Bvcy55ID4gODIwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiMSw2IFBhdXNlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsaWNrUG9zLnggPCAxNjAwICYmIGNsaWNrUG9zLnggPiAxNTEwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsaWNrUG9zLnkgPCAyNzAgJiYgY2xpY2tQb3MueSA+IDE3MCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIjIsMSBTTE9UMlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xpY2tQb3MueSA8IDQwMCAmJiBjbGlja1Bvcy55ID4gMzAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiMiwyIFNMT1Q0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbGlja1Bvcy55IDwgNTIwICYmIGNsaWNrUG9zLnkgPiA0MjApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIyLDMgU0xPVDZcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsaWNrUG9zLnkgPCA2NTAgJiYgY2xpY2tQb3MueSA+IDU0MCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIjIsNCBTTE9UOFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xpY2tQb3MueSA8IDc4MCAmJiBjbGlja1Bvcy55ID4gNjgwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiMiw1IFNMT1QxMFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xpY2tQb3MueSA8IDg4MCAmJiBjbGlja1Bvcy55ID4gODIwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiMiw2IFNwZWVkIFVwXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzQW55T3ZlcmxhcChwb3NpdGlvbjogVmVjMik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCB0aWxlUG9zaXRpb24gPSB0aGlzLmZsb29yLmdldENvbFJvd0F0KHBvc2l0aW9uKTtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5hbGl2ZVdhbGxzLnNvbWUoKGUpID0+IHRoaXMuZmxvb3IuZ2V0Q29sUm93QXQoZS5wb3NpdGlvbikuZXF1YWxzKHRpbGVQb3NpdGlvbikpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxpdmVUdXJyZXRzLnNvbWUoKGUpID0+IHRoaXMuZmxvb3IuZ2V0Q29sUm93QXQoZS5wb3NpdGlvbikuZXF1YWxzKHRpbGVQb3NpdGlvbikpIHx8XG4gICAgICAgICAgICB0aGlzLmFsaXZlV2FsbHMuc29tZSgoZSkgPT4gdGhpcy5mbG9vci5nZXRDb2xSb3dBdChlLnBvc2l0aW9uKS5lcXVhbHModGlsZVBvc2l0aW9uKSkgfHxcbiAgICAgICAgICAgIHRoaXMuYWxpdmVUcmFwcy5zb21lKChlKSA9PiB0aGlzLmZsb29yLmdldENvbFJvd0F0KGUucG9zaXRpb24pLmVxdWFscyh0aWxlUG9zaXRpb24pKSB8fFxuICAgICAgICAgICAgdGhpcy5hbGl2ZUVuZW1pZXMuc29tZSgoZSkgPT4gdGhpcy5mbG9vci5nZXRDb2xSb3dBdChlLnBvc2l0aW9uKS5lcXVhbHModGlsZVBvc2l0aW9uKSlcbiAgICB9XG5cblxuICAgIHBsYWNlVHJhcChwb3NpdGlvbjogVmVjMiwgdHlwZTogVFJBUF9UWVBFKSB7XG4gICAgICAgIGxldCB0cmFwOiBBbmltYXRlZFNwcml0ZSA9IHRoaXMuZGVhZFRyYXBzLnBvcCgpO1xuXG4gICAgICAgIGlmICghdHJhcCkge1xuICAgICAgICAgICAgdHJhcCA9IHRoaXMuYWRkLmFuaW1hdGVkU3ByaXRlKCd0cmFwcycsICdwcmltYXJ5Jyk7XG4gICAgICAgICAgICB0cmFwLnNldENvbGxpc2lvblNoYXBlKG5ldyBBQUJCKFZlYzIuWkVSTywgdHJhcC5zaXplV2l0aFpvb20pKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFwLmFuaW1hdGlvbi5wbGF5SWZOb3RBbHJlYWR5KCdCUk9OWkVfRlJPU1QnLCB0cnVlKTtcbiAgICAgICAgdHJhcC5wb3NpdGlvbiA9IHRoaXMuZmxvb3IuZ2V0Q29sUm93QXQocG9zaXRpb24uYWRkKG5ldyBWZWMyKDE2LCAxNikpKS5tdWx0KG5ldyBWZWMyKDMyLCAzMikpO1xuXG4gICAgICAgIHRyYXAudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWxpdmVUcmFwcy5wdXNoKHRyYXApO1xuICAgIH1cblxuICAgIHBsYWNlYmFzZShwb3NpdGlvbjpWZWMyKXtcbiAgICAgICAgbGV0IGJhc2U6IEFuaW1hdGVkU3ByaXRlO1xuICAgICAgICBiYXNlID0gdGhpcy5hZGQuYW5pbWF0ZWRTcHJpdGUoJ2Jhc2UnLCAncHJpbWFyeScpO1xuICAgICAgICBiYXNlLmFkZEFJKFdhbGxBSSwge30pOyBcbiAgICAgICAgYmFzZS5zZXRDb2xsaXNpb25TaGFwZShuZXcgQUFCQihWZWMyLlpFUk8sIGJhc2Uuc2l6ZVdpdGhab29tKSk7XG4gICAgICAgIGNvbnN0IGN1cnJDb2xSb3cgPSB0aGlzLmZsb29yLmdldENvbFJvd0F0KHBvc2l0aW9uKTtcbiAgICAgICAgYmFzZS5haS5pbml0aWFsaXplQUkoYmFzZSwge1xuICAgICAgICAgICAgbGVmdFRpbGU6IG51bGwsXG4gICAgICAgICAgICByaWdodFRpbGU6IG51bGwsXG4gICAgICAgICAgICBib3RUaWxlOiBudWxsLFxuICAgICAgICAgICAgdG9wVGlsZTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgKGJhc2UuYWkgYXMgV2FsbEFJKS5oZWFsdGggPSAxIDw8IDMwO1xuXG4gICAgICAgIGJhc2UucG9zaXRpb24gPSBjdXJyQ29sUm93LmNsb25lKCkubXVsdChuZXcgVmVjMigzMiwgMzIpKTtcbiAgICAgICAgYmFzZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgYmFzZS5hZGRQaHlzaWNzKCk7XG4gICAgICAgIHRoaXMuYWxpdmVXYWxscy5wdXNoKGJhc2UpO1xuICAgICAgICBiYXNlLmFuaW1hdGlvbi5wbGF5KFwiSURMRVwiLCB0cnVlKTtcbiAgICB9XG5cbiAgICBwbGFjZVdhbGwocG9zaXRpb246IFZlYzIpIHtcbiAgICAgICAgbGV0IHdhbGw6IEFuaW1hdGVkU3ByaXRlID0gdGhpcy5kZWFkV2FsbHMucG9wKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuYWxpdmVXYWxscyk7XG5cbiAgICAgICAgaWYgKCF3YWxsKSB7XG4gICAgICAgICAgICB3YWxsID0gdGhpcy5hZGQuYW5pbWF0ZWRTcHJpdGUoJ3dhbGxzJywgJ3ByaW1hcnknKTtcbiAgICAgICAgICAgIHdhbGwuYWRkQUkoV2FsbEFJLCB7fSk7IFxuICAgICAgICAgICAgd2FsbC5zZXRDb2xsaXNpb25TaGFwZShuZXcgQUFCQihWZWMyLlpFUk8sIHdhbGwuc2l6ZVdpdGhab29tKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGVmdFRpbGU6IEFuaW1hdGVkU3ByaXRlID0gbnVsbCwgcmlnaHRUaWxlOiBBbmltYXRlZFNwcml0ZSA9IG51bGwsIHRvcFRpbGU6IEFuaW1hdGVkU3ByaXRlID0gbnVsbCwgYm90VGlsZTogQW5pbWF0ZWRTcHJpdGUgPSBudWxsO1xuICAgICAgICBwb3NpdGlvbi5hZGQobmV3IFZlYzIoMTYsIDE2KSk7XG4gICAgICAgIGNvbnN0IGN1cnJDb2xSb3cgPSB0aGlzLmZsb29yLmdldENvbFJvd0F0KHBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgbGVmdFRpbGVDb2xSb3cgPSBjdXJyQ29sUm93LmNsb25lKCkuYWRkKG5ldyBWZWMyKC0xLCAwKSk7XG4gICAgICAgIGNvbnN0IHJpZ2h0VGlsZUNvbFJvdyA9IGN1cnJDb2xSb3cuY2xvbmUoKS5hZGQobmV3IFZlYzIoMSwgMCkpO1xuICAgICAgICBjb25zdCBib3RUaWxlQ29sUm93ID0gY3VyckNvbFJvdy5jbG9uZSgpLmFkZChuZXcgVmVjMigwLCAxKSk7XG4gICAgICAgIGNvbnN0IHRvcFRpbGVDb2xSb3cgPSBjdXJyQ29sUm93LmNsb25lKCkuYWRkKG5ldyBWZWMyKDAsIC0xKSk7XG5cbiAgICAgICAgdGhpcy5hbGl2ZVdhbGxzLmZvckVhY2goKHcpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZsb29yLmdldENvbFJvd0F0KHcucG9zaXRpb24pLmVxdWFscyhsZWZ0VGlsZUNvbFJvdykpIHtcbiAgICAgICAgICAgICAgICBsZWZ0VGlsZSA9IHc7XG4gICAgICAgICAgICAgICAgKGxlZnRUaWxlLmFpIGFzIFdhbGxBSSkuYWRkTmVpZ2hib3Iod2FsbCwgTkVJR0hCT1IuUklHSFQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBMRUZUIFRJTEUgRk9VTkQ6ICR7bGVmdFRpbGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5mbG9vci5nZXRDb2xSb3dBdCh3LnBvc2l0aW9uKS5lcXVhbHMocmlnaHRUaWxlQ29sUm93KSkge1xuICAgICAgICAgICAgICAgIHJpZ2h0VGlsZSA9IHc7XG4gICAgICAgICAgICAgICAgKHJpZ2h0VGlsZS5haSBhcyBXYWxsQUkpLmFkZE5laWdoYm9yKHdhbGwsIE5FSUdIQk9SLkxFRlQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSSUdIVCBUSUxFIEZPVU5EOiAke3JpZ2h0VGlsZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZsb29yLmdldENvbFJvd0F0KHcucG9zaXRpb24pLmVxdWFscyhib3RUaWxlQ29sUm93KSkge1xuICAgICAgICAgICAgICAgIGJvdFRpbGUgPSB3O1xuICAgICAgICAgICAgICAgIChib3RUaWxlLmFpIGFzIFdhbGxBSSkuYWRkTmVpZ2hib3Iod2FsbCwgTkVJR0hCT1IuVE9QKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQk9UIFRJTEUgRk9VTkQ6ICR7Ym90VGlsZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZsb29yLmdldENvbFJvd0F0KHcucG9zaXRpb24pLmVxdWFscyh0b3BUaWxlQ29sUm93KSkge1xuICAgICAgICAgICAgICAgIHRvcFRpbGUgPSB3O1xuICAgICAgICAgICAgICAgICh0b3BUaWxlLmFpIGFzIFdhbGxBSSkuYWRkTmVpZ2hib3Iod2FsbCwgTkVJR0hCT1IuQk9UKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVE9QIFRJTEUgRk9VTkQ6ICR7dG9wVGlsZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICB3YWxsLmFpLmluaXRpYWxpemVBSSh3YWxsLCB7XG4gICAgICAgICAgICBsZWZ0VGlsZTogbGVmdFRpbGUsXG4gICAgICAgICAgICByaWdodFRpbGU6IHJpZ2h0VGlsZSxcbiAgICAgICAgICAgIGJvdFRpbGU6IGJvdFRpbGUsXG4gICAgICAgICAgICB0b3BUaWxlOiB0b3BUaWxlXG4gICAgICAgIH0pXG5cbiAgICAgICAgd2FsbC5wb3NpdGlvbiA9IGN1cnJDb2xSb3cuY2xvbmUoKS5tdWx0KG5ldyBWZWMyKDMyLCAzMikpO1xuICAgICAgICB3YWxsLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB3YWxsLmFkZFBoeXNpY3MoKTtcbiAgICAgICAgdGhpcy5hbGl2ZVdhbGxzLnB1c2god2FsbCk7XG4gICAgfVxuXG4gICAgcGxhY2VUdXJyZXQocG9zaXRpb246IFZlYzIpIHtcbiAgICAgICAgbGV0IHR1cnJldCA9IHRoaXMuZGVhZFR1cnJldHMucG9wKCk7XG4gICAgICAgIGNvbnN0IGN1cnJDb2xSb3cgPSB0aGlzLmZsb29yLmdldENvbFJvd0F0KHBvc2l0aW9uLmFkZChuZXcgVmVjMigxNiwgMTYpKSk7XG5cbiAgICAgICAgaWYgKCF0dXJyZXQpIHtcbiAgICAgICAgICAgIHR1cnJldCA9IHRoaXMuYWRkLmFuaW1hdGVkU3ByaXRlKFwidHVycmV0XCIsIFwicHJpbWFyeVwiKTtcbiAgICAgICAgICAgIHR1cnJldC5hZGRBSShUdXJyZXRBSSwgeyBiYXR0bGVNYW5hZ2VyOiB0aGlzLmJhdHRsZU1hbmFnZXIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHVycmV0LnBvc2l0aW9uID0gY3VyckNvbFJvdy5jbG9uZSgpLm11bHQobmV3IFZlYzIoMzIsIDMyKSk7XG4gICAgICAgIHR1cnJldC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdHVycmV0LmFkZFBoeXNpY3MoKTtcbiAgICAgICAgdGhpcy5hbGl2ZVR1cnJldHMucHVzaCh0dXJyZXQpO1xuICAgIH1cblxuICAgIHBsYWNlRW5lbWV5KHBvc2l0aW9uOiBWZWMyKSB7XG4gICAgICAgIGxldCBlbmVteSA9IHRoaXMuZGVhZEVuZW1pZXMucG9wKCk7XG4gICAgICAgIGNvbnN0IGN1cnJDb2xSb3cgPSB0aGlzLmZsb29yLmdldENvbFJvd0F0KHBvc2l0aW9uLmFkZChuZXcgVmVjMigxNiwgMTYpKSk7XG5cbiAgICAgICAgaWYgKCFlbmVteSkge1xuICAgICAgICAgICAgZW5lbXkgPSB0aGlzLmFkZC5hbmltYXRlZFNwcml0ZShcIlVNQVwiLCBcInByaW1hcnlcIik7XG4gICAgICAgICAgICBlbmVteS5hZGRBSShFbmVteUFJLCB7IGhlYWx0aDogMzAsIEJhc2VQb3M6IG5ldyBWZWMyKDY3MiwzNTIpLFNwYXduUG9zOmN1cnJDb2xSb3cuY2xvbmUoKS5tdWx0KG5ldyBWZWMyKDMyLCAzMikpLCBhbGl2ZVdhbGxzOiB0aGlzLmFsaXZlV2FsbHMsIGFsaXZlVHVycmV0czogdGhpcy5hbGl2ZVR1cnJldHMsIGZsb29yOiB0aGlzLmZsb29yLCBiYXR0bGVNYW5hZ2VyOiB0aGlzLmJhdHRsZU1hbmFnZXIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgKGVuZW15LmFpIGFzIEJhdHRsZXJBSSkuaGVhbHRoID0gMzA7IFxuICAgICAgICBlbmVteS5zZXRBSUFjdGl2ZSh0cnVlLCB7fSk7XG4gICAgICAgIGVuZW15LmFuaW1hdGlvbi5wbGF5SWZOb3RBbHJlYWR5KFwiSURMRVwiLCB0cnVlKTtcbiAgICAgICAgZW5lbXkucG9zaXRpb24gPSBjdXJyQ29sUm93LmNsb25lKCkubXVsdChuZXcgVmVjMigzMiwgMzIpKTtcbiAgICAgICAgZW5lbXkudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIGVuZW15LmFkZFBoeXNpY3MoKTtcbiAgICAgICAgdGhpcy5hbGl2ZUVuZW1pZXMucHVzaChlbmVteSk7XG4gICAgfVxuXG4gICAgdXBkYXRlTmVpZ2hib3JzKHdhbGw6IEFuaW1hdGVkU3ByaXRlKSB7XG4gICAgICAgIGNvbnN0IHdhbGxBSSA9IHdhbGwuYWkgYXMgV2FsbEFJO1xuICAgICAgICB3YWxsQUkubmVpZ2hib3JpbmdXYWxsLmZvckVhY2goKHcsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpciA9IDA7XG4gICAgICAgICAgICAgICAgc3dpdGNoKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBORUlHSEJPUi5MRUZUOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIE5FSUdIQk9SLkJPVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpciA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTkVJR0hCT1IuVE9QOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIE5FSUdIQk9SLlJJR0hUOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGlyID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKHcuYWkgYXMgV2FsbEFJKS5kZWxOZWlnaGJvcihkaXIpOyAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICB9XG5cbiAgICBmaW5kRW5lbXlJblJhbmdlKGZyb206IFZlYzIsIHJhbmdlOiBudW1iZXIpOiBCYXR0bGVyQUkgfCB1bmRlZmluZWQge1xuICAgICAgICBpZiAoIXRoaXMuYWxpdmVFbmVtaWVzLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWxpdmVFbmVtaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZnJvbS5kaXN0YW5jZVRvKHRoaXMuYWxpdmVFbmVtaWVzW2ldLnBvc2l0aW9uKSA8IHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmFsaXZlRW5lbWllc1tpXS5haSBhcyBCYXR0bGVyQUkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XG5cbmV4cG9ydCBjb25zdCBDQU5WQVNfU0laRSA9IHtcbiAgICB4OiAxNjAwLFxuICAgIHk6IDkwMFxufVxuXG5leHBvcnQgZW51bSBXQUxMX1RZUEUge1xuICAgIERJUlQgPSBcIkRJUlRcIixcbiAgICBXT09EID0gXCJXT09EXCIsXG4gICAgU1RPTkUgPSBcIlNUT05FXCIsXG4gICAgRklCRVIgPSBcIkZJQkVSXCJcbn1cblxuZXhwb3J0IGVudW0gVFJBUF9UWVBFIHtcbiAgICBBQ0lEID0gXCJBQ0lEXCIsXG4gICAgTkVUID0gXCJORVRcIixcbiAgICBGUk9TVCA9IFwiRlJPU1RcIixcbiAgICBGTEFNRSA9IFwiRkxBTUVcIlxufVxuXG5leHBvcnQgZW51bSBYRU5PX0VWRU5UUyB7XG4gICAgRVJST1IgPSBcIkVSUk9SXCIsXG4gICAgVU5MT0FEX0FTU0VUID0gXCJVTkxPQURfQVNTRVRcIixcbiAgICBXQUxMX0RJRUQgPSBcIldBTExfRElFRFwiLFxuICAgIEVORU1ZX0RJRUQgPSBcIkVORU1ZX0RJRURcIixcbiAgICBUVVJSRVRfRElFRCA9IFwiVFVSUkVUX0RJRURcIixcbiAgICBHQU1FX09WRVIgPSBcIkdBTUVfT1ZFUlwiLFxuICAgIFVQR1JBREUgPSBcIlVQR1JBREVcIlxufVxuXG5leHBvcnQgZW51bSBYRU5PX0VGRkVDVF9UWVBFIHtcbiAgICBGSVJFX0VGRkVDVCA9IFwiRklSRV9FRkZFQ1RcIixcbiAgICBTTE9XX0VGRkVDVCA9IFwiU0xPV19FRkZFQ1RcIixcbiAgICBBQ0lEX0VGRkVDVCA9IFwiQUNJRF9FRkZFQ1RcIlxufVxuXG5leHBvcnQgZW51bSBYRU5PX0FUS0VSX1RZUEUge1xuICAgIEZSSUVORCA9IFwiRlJJTkVEXCIsXG4gICAgRU5FTVkgPSBcIkVORU1ZXCJcbn1cblxuIiwiaW1wb3J0IEdhbWUgZnJvbSBcIi4vV29sZmllMkQvTG9vcC9HYW1lXCI7XG5pbXBvcnQgUmVnaXN0cnlNYW5hZ2VyIGZyb20gXCIuL1dvbGZpZTJEL1JlZ2lzdHJ5L1JlZ2lzdHJ5TWFuYWdlclwiO1xuaW1wb3J0IE1haW5NZW51IGZyb20gXCIuL2h3NC9TY2VuZXMvTWFpbk1lbnVcIjtcbmltcG9ydCBHb2FwQWN0aW9uUGxhbm5lciBmcm9tIFwiLi9Xb2xmaWUyRC9BSS9Hb2FwQWN0aW9uUGxhbm5lclwiO1xuaW1wb3J0IFNwbGFzaFNjcmVlbiBmcm9tIFwiLi9odzQvU2NlbmVzL1NwbGFzaFNjcmVlblwiO1xuaW1wb3J0IHsgQ0FOVkFTX1NJWkUgfSBmcm9tIFwiLi9odzQvY29uc3RhbnRzXCI7XG5cbi8vIFRoZSBtYWluIGZ1bmN0aW9uIGlzIHlvdXIgZW50cnlwb2ludCBpbnRvIFdvbGZpZTJELiBTcGVjaWZ5IHlvdXIgZmlyc3Qgc2NlbmUgYW5kIGFueSBvcHRpb25zIGhlcmUuXG4oZnVuY3Rpb24gbWFpbigpe1xuICAgIC8vIFJ1biBhbnkgdGVzdHNcbiAgICBydW5UZXN0cygpO1xuXG4gICAgLy8gU2V0IHVwIG9wdGlvbnMgZm9yIG91ciBnYW1lXG4gICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgIGNhbnZhc1NpemU6IHt4OiBDQU5WQVNfU0laRS54LCB5OiBDQU5WQVNfU0laRS55fSwgICAgICAgICAgLy8gVGhlIHNpemUgb2YgdGhlIGdhbWVcbiAgICAgICAgY2xlYXJDb2xvcjoge3I6IDAuMSwgZzogMC4xLCBiOiAwLjF9LCAgIC8vIFRoZSBjb2xvciB0aGUgZ2FtZSBjbGVhcnMgdG9cbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogXCJmb3J3YXJkXCIsIGtleXM6IFtcIndcIl19LFxuICAgICAgICAgICAge25hbWU6IFwiYmFja3dhcmRcIiwga2V5czogW1wic1wiXX0sXG4gICAgICAgICAgICB7bmFtZTogXCJsZWZ0XCIsIGtleXM6IFtcImFcIl19LFxuICAgICAgICAgICAge25hbWU6IFwicmlnaHRcIiwga2V5czogW1wiZFwiXX0sXG4gICAgICAgICAgICB7bmFtZTogXCJwaWNrdXBcIiwga2V5czogW1wiZVwiXX0sXG4gICAgICAgICAgICB7bmFtZTogXCJkcm9wXCIsIGtleXM6IFtcInFcIl19LFxuICAgICAgICAgICAge25hbWU6IFwic2xvdDFcIiwga2V5czogW1wiMVwiXX0sXG4gICAgICAgICAgICB7bmFtZTogXCJzbG90MlwiLCBrZXlzOiBbXCIyXCJdfSxcbiAgICAgICAgXSxcbiAgICAgICAgdXNlV2ViR0w6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRlbGwgdGhlIGdhbWUgd2Ugd2FudCB0byB1c2Ugd2ViZ2xcbiAgICAgICAgc2hvd0RlYnVnOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hldGhlciB0byBzaG93IGRlYnVnIG1lc3NhZ2VzLiBZb3UgY2FuIGNoYW5nZSB0aGlzIHRvIHRydWUgaWYgeW91IHdhbnRcbiAgICB9XG5cblxuICAgIC8vIENyZWF0ZSBhIGdhbWUgd2l0aCB0aGUgb3B0aW9ucyBzcGVjaWZpZWRcbiAgICBjb25zdCBnYW1lID0gbmV3IEdhbWUob3B0aW9ucyk7XG5cbiAgICAvLyBTdGFydCBvdXIgZ2FtZVxuICAgIGdhbWUuc3RhcnQoU3BsYXNoU2NyZWVuLCB7fSk7XG59KSgpO1xuXG5mdW5jdGlvbiBydW5UZXN0cygpe1xuICAgIFxufTsiXX0=
